<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CaelumTian的博客</title>
  <subtitle>你若盛开，清风自来，心若沉浮 浅笑安然</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-28T11:54:42.112Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>CaelumTian</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>redux 源码解析</title>
    <link href="http://yoursite.com/2019/01/26/redux%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2019/01/26/redux源码解析/</id>
    <published>2019-01-26T08:27:05.000Z</published>
    <updated>2019-03-28T11:54:42.112Z</updated>
    
    <content type="html"><![CDATA[<p>redux 的思想我们已经看过了。我们简单的看下，redux 的具体实现。redux 主要提供了如下几个功能： </p>
<ul>
<li>创建 store，即：createStore()。</li>
<li>创建出来的 store 提供subscribe，dispatch，getState这些方法。</li>
<li>将多个reducer合并为一个reducer，即：combineReducers()。</li>
<li>应用中间件，即applyMiddleware()。</li>
</ul>
<a id="more"></a>
<h2 id="createStore-实现"><a href="#createStore-实现" class="headerlink" title="createStore 实现"></a>createStore 实现</h2><p>简化版代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer, preloadedState, enhancer</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> currentReducer = reducer <span class="comment">// reducer</span></div><div class="line">    <span class="keyword">let</span> currentState = preloadedState <span class="comment">// 默认 state</span></div><div class="line">    <span class="keyword">let</span> currentListeners = [] <span class="comment">// 发布订阅模式队列</span></div><div class="line">    <span class="keyword">let</span> nextListeners = currentListeners <span class="comment">// 浅拷贝下这个队列</span></div><div class="line">    <span class="keyword">let</span> isDispatching = <span class="literal">false</span> <span class="comment">// isDispatching 标志是否正在执行dispatch</span></div><div class="line"></div><div class="line">    <span class="comment">// @enhancer</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'undefined'</span>) &#123;</div><div class="line">        <span class="comment">// 如果enhancer存在，那他必须是个function, 否则throw Error哈</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'function'</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the enhancer to be a function.'</span>)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> enhancer(createStore)(reducer, preloadedState)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// @1</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getState</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// 为了确保state的正确性(获取最新的state)，判断是否正在 dispatch</span></div><div class="line">        <span class="keyword">if</span> (isDispatching) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(.../);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 确定currentState是当前的state 看 -&gt; subscribe</span></div><div class="line">        <span class="keyword">return</span> currentState</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// @2</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">listener</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (isDispatching) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(.../);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">let</span> isSubscribed = <span class="literal">true</span>;</div><div class="line">        <span class="comment">// 如果，nextListeners 和 currentListeners 是一个引用，就拷贝 currentListeners 给 nextListeners</span></div><div class="line">        ensureCanMutateNextListeners()</div><div class="line">        <span class="comment">// 添加一个订阅函数</span></div><div class="line">        nextListeners.push(listener)</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unsubscribe</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span> (!isSubscribed) &#123;</div><div class="line">                <span class="comment">// 没有直接订阅 则 return</span></div><div class="line">                <span class="keyword">return</span></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 同理</span></div><div class="line">            <span class="keyword">if</span> (isDispatching) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">''</span>)</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 取消订阅</span></div><div class="line">            isSubscribed = <span class="literal">false</span></div><div class="line">            <span class="comment">// 保存订阅快照</span></div><div class="line">            ensureCanMutateNextListeners()</div><div class="line">            <span class="comment">// 找到并删除当前的listener</span></div><div class="line">            <span class="keyword">const</span> index = nextListeners.indexOf(listener)</div><div class="line">            nextListeners.splice(index, <span class="number">1</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// @3</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</div><div class="line">        <span class="comment">// 各种常规判断</span></div><div class="line">        ...</div><div class="line">        <span class="comment">// dispatch中不可以有进行的dispatch</span></div><div class="line">        <span class="keyword">if</span> (isDispatching) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Reducers may not dispatch actions.'</span>)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 执行时标记为true</span></div><div class="line">            isDispatching = <span class="literal">true</span></div><div class="line">            <span class="comment">// 执行reducer</span></div><div class="line">            currentState = currentReducer(currentState, action)</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="comment">// 最终执行， isDispatching标记为false， 即完成状态</span></div><div class="line">            isDispatching = <span class="literal">false</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 执行所有监听队列</span></div><div class="line">        <span class="keyword">const</span> listeners = (currentListeners = nextListeners)</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; listeners.length; i++) &#123;</div><div class="line">            <span class="keyword">const</span> listener = listeners[i]</div><div class="line">            <span class="comment">// 执行每一个监听函数</span></div><div class="line">            listener()</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 返回传入的action</span></div><div class="line">        <span class="keyword">return</span> action</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 初始化数据</span></div><div class="line">    dispatch(&#123;</div><div class="line">        type: ActionTypes.INIT</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        dispatch,</div><div class="line">        subscribe,</div><div class="line">        getState,</div><div class="line">        replaceReducer,</div><div class="line">        [$$observable]: observable</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="getState"><a href="#getState" class="headerlink" title="getState"></a>getState</h3><p>可以看出，createStore 将 state 通过闭包保存在了 currentState 中，通过调用 getState 返回。为了能够初始化数据，在 createStore 的最后，dispath 了一个 <code>ActionTypes.INIT</code> 请求。在这里 <code>ActionTypes.INIT</code> 实际上为一个随机字符串 <code>@@redux/INIT${randomString()}</code>，这就保证了其不会命中任何 <code>action</code>，而是走默认 <code>return state</code> 完成数据初始化过程。</p>
<h3 id="subscribe"><a href="#subscribe" class="headerlink" title="subscribe"></a>subscribe</h3><p>一个简单的发布订阅模式，所有注册函数保存在 newListeners (执行的时候，会用 currentListeners) 队列中。返回一个 unsubscribe 来清除注册函数。</p>
<h3 id="dispatch"><a href="#dispatch" class="headerlink" title="dispatch"></a>dispatch</h3><p>直接调用 reducer 函数来进行处理，并且执行所有的 listeners。可以看见整个过程都是同步的，这也是 redux 不能在 reducer 中书写异步的原因之一(最主要的还是因为纯函数，不能涉及IO)。<br>这里 dispatch 对参数 action 做了检查：action 必须是一个纯对象，且必须有 type 属性。</p>
<h2 id="combinReducers"><a href="#combinReducers" class="headerlink" title="combinReducers"></a>combinReducers</h2><p>combinReducers 可以将多个 reducers 合并在成为一个 reducers，从而给 createStore 使用。简单的用法如下。简单来说就是讲，各个 reducer 上的 state 统一管理在一个 key 值上，action 判断都统一放在一起。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">combineReducers(&#123;</div><div class="line">    key1: reducer1,</div><div class="line">    key2: reducer2</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">combineReducers</span>(<span class="params">reducers</span>) </span>&#123;</div><div class="line">    <span class="comment">// 先获取传入reducers对象的所有key</span></div><div class="line">    <span class="keyword">const</span> reducerKeys = <span class="built_in">Object</span>.keys(reducers)</div><div class="line">    <span class="comment">// 最后真正有效的reducer存在这里</span></div><div class="line">    <span class="keyword">const</span> finalReducers = &#123;&#125; </div><div class="line">    </div><div class="line">    <span class="comment">// 下面从reducers中筛选出有效的reducer</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; reducerKeys.length; i++)&#123;</div><div class="line">        <span class="keyword">const</span> key  = reducerKeys[i]</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> reducers[key] === <span class="string">'function'</span>) &#123;</div><div class="line">            finalReducers[key] = reducers[key] </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 有效的 key</span></div><div class="line">    <span class="keyword">const</span> finalReducerKeys = <span class="built_in">Object</span>.keys(finalReducers);</div><div class="line">    </div><div class="line">    <span class="keyword">let</span> shapeAssertionError</div><div class="line">  	<span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 检查finalReducer中的reducer接受一个初始action或一个未知的action时，是否依旧能够返回有效的值。</span></div><div class="line">    	assertReducerShape(finalReducers)</div><div class="line">  	&#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">    	shapeAssertionError = e</div><div class="line">  	&#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 返回合并后的reducer</span></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">combination</span>(<span class="params">state= &#123;&#125;, action</span>)</span>&#123;</div><div class="line">    	<span class="comment">// 取得每个子reducer对应的state，与action一起作为参数给每个子reducer执行。</span></div><div class="line">    	<span class="keyword">let</span> hasChanged = <span class="literal">false</span> <span class="comment">//标志state是否有变化</span></div><div class="line">        <span class="keyword">let</span> nextState = &#123;&#125;</div><div class="line">        <span class="comment">// 执行所有的子 reducer </span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; finalReducerKeys.length; i++) &#123;</div><div class="line">            <span class="keyword">const</span> key = finalReducerKeys[i]</div><div class="line">            <span class="keyword">const</span> reducer = finalReducers[key]</div><div class="line">            <span class="comment">// 当前key的state值</span></div><div class="line">            <span class="keyword">const</span> previousStateForKey = state[key]</div><div class="line">            <span class="comment">// 执行reducer， 返回当前state</span></div><div class="line">            <span class="keyword">const</span> nextStateForKey = reducer(previousStateForKey, action)</div><div class="line">            <span class="comment">//存到nextState中（总的状态）</span></div><div class="line">            nextState[key] = nextStateForKey</div><div class="line">            <span class="comment">// 如果子reducer不能处理该action，那么会返回previousStateForKey</span></div><div class="line">            hasChanged = hasChanged || previousStateForKey !== nextStateForKey</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 当所有状态都没改变时，我们直接返回之前的state就可以了。</span></div><div class="line">        <span class="keyword">return</span> hasChanged ? nextState : state</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们可以看见，融合后的 reducer 当一个 action 触发时，不仅仅是该 action 对应的 reducer 执行了，其他所有的 reducer 也同时被执行了，只是 action type 不匹配，state 的值不变而已。这种空操作，可能会存在性能的浪费。(理论上大部分都不会有问题，只有节点数量多了才会有，最重要的优化是：没问题之前不做优化)<br>我们可以借助 redux-ignore 来指定黑白名单的方式，返回优化后的 reducer。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; ignoreActions, filterActions &#125; <span class="keyword">from</span> <span class="string">'redux-ignore'</span>;</div><div class="line"> </div><div class="line"><span class="comment">// 黑名单写法</span></div><div class="line">ignoreActions(reducer, [ARRAY_OF_ACTIONS])</div><div class="line">ignoreActions(reducer, (action) =&gt; !action.valid)</div><div class="line"></div><div class="line"><span class="comment">// 白名单写法</span></div><div class="line">filterActions(reducer, [ARRAY_OF_ACTIONS])</div><div class="line">filterActions(reducer, (action) =&gt; action.valid)</div></pre></td></tr></table></figure>
<p>原理也很简单，就是利用  actions.indexOf(action.type) &gt;= 0 来决定 reducer 是否触发而已。</p>
<h2 id="applyMiddleware-中间件"><a href="#applyMiddleware-中间件" class="headerlink" title="applyMiddleware 中间件"></a>applyMiddleware 中间件</h2><p>我们知道 reducer 本身是一个纯函数，纯函数要求自身不能和 IO 产生关联。这也就注定 reducer 本身是一个同步函数。同样，我们在 <code>store.dispath</code> 源码中看见，当一个 dispath 发出后，所有的监听回调也就同步发生了。<br>在实际业务中，我们的请求一般都是异步的，那么做异步请求处理就只能放在 dispatch 前来做。所以我们希望有一种通用的方案，来扩展 dispath 的功能。这就是中间件的功能。下面我们思考因该如何来做一个中间件：</p>
<h3 id="封装-dispath"><a href="#封装-dispath" class="headerlink" title="封装 dispath"></a>封装 dispath</h3><p>加入我们想要加入一个 dispath 前后记录日志的功能。我们可能会这么写 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">'action 触发前'</span>);</div><div class="line">store.dispath(action);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'action 触发完毕'</span>);</div></pre></td></tr></table></figure>
<p>为了方便复用，我们扩展其为一个函数： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchAndLog</span>(<span class="params">store, action</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'action 触发: '</span>, action.type);</div><div class="line">    store.dispatch(action);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'action 触发完毕'</span>, store.getState());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="重写-dispatch"><a href="#重写-dispatch" class="headerlink" title="重写 dispatch"></a>重写 dispatch</h3><p>现在我们可以通过调用 <code>dispatchAndLog</code> 来完成带有日志的 dispath。日志记录功能可以直接反映到 dispath 上面，不改变原有的用法，更直接些。通过复写 dispath 来实现扩展：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 保存 dispath 副本</span></div><div class="line"><span class="keyword">let</span> next = store.dispatch;</div><div class="line">store.diapatch = <span class="function"><span class="keyword">function</span> (<span class="params">store, action</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'action 触发: '</span>, action.type);</div><div class="line">    <span class="keyword">let</span> result = store.dispatch(action);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'action 触发完毕'</span>, store.getState());</div><div class="line">    <span class="comment">// 返回 action</span></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们随便使用 dispath 就可以实现日志的打印，而不用费事的去使用 <code>dispatchAndLog</code> 函数。</p>
<h3 id="新的扩展"><a href="#新的扩展" class="headerlink" title="新的扩展"></a>新的扩展</h3><p>实际开发中，我们可能不仅需要日志功能，还有可能需要其他的扩展功能。比如异常上报。为此我们需要将上述操作写成两个函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extendsLogFunc</span>(<span class="params">store, action</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> next = store.dispatch;</div><div class="line">    store.diapatch = <span class="function"><span class="keyword">function</span> (<span class="params">store, action</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'action 触发: '</span>, action.type);</div><div class="line">        <span class="keyword">let</span> result = next(action);</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'action 触发完毕'</span>, store.getState());</div><div class="line">        <span class="comment">// 返回 action</span></div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extendsErrorPublish</span>(<span class="params">store, action</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> next = store.dispatch;</div><div class="line">    store.diapatch = <span class="function"><span class="keyword">function</span> (<span class="params">store, action</span>) </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">return</span> next(action)</div><div class="line">        &#125; <span class="keyword">catch</span>(e) &#123;</div><div class="line">            <span class="comment">// 错误处理</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用两个扩展：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">extendsLogFunc(store, aciton);</div><div class="line">extendsErrorPublish(store, action);</div></pre></td></tr></table></figure>
<h3 id="middleware-方法"><a href="#middleware-方法" class="headerlink" title="middleware 方法"></a>middleware 方法</h3><p>从上面，我们可以看出，其实扩展多个中间件，就是复写多次 <code>store.dispatch</code> 方法。每次 next 缓存的都是上一个中间件替换好的 dispatch 方法。即如下链式调用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">next(next(next(...args)))</div></pre></td></tr></table></figure>
<p>即洋葱模型。我们提供这样一个封装函数，来实现这一模型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params">store, middleswares</span>) </span>&#123;</div><div class="line">    middlewares = middlewares.slice();</div><div class="line">    <span class="comment">// 翻转是为了实现从内向外逐步执行</span></div><div class="line">    middlewares.reverse();</div><div class="line">    middlewares.forEach(<span class="function"><span class="params">middleware</span> =&gt;</span></div><div class="line">        store.dispatch = middleware(store);</div><div class="line">    )</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对 <code>extendsLogFunc</code> 稍作改动(extendsErrorPublish， 同理) </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extendsLogFunc</span>(<span class="params">store</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> next = store.dispatch;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">action</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'action 触发: '</span>, action.type);</div><div class="line">        <span class="keyword">let</span> result = next(action);</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'action 触发完毕'</span>, store.getState());</div><div class="line">        <span class="comment">// 返回 action</span></div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就可以使用了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">applyMiddleware(store, [extendsLogFunc, extendsErrorPublish])</div></pre></td></tr></table></figure>
<h3 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h3><p>我们观察改动后的 extendsLogFunc。无非就是层层准备参数，最后一起使用，这样我们很容易想到函数柯里化：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> extendsLogFunc = <span class="function"><span class="params">store</span> =&gt;</span> next =&gt; <span class="function"><span class="params">action</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'action 触发: '</span>, action.type);</div><div class="line">    <span class="keyword">let</span> result = next(action);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'action 触发完毕'</span>, store.getState());</div><div class="line">    <span class="comment">// 返回 action</span></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了能顺利运行，我们也需要晒微修改下 applyMiddleware，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params">store, middlewares</span>) </span>&#123;</div><div class="line">    middlewares = middlewares.slice();</div><div class="line">    middlewares.reverse();</div><div class="line">    <span class="keyword">let</span> dispatch = store.dispath;</div><div class="line">    middlewares.forEach(<span class="function"><span class="params">middleware</span> =&gt;</span></div><div class="line">        dispatch = middleware(store)(dispatch);</div><div class="line">    )</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们再看，createStore 的源码，如果我们传入了第三个参数 enhancer 作为中间件，那么调用的是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> enhancer(createStore)(reducer, preloadedState)</div></pre></td></tr></table></figure>
<p>典型的柯里化调用，为此，我们最后修改下 <code>applyMiddleware</code> 函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params">middlewares</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">createStore</span>) =&gt;</span> (reducer, preloadedState) =&gt; &#123;</div><div class="line">        <span class="keyword">const</span> stores = createStore(reducer, preloadedState);</div><div class="line">        <span class="keyword">let</span> dispatch = store.dispath;</div><div class="line">        middlewares = middlewares.slice();</div><div class="line">        middlewares.reverse();</div><div class="line">        middlewares.forEach(<span class="function"><span class="params">middleware</span> =&gt;</span></div><div class="line">            dispatch = middleware(store)(dispatch);</div><div class="line">        )</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.assing(&#123;&#125;, store, &#123;dispath&#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="string">``</span><span class="string">` </span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">这样，我们就完成了，使用如下：</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">`</span><span class="string">``</span>javascript</div><div class="line"><span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">'redux'</span></div><div class="line"><span class="keyword">let</span> store = createStore(reducers, applyMiddleware([extendsLogFunc, extendsErrorPublish]));</div></pre></td></tr></table></figure>
<h3 id="看下源码"><a href="#看下源码" class="headerlink" title="看下源码"></a>看下源码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params">...middlewares</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="params">createStore</span> =&gt;</span> (...args) =&gt; &#123;</div><div class="line">    <span class="keyword">const</span> store = createStore(...args)</div><div class="line">    <span class="keyword">let</span> dispatch = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</div><div class="line">        <span class="string">`Dispatching while constructing your middleware is not allowed. `</span> +</div><div class="line">          <span class="string">`Other middleware would not be applied to this dispatch.`</span></div><div class="line">      )</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">const</span> middlewareAPI = &#123;</div><div class="line">      getState: store.getState,</div><div class="line">      dispatch: <span class="function">(<span class="params">...args</span>) =&gt;</span> dispatch(...args)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">const</span> chain = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(middlewareAPI))</div><div class="line">    <span class="comment">// 实现洋葱模型</span></div><div class="line">    dispatch = compose(...chain)(store.dispatch) </div><div class="line">    <span class="comment">// 返回增强的store</span></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      ...store,</div><div class="line">      dispatch</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和我们的书写思路差不多吧，在源码里，通过 compose 方法，来实现的洋葱模型；compose 函数式编程中用来复合代码的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funcs</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (funcs.length === <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (funcs.length === <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> funcs[<span class="number">0</span>]</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> funcs.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> (...args) =&gt; a(b(...args)))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在搭配 react 的时候，我们通常不会直接使用 <code>redux</code> 因为这样需要关注的优化点就有点多。通常情况下，我们会选择 <code>react-redux</code> 来完成和 react 的结合。下篇文章着重介绍下，<code>react-redux</code> 源码，并针对 redux 可能带来的性能问题进行说明。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;redux 的思想我们已经看过了。我们简单的看下，redux 的具体实现。redux 主要提供了如下几个功能： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建 store，即：createStore()。&lt;/li&gt;
&lt;li&gt;创建出来的 store 提供subscribe，dispatch，getState这些方法。&lt;/li&gt;
&lt;li&gt;将多个reducer合并为一个reducer，即：combineReducers()。&lt;/li&gt;
&lt;li&gt;应用中间件，即applyMiddleware()。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="redux" scheme="http://yoursite.com/tags/redux/"/>
    
      <category term="前端源码解析" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>前端数据流管理</title>
    <link href="http://yoursite.com/2019/01/02/react%E6%95%B0%E6%8D%AE%E6%B5%81%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2019/01/02/react数据流管理/</id>
    <published>2019-01-02T06:19:28.000Z</published>
    <updated>2019-03-26T08:26:17.930Z</updated>
    
    <content type="html"><![CDATA[<p>react 的范式为 <code>UI = render(state)</code>，用户的界面完全取决于数据层。react 中通过管理状态（state）来实现对组件的管理，当 state 发生变更后，react 就会重新渲染界面，组件与组件之间也经常需要共享状态。如果缺乏一个好的状态管理方案，那么共享数据将变得麻烦，同时状态不受控的话会让我们很难跟踪调试程序。</p>
<a id="more"></a>
<p>react 本身采用的时自上而下的单向组件数据流，我们通常将代码抽成 Smart Component 组件和 Dumb Component 组件。通过 proprs 来连接，来完成功能。针对小的项目，这就足够了，但是项目大了以后会出现如下几个问题：</p>
<ol>
<li>如何跨组件实现状态同步<br>react 16 提供新的的 context 可以解决这一问题，但是 context 一般会放顶级组件上，一旦有改变将触发所有组件的re-render，这将带来损耗。</li>
<li>如何让状态变得可预知，甚至可回溯</li>
<li>如何避免组件臃肿，Model 和 View 都混在了一起</li>
</ol>
<p>为此前端提出了一个通用解决思路：把组件之间需要共享的状态抽取出来，遵循特定的约定，统一来管理，让状态的变化可以预测。针对这个思路，我们来看下都有哪些实现。 (隔离变化，约定大于配置，其实不管是 Vue，还是 React 都对其状态管理有着同样的要求)</p>
<h2 id="单向数据流体系"><a href="#单向数据流体系" class="headerlink" title="单向数据流体系"></a>单向数据流体系</h2><h3 id="Store-模式"><a href="#Store-模式" class="headerlink" title="Store 模式"></a>Store 模式</h3><p>我们将状态存在一个全局变量 <code>store</code> 里面，store 里面设置一些方法来控制 state 的改变。<br><code>约定</code>：组件只能通过调用 store 上的方法来改变数据，而不能直接操作 store 里面的 state。这样就保证了数据的可追溯。 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> store = &#123;</div><div class="line">    state: &#123;</div><div class="line">        data: &#123;&#125;</div><div class="line">    &#125;,</div><div class="line">    setDataAction(newValue) &#123;</div><div class="line">        <span class="keyword">this</span>.state.data = newValue;</div><div class="line">    &#125;,</div><div class="line">    clearDataAction() &#123;</div><div class="line">        <span class="keyword">this</span>.state.data = &#123;&#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>进一步，为了方便管理 view 层调用相应的 store 方法，我们包装一个 <code>dispatcher</code> 来映射 view 层的一个动作 action 到 store 上。这样一个 flux 架构就诞生了。</p>
<h3 id="Flux"><a href="#Flux" class="headerlink" title="Flux"></a>Flux</h3><p>Flux 本身是一种思想，一种约定。Flux 把一个应用分成 4 个部分：View, Action, Dispatcher, Store</p>
<img src="/2019/01/02/react数据流管理/a3.png" alt="a3.png" title="">   
<p>View 层用来展示数据，当用户操作UI上的某个操作，就会触发 Dispatcher。<br>Dispatcher 就像一个请求中转站一样会 dispatch 一个 action 给 Store。Store 根据这个 action 来改变数据。当然 Action 也可以由其他地方触发。<br>一旦 Store 发生了变化，就会往外面发送一个事件，比如 change，来通知所有的订阅者。View 会监听这个事件，从而触发自身的 re-render。（实现：发布订阅模式）<br>Dispatcher 的作用是接收所有的 Action，然后发给所有的 Store。 Store 的改变只能通过 Action，不能通过其他方式。</p>
<p>改写上面的例子：</p>
<p>store 部分加入发布订阅</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> store = assign((), EventEmitter.prototype, store, &#123;</div><div class="line">    emitChange: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.emit(<span class="string">'change'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>Dispatcher 部分</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'../store'</span>;</div><div class="line"></div><div class="line">AppDispatcher.regiseter(<span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">switch</span>(action.type) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">'setData'</span>:</div><div class="line">            store.setData(action.data);</div><div class="line">            <span class="comment">// 触发变更</span></div><div class="line">            store.emitChange();</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="string">'clear'</span>:</div><div class="line">            store.clearData();</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>View 层</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'../store'</span>;</div><div class="line"><span class="keyword">import</span> AppDispatcher <span class="keyword">from</span> <span class="string">'...'</span>;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">    componentDidMount: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        store.addChangeListener(<span class="keyword">this</span>._onChange);</div><div class="line">    &#125;</div><div class="line">    componentWillUnmount: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        store.removeChangeListener(<span class="keyword">this</span>._onChange);</div><div class="line">    &#125;</div><div class="line">    _onChange: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">this</span>.setState(&#123;</div><div class="line">            items: ListStore.getAll()</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    handleClick: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        AppDispatcher(&#123;</div><div class="line">            type: <span class="string">'setData'</span>,</div><div class="line">            data: data</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    render() &#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，Flux 核心思想就是数据都是单向流动的。<br>Flux 本身会有很多个 store 来存储引用数据，并在各自的 store 里面执行更新逻辑。那么当多个store之间有依赖关系的时候，就不太好处理。同时 store 里面不仅封装了数据，还有处理数据的逻辑。</p>
<h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h3><p>在 Flux 的基础上，Redux 对其进行了一些改进增强。  </p>
<img src="/2019/01/02/react数据流管理/a4.png" alt="a4.png" title=""> 
<p>在 Redux 中没有 Dispatcher 的概念，它使用 reducer 来进行事件处理。<br>reducer 是一个纯函数，每个 reducer 负责维护应用整体 state 树中的某一部分，多个 reducer 可以通过 combineReducers 方法合成一个根reducer，这个根reducer负责维护完整的 state。<br><code>约定</code>: reducer 必须为纯函数（此函数在相同的输入值时，需产生相同的输出。函数的输出和输入值以外的其他隐藏信息或状态无关，也和由I/O 设备产生的外部输出无关，例如 Ajax）。<br>由于有这样的规定，redux 成功副作用隔离。我们很容易判断出数据的变化的原因，数据流清晰可回朔。同时 Redux 引入的 immutable 进一步隔离了对象引用的问题。</p>
<h4 id="对比-Flux"><a href="#对比-Flux" class="headerlink" title="对比 Flux"></a>对比 Flux</h4><p>Redux 和 Flux 之间最大的区别就是对 store/reducer 的抽象，Flux 中 store 是各自为战的，每个 store 只对对应的 controller-view 负责，每次更新都只通知对应的 controller-view；而 Redux 中各子 reducer 都是由根reducer统一管理的，每个子reducer的变化都要经过根reducer的整合。</p>
<img src="/2019/01/02/react数据流管理/a5.png" alt="a5.png" title=""> 
<p>综上：Redux有三大原则：</p>
<ol>
<li>单一数据源：Flux 的数据源可以是多个。 </li>
<li>State 是只读的：Flux 的 State 可以随便改。</li>
<li>使用纯函数来执行修改：Flux 执行修改的不一定是纯函数。</li>
</ol>
<h4 id="Redux-异步"><a href="#Redux-异步" class="headerlink" title="Redux 异步"></a>Redux 异步</h4><p>在 Redux 中，每当我们发出一个 Action，Reducer 就会立即算出 State。那么我们想支持异步呢？在哪儿加入异步操作呢？<br>Reducer ？ 纯函数，不能引入IO，不适合。Action ? 一个纯对象，没有位置。所以只能通过包装 dispatch 加上中间件的动能。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> next = store.dispatch;</div><div class="line">store.dispatch = <span class="function"><span class="keyword">function</span> <span class="title">dispatchAndLog</span>(<span class="params">action</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'dispatching'</span>, action);</div><div class="line">    next(action);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'next state'</span>, store.getState());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Redux 提供了一个 applyMiddleware 方法来应用中间件：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = createStore(</div><div class="line">    reducer,</div><div class="line">    applyMiddleware(thunk, promise, logger)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>这个方法主要就是把所有的中间件组成一个数组，依次执行。也就是说，任何被发送到 store 的 action 现在都会经过thunk，promise，logger 这几个中间件了。</p>
<p>关于 Redux 的异步处理，之后会有单独解析 redux-sage 的内容。</p>
<h2 id="Mobx"><a href="#Mobx" class="headerlink" title="Mobx"></a>Mobx</h2><p>之前说的都是单项数据流方案，思想主要就是函数是编程（FP）的思想。Mobx 则是一个 TFRP 的框架，FRP 的一个分支。</p>
<img src="/2019/01/02/react数据流管理/flow.png" alt="flow.png" title="">   
<p>mobx的流程图如上，通常是：触发action，在action中修改state，通过computed拿到state的计算值，自动触发对应的reactions，这里包含autorun，渲染视图等。有一点需要注意：相对于react来说，mobx没有一个全局的状态树，状态分散在各个独立的 store 中。这种自动订阅，自动发布的模式，使得开发十分方便。<br>但是相对的，mobx 中并没有解决副作用问题，同时，对 props 的直接修改，也会导致与 react 对 props 的不可变定义冲突。因此 mobx 后来给出了 action 解决方案，解决了与 react props 的冲突，但是没有解决副作用未强制分离的问题。  </p>
<p>对比一下：</p>
<ol>
<li>redux 采用全局单一 store，mobx 则由多个独立 store 组成</li>
<li>redux 通过 action 将副作用隔离在 reducer 之外。而 mobx 比较自由，没有对副作用进行处理。</li>
<li>redux 函数式、不可变、模式化；mobx 响应式、依赖追踪</li>
<li>redux 开发需要些很多样板代码，但是调试数据的时候确很方便。mobx 书写简单，但是没有强约束换来的是调试困难。</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651231366&amp;idx=1&amp;sn=0e322d1fb0b59710aae98fe9df7d00ae&amp;chksm=bd494d028a3ec414ccda32e03f8a794372cdb1ab614c06f60526571623dd462653813d5bc230&amp;xtrack=1&amp;scene=0&amp;subscene=131&amp;clicktime=1552304245&amp;ascene=7&amp;devicetype=android-28&amp;version=2700033b&amp;nettype=3gnet&amp;abtest_cookie=BAABAAoACwASABMABQAjlx4AVpkeAMyZHgDamR4A3JkeAAAA&amp;lang=zh_CN&amp;pass_ticket=YbTwrdgEkkcGf%252BH838CvWRFJH9PYUZn90NpiCUOidTcTbXee%252B5bgEwAXKl6tBRd7&amp;wx_header=1" target="_blank" rel="external">Vuex、Flux、Redux、Redux-saga、Dva、MobX</a></li>
<li><a href="https://github.com/dt-fe/weekly/blob/master/42.%E7%B2%BE%E8%AF%BB%E3%80%8A%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E6%B5%81%E5%93%B2%E5%AD%A6%E3%80%8B.md" target="_blank" rel="external">精读《前端数据流哲学》</a></li>
<li><a href="https://imweb.io/topic/57711e37f0a5487b05f325b5" target="_blank" rel="external">浅谈 React、Flux 与 Redux</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;react 的范式为 &lt;code&gt;UI = render(state)&lt;/code&gt;，用户的界面完全取决于数据层。react 中通过管理状态（state）来实现对组件的管理，当 state 发生变更后，react 就会重新渲染界面，组件与组件之间也经常需要共享状态。如果缺乏一个好的状态管理方案，那么共享数据将变得麻烦，同时状态不受控的话会让我们很难跟踪调试程序。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
      <category term="redux" scheme="http://yoursite.com/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>React 组件复用和组合 (二)</title>
    <link href="http://yoursite.com/2018/12/05/React%E7%BB%84%E4%BB%B6%E5%A4%8D%E7%94%A8%E5%92%8C%E7%BB%84%E5%90%882/"/>
    <id>http://yoursite.com/2018/12/05/React组件复用和组合2/</id>
    <published>2018-12-05T09:27:12.000Z</published>
    <updated>2019-03-11T11:59:47.636Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章，我们介绍了高阶组件(HOC)，最后也提出了几个关于高阶组件的问题。这里我们接上另一种组件复用模式 <code>render props</code> 亦或是 <code>funtion as child</code>。</p>
<h2 id="render-props"><a href="#render-props" class="headerlink" title="render props"></a>render props</h2><p>本质上，render props 就是在原有的组件上增加一个 prop 来实现不同的渲染情况，从而达到代码复用的目的(即将组件组件做为参数)。举例如下：</p>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareStateComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">    state = &#123;...&#125;;</div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;div&gt;&#123;<span class="keyword">this</span>.props.render(<span class="keyword">this</span>.state)&#125;&lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">        );</span></div><div class="line"><span class="regexp">    &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ 使用</span></div><div class="line"><span class="regexp">class App extends React.Component &#123;</span></div><div class="line"><span class="regexp">    render() &#123;</span></div><div class="line"><span class="regexp">        &lt;ShareStateComponent </span></div><div class="line"><span class="regexp">            render = &#123;</span></div><div class="line"><span class="regexp">                (state) =&gt; &#123;</span></div><div class="line"><span class="regexp">                    &lt;span&gt;数据：&#123;...state&#125;&lt;/</span>span&gt;</div><div class="line">                &#125;</div><div class="line">            &#125;/&gt;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>StareStateComponent 内部维护了一些可复用的功能，在实例化时，通过调用名为 render 的 prop 属性函数实现了不同组件的渲染。换个更直观的方案，我们可以直接利用 <code>this.props.children</code> ，通过执行 this.props.children 方法，来传递必要的参数，从而实现基于共享数据的不同渲染逻辑，达到复用的目的。这种用法在 <code>React Motion</code>, <code>React Router</code> 里都有采用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">render (</div><div class="line">    &lt;RenderProps1&gt;</div><div class="line">        &#123;(data1) =&gt; (</div><div class="line">            &lt;div&gt;</div><div class="line">                &#123;data1&#125;  </div><div class="line">                &lt;RenderProps2&gt;</div><div class="line">                    &#123;(data2) =&gt; &#123;</div><div class="line">                        &lt;RenderProps3&gt;</div><div class="line">                            (&#123;data3&#125; =&gt; &#123;</div><div class="line">                                &lt;div&gt;&#123;data2&#125;, &#123;data3&#125;&lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">                            &#125;)</span></div><div class="line"><span class="regexp">                        &lt;/</span>RenderProps3&gt;</div><div class="line">                    &#125;&#125;</div><div class="line">                &lt;<span class="regexp">/RenderProps2&gt;       </span></div><div class="line"><span class="regexp">            &lt;/</span>div&gt;</div><div class="line">        )&#125;</div><div class="line">    &lt;<span class="regexp">/RenderProps1&gt;</span></div><div class="line"><span class="regexp">)</span></div></pre></td></tr></table></figure>
<p>通过上面的代码，我们可以看到相比高阶组件，render props 的方案，我们更能直观的观察到数据的流动，从而解决了高阶组件的嵌套问题。与高阶组件相比，render props 的开放性得到提升，原本 HOC 所做的功能抽象可以通过 render props 获取，render 方式还可以直接访问父级的一切内容：  </p>
<img src="/2018/12/05/React组件复用和组合2/a2.png" alt="a2.png" title="">
<h3 id="render-props-存在的问题"><a href="#render-props-存在的问题" class="headerlink" title="render props 存在的问题"></a>render props 存在的问题</h3><p>render props 带来的优点：</p>
<ol>
<li>不用担心props命名问题，在render函数中只取需要的state，数据流动更加直观</li>
<li>不会产生无用的组件加深层级</li>
<li>render props模式的构建都是动态的，所有的改变都在render中触发，可以更好的利用组件内的生命周期。</li>
<li>能够直接访问父组件的内容，开发性更高</li>
</ol>
<p>但 render props 也有一些不能忽视的问题：</p>
<ol>
<li>this.props.children 被重新定义为函数是否合适</li>
<li>渲染粒度变大，如果在属性中定义函数，浅比较下 prop 的值永远是新的，每次都将重新生成新的 prop，这将导致 React.PureComponent 不起作用</li>
<li>renderProps 渲染的并不是 React 组件，无法为其单独使用 redux，mobx</li>
<li>容易产生嵌套地狱问题</li>
</ol>
<p>当然，对于项目使用 HOC 还是 render props 应该根据不同的场景来进行渲染。<br>个人觉得，HOC 更倾向于封装一些复杂的操作，需要复用通用的业务状态和功能的时候使用。而 render props 比较适合抽离与业务无关但是和UI保存的状态有关的功能 (renderProps 内部管理的状态不方便从外部获取，因此只适合保存业务无关的数据，比如 Modal 显隐)。</p>
<h2 id="RenderProps-工具库-react-powerplug"><a href="#RenderProps-工具库-react-powerplug" class="headerlink" title="RenderProps 工具库 react-powerplug"></a>RenderProps 工具库 react-powerplug</h2><p>React PowerPlug 是利用 render props 进行更好状态管理的工具库。<br>在我们日常开发中，一个 Component 类中，可能有很多的 state 但是并不是每个状态都和有业务有关，比如：UI 的展示状态，受控组件的临时 value 等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">    state = &#123;</div><div class="line">        nameIsEdit: <span class="literal">false</span>,</div><div class="line">        briefIsEdit: <span class="literal">false</span>,</div><div class="line">        isLoding: <span class="literal">false</span>,</div><div class="line">        value: <span class="string">''</span>,</div><div class="line">        data: &#123;&#125;</div><div class="line">    &#125;;</div><div class="line">    render() &#123;</div><div class="line">        <span class="comment">//....</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这时候我们就一些常用的状态管理封装成 render props 的形式。react-powerplug 就是提供这样工具的一个类库。这里简单看下几个功能，来帮助我们更好理解 render props 的应用。</p>
<h3 id="Value"><a href="#Value" class="headerlink" title="Value"></a>Value</h3><p>该方法是用来管理值操作的工具。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;Value initial=<span class="string">"React"</span>&gt;</div><div class="line">    &#123;(&#123; value, set, reset &#125;) =&gt; (</div><div class="line">        &lt;&gt;</div><div class="line">        &lt;Select</div><div class="line">            label=<span class="string">"Choose one"</span></div><div class="line">            options=&#123;[<span class="string">"React"</span>, <span class="string">"Preact"</span>, <span class="string">"Vue"</span>]&#125;</div><div class="line">            value=&#123;value&#125;</div><div class="line">            onChange=&#123;set&#125;</div><div class="line">        /&gt;</div><div class="line">        &lt;Button onClick=&#123;reset&#125;&gt;Reset to initial&lt;<span class="regexp">/Button&gt;</span></div><div class="line"><span class="regexp">        &lt;/</span>&gt;</div><div class="line">    )&#125;</div><div class="line">&lt;<span class="regexp">/Value&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li><a href="https://github.com/renatorib/react-powerplug/blob/master/src/components/Value.js" target="_blank" rel="external">源码地址</a>  </li>
</ul>
<p>Value 中，只存储一个属性 value，并赋初始值为 initial。</p>
<p>方法：set reset。</p>
<ul>
<li>set 回调函数触发后调用 setState 更新 value。</li>
<li>reset 就是调用 set 并传入 this.props.initial 即可。</li>
</ul>
<h3 id="Active"><a href="#Active" class="headerlink" title="Active"></a>Active</h3><p>这是一个内置鼠标交互监听的容器，监听了 onMouseUp 与 onMouseDown，并依此判断 active 状态。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;Active&gt;</div><div class="line">    &#123;(&#123; active, bind &#125;) =&gt; (</div><div class="line">        &lt;div &#123;...bind&#125;&gt;</div><div class="line">            You are &#123;active ? <span class="string">"clicking"</span> : <span class="string">"not clicking"</span>&#125; <span class="keyword">this</span> div.</div><div class="line">        &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">    )&#125;</span></div><div class="line"><span class="regexp">&lt;/</span>Active&gt;</div></pre></td></tr></table></figure>
<p>借助 Value 实现，巧妙的利用了 value，value 重命名为 active 且初始值为 false。增加了 bind 方法，借助 set 来更新状态。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span></div><div class="line"><span class="keyword">import</span> Value <span class="keyword">from</span> <span class="string">'./Value'</span></div><div class="line"><span class="keyword">import</span> renderProps <span class="keyword">from</span> <span class="string">'../utils/renderProps'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> Active = <span class="function">(<span class="params">&#123; onChange, ...props &#125;</span>) =&gt;</span> (</div><div class="line">    &lt;Value initial=&#123;<span class="literal">false</span>&#125; onChange=&#123;onChange&#125;&gt;</div><div class="line">        &#123;(&#123; value, set &#125;) =&gt;</div><div class="line">            renderProps(props, &#123;</div><div class="line">                active: value,</div><div class="line">                bind: &#123;</div><div class="line">                    onMouseDown: <span class="function"><span class="params">()</span> =&gt;</span> set(<span class="literal">true</span>),</div><div class="line">                    onMouseUp: <span class="function"><span class="params">()</span> =&gt;</span> set(<span class="literal">false</span>)</div><div class="line">                &#125;,</div><div class="line">            &#125;)</div><div class="line">        &#125;</div><div class="line">    &lt;<span class="regexp">/Value&gt;</span></div><div class="line"><span class="regexp">)</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">export default Active</span></div></pre></td></tr></table></figure>
<p>其他功能就不一一展示了。</p>
<h2 id="render-props-嵌套问题"><a href="#render-props-嵌套问题" class="headerlink" title="render props 嵌套问题"></a>render props 嵌套问题</h2><p>上面过，render props 有一个缺点当我们想要组合使用的时候，可能会遇到嵌套地狱问题。在 react-powerplug 中提供了 compose 函数，来解决这一问题。 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; compose &#125; <span class="keyword">from</span> <span class="string">'react-powerplug'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> AandB = compose(</div><div class="line">    &lt;A .../&gt;,</div><div class="line">    &lt;B .../&gt;</div><div class="line">)</div><div class="line">&lt;AandB&gt;</div><div class="line">    &#123;(a, b) =&gt; &#123;</div><div class="line">        <span class="comment">//....</span></div><div class="line">    &#125;&#125;</div><div class="line">&lt;<span class="regexp">/AandB&gt;</span></div></pre></td></tr></table></figure>
<p>社区也提供了 <a href="https://github.com/Astrocoders/epitath" target="_blank" rel="external">Epitath</a> 工具来专门解决 render props 嵌套问题。细节就不看了。</p>
<h2 id="React-Hooks"><a href="#React-Hooks" class="headerlink" title="React Hooks"></a>React Hooks</h2><p>React Hooks 是 React 16.7.0-alpha 版本推出的新特性。React Hooks 要解决的问题是状态共享，是继 render-props 和 higher-order components 之后的第三种状态共享方案，不会产生 JSX 嵌套地狱问题。之后介绍吧，现在还没空仔细体会呢。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.jianshu.com/p/ff6b3008820a?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="external">React组件Render Props VS HOC 设计模式</a></li>
<li><a href="https://medium.com/tandemly/im-breaking-up-with-higher-order-components-44b0df2db052" target="_blank" rel="external">I’m Breaking up with Higher Order Components.</a></li>
<li><a href="https://github.com/dt-fe/weekly/blob/master/75.%E7%B2%BE%E8%AF%BB%E3%80%8AEpitath%20%E6%BA%90%E7%A0%81%20-%20renderProps%20%E6%96%B0%E7%94%A8%E6%B3%95%E3%80%8B.md" target="_blank" rel="external">精读《Epitath 源码 - renderProps 新用法》</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章，我们介绍了高阶组件(HOC)，最后也提出了几个关于高阶组件的问题。这里我们接上另一种组件复用模式 &lt;code&gt;render props&lt;/code&gt; 亦或是 &lt;code&gt;funtion as child&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;render-props&quot;&gt;&lt;a href=&quot;#render-props&quot; class=&quot;headerlink&quot; title=&quot;render props&quot;&gt;&lt;/a&gt;render props&lt;/h2&gt;&lt;p&gt;本质上，render props 就是在原有的组件上增加一个 prop 来实现不同的渲染情况，从而达到代码复用的目的(即将组件组件做为参数)。举例如下：&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React 组件复用和组合 (一)</title>
    <link href="http://yoursite.com/2018/12/01/React%E7%BB%84%E5%90%88%E4%B8%8E%E5%A4%8D%E7%94%A8/"/>
    <id>http://yoursite.com/2018/12/01/React组合与复用/</id>
    <published>2018-12-01T02:57:08.000Z</published>
    <updated>2019-03-11T07:41:23.120Z</updated>
    
    <content type="html"><![CDATA[<p>组件的复用和组合，可以帮助我们在现有的轮子上扩展新的功能，提高工作效率，避免重复造轮子。React 组件化的开发方式可以很好地实现复用和组合的功能，本章主要围绕高阶组件来讨论下这一问题。</p>
<h2 id="高阶组件（HOC）"><a href="#高阶组件（HOC）" class="headerlink" title="高阶组件（HOC）"></a>高阶组件（HOC）</h2><blockquote>
<p>高阶组件（HOC）是 React 中用于重用组件逻辑的高级技术。 HOC 本身不是 React API 的一部分。 它们是从 React 构思本质中浮现出来的一种模式。  </p>
</blockquote>
<a id="more"></a>
<p>通俗点高阶组件就是一个函数，其接受一个组件并返回对着个组件功能上的扩展复用的新的组件。</p>
<blockquote>
<p>const EnhancedComponent = higherOrderComponent(WrappedComponent);</p>
</blockquote>
<p>高阶组件常见有两种实现方式，一种是 Props Proxy(属性代理)，一种是 Inheritance Inversion(继承反转)</p>
<h3 id="Props-Proxy"><a href="#Props-Proxy" class="headerlink" title="Props Proxy"></a>Props Proxy</h3><p>Props Proxy 模式可以对 WrappedComponent 的 props 进行操作扩展，抽离 state，并可以使用其他元素来包裹 WrappedComponend 来实现扩展组件的功能。</p>
<h4 id="操作-props"><a href="#操作-props" class="headerlink" title="操作 props"></a>操作 props</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">propsHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">        render() &#123;</div><div class="line">            <span class="keyword">let</span> newProps = &#123;/.../&#125;;</div><div class="line">            <span class="keyword">return</span> &lt;WrappedComponent &#123;...props&#125; &#123;...newProps&#125;/&gt;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，传递给 WrappedComponent 的属性首先传递给了高阶组件返回的组件，这样我们就获得了props的控制权。</p>
<h4 id="抽离-state"><a href="#抽离-state" class="headerlink" title="抽离 state"></a>抽离 state</h4><p>我们可以将 WrappedComponent 中的状态提到包裹组件中，一种很常见的操作就是将不受控组件转换成受控组件。通常，我们在设计 UI 组件的时候，组件应该简单只负责展示 (不受控组件)。对组件的修改逻辑不应该放在组件中，而是由调用者来提供。这样，我们就可以用HOC来将无状态组件变成受控组件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">stateHoc</span>(<span class="params">WrappedComponent</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">        <span class="keyword">constructor</span>(props) &#123;</div><div class="line">            <span class="keyword">super</span>(props);</div><div class="line">            <span class="keyword">this</span>.state = &#123;</div><div class="line">                value: <span class="string">''</span></div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line">        onChange(event) &#123;</div><div class="line">            <span class="keyword">this</span>.setState(&#123;</div><div class="line">                value: event.target.value</div><div class="line">            &#125;)</div><div class="line">        &#125;</div><div class="line">        render() &#123;</div><div class="line">            <span class="keyword">const</span> props = &#123;</div><div class="line">                ...this.props,</div><div class="line">                value: <span class="keyword">this</span>.state.value,</div><div class="line">                onChange: <span class="keyword">this</span>.onChange</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> &lt;WrappedComponent &#123;...props&#125;/&gt;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@stateHoc</div><div class="line">class InputStateLess extends Component &#123;</div><div class="line">    render() &#123;</div><div class="line">        return &lt;input name="name" value=&#123;this.props.value&#125; /&gt;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Inheritance-Inversion"><a href="#Inheritance-Inversion" class="headerlink" title="Inheritance Inversion"></a>Inheritance Inversion</h3><p>反向继承，我们采用直接继承 WrappedComponent 的方案，而不是采用包裹 WrappedComonent 的代理方案。这意味着，我们可以调用 WrappedComponent 的属性，声明周期等任何内容。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">iiOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</div><div class="line">        render() &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.render();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过我们可以完全操作 WrappedComponent 上的内容，我们可以实现<code>渲染劫持</code>等操作，改变 WrappedComponent 的任何行为。<br>Inheritance Inversion 是继承的思想，对于 WrappedComponent 也有较强的侵入性，因此并不常见。</p>
<h3 id="高阶组件的应用"><a href="#高阶组件的应用" class="headerlink" title="高阶组件的应用"></a>高阶组件的应用</h3><p>高阶组件的本质是统一抽象功能，强调逻辑和UI的分离</p>
<h4 id="view-层分离"><a href="#view-层分离" class="headerlink" title="view 层分离"></a>view 层分离</h4><p>在设计组件的时候，我们会尽可能考虑组件的复用性，对于组件的 view 层，我们期望是组件与组件之间没有重叠的部分，重叠的部分应该被抽出来形成更细粒度的组件，这样方便我们各种各样的组件组合。每个最小的基础组件我们都期望他是一个<code>木偶组件(Dumb Component)</code>。<br>木偶组件，指只会接受 props 并且渲染结果完全依赖 props 的组件。Dumb 组件不应该依赖除了 React.js 和 Dumb 组合以外的内容(比如不应该依赖 redux，mobx 等)。这样的组件可复用性是最好的，其他人可以放心使用。<br>当然仅有 Dumb 组件，是不能工作的，因为他们没有逻辑。为此还应该有这么一类组件，他们只负责应用逻辑，和各种数据打交道，然后把数据以 props 的形式传递给 Dumb 组件。<br>注意，Dumb 绝对不能依赖 Smart 组件，这相当增加了 Dumb 输出的不确定性。如果一个组件是 Dumb 的，那么它的子组件们都应该是 Dumb 的才对。</p>
<img src="/2018/12/01/React组合与复用/a.png" alt="a.png" title="">
<h4 id="逻辑层的分离"><a href="#逻辑层的分离" class="headerlink" title="逻辑层的分离"></a>逻辑层的分离</h4><p>组件中的交互逻辑和业务逻辑有很大部分也是重复的，我们可以将这写公共部分进行抽象封装起来，来为其他组件增加新的能力，这也就是高阶组建的思想。每个独立可重用的逻辑都是一个 <code>Decorator</code> 装饰器。<br>适用于高阶组件的逻辑层应该时那些完全不与 DOM 相关的内容。比如数据校验，权限控制，或者通过数据变化间接控制 DOM 的。</p>
<h4 id="举例-Form-表单的抽离"><a href="#举例-Form-表单的抽离" class="headerlink" title="举例 Form 表单的抽离"></a>举例 Form 表单的抽离</h4><p>Form 中，会包含不同的组件，input, selector, checkbox 等等，也可能会是多种常见组件的组合。</p>
<img src="/2018/12/01/React组合与复用/b.png" alt="b.png" title="">
<p>如图，一个下拉搜索框，由 input，select, list 三个纯粹的细粒度的 Dumb 组件组成。对于每个 UI 都有自己的数据 validator 验证规则，和数据变化回调规则。我们可以将这部分逻辑的对应关系和UI的绑定做成一个 HOC 组件。 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 函数柯里化，为 HOC 提供参数</span></div><div class="line"><span class="comment">// validator 用户定义的变淡验证规则</span></div><div class="line"><span class="comment">// changeFunc 相应数据变化的函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">formFactory</span>(<span class="params">validator, changeFunc = <span class="string">'onChange'</span></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">WrappedComponent</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">            getBind(changeFunc, validtor) &#123;</div><div class="line">                <span class="comment">//...</span></div><div class="line">            &#125;</div><div class="line">            render() &#123;</div><div class="line">                <span class="keyword">const</span> props = &#123;</div><div class="line">                    ...this.props,</div><div class="line">                    [trigger]: <span class="keyword">this</span>.getBind(trigger, validtor)</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> &lt;WrappedComponent &#123;...props&#125; /&gt;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 为 Input 组件绑定验证规则</div><div class="line">formFactory((value) =&gt; &#123;</div><div class="line">    return value &gt; 0</div><div class="line">&#125;)(&lt;Input name="age" placeholder="请输入年龄"/&gt;)</div></pre></td></tr></table></figure>
<h3 id="高阶组件的问题"><a href="#高阶组件的问题" class="headerlink" title="高阶组件的问题"></a>高阶组件的问题</h3><h4 id="不确定性-amp-命名冲突"><a href="#不确定性-amp-命名冲突" class="headerlink" title="不确定性 &amp; 命名冲突"></a>不确定性 &amp; 命名冲突</h4><p>高阶组件的变更是由 props 引起的，且高阶组件之间是互相独立的。因此当组件的 props 发生变化后，我们很难确定是哪个高级组件引起的 props 变动或者是组件本身引起的。同样多个高阶组件的引入的 props 也有可能因为同名原因导致互相覆盖，产生许多无用的组件嵌套加深组件层级，这些问题高阶组件都无法解决。<br>官方文档上推荐我们使用高阶组件的时候提出了如下约定：</p>
<blockquote>
<p>约定: 给包裹组件传递不相关的属性(Props)</p>
</blockquote>
<p>这个问题只能靠约定而没有办法约束，因此可维护性变低。</p>
<h4 id="静态方法必须复制-amp-Refs-不会被传递"><a href="#静态方法必须复制-amp-Refs-不会被传递" class="headerlink" title="静态方法必须复制 &amp; Refs 不会被传递"></a>静态方法必须复制 &amp; Refs 不会被传递</h4><p>由于高阶组件包裹的特性，原有组件上的静态方法并不会得到传递。同样的道理 ref 在容器组件上应用 ref 也不会直接传递给原有组件。我们都需要在容器组件上做静态方法的复制和 ref 的传递。</p>
<p>高阶组件的带来的副作用有没有解决办法呢？render-props 可以在一定程度上来解决，这个之后我们再谈吧。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/22054582" target="_blank" rel="external">基于 Decorator 的组件扩展实践</a></li>
<li><a href="http://react.html.cn/docs/higher-order-components.html" target="_blank" rel="external">高阶组件(Higher-Order Components)</a></li>
<li><a href="https://medium.com/@franleplant/react-higher-order-components-in-depth-cf9032ee6c3e" target="_blank" rel="external">React Higher Order Components in depth</a></li>
<li><a href="http://huziketang.mangojuice.top/books/react/lesson43" target="_blank" rel="external">Smart 组件 vs Dumb 组件</a></li>
<li><a href="https://juejin.im/post/5914fb4a0ce4630069d1f3f6" target="_blank" rel="external">React 高阶组件(HOC)入门指南</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;组件的复用和组合，可以帮助我们在现有的轮子上扩展新的功能，提高工作效率，避免重复造轮子。React 组件化的开发方式可以很好地实现复用和组合的功能，本章主要围绕高阶组件来讨论下这一问题。&lt;/p&gt;
&lt;h2 id=&quot;高阶组件（HOC）&quot;&gt;&lt;a href=&quot;#高阶组件（HOC）&quot; class=&quot;headerlink&quot; title=&quot;高阶组件（HOC）&quot;&gt;&lt;/a&gt;高阶组件（HOC）&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;高阶组件（HOC）是 React 中用于重用组件逻辑的高级技术。 HOC 本身不是 React API 的一部分。 它们是从 React 构思本质中浮现出来的一种模式。  &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>单页应用代码分割</title>
    <link href="http://yoursite.com/2018/11/19/%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2/"/>
    <id>http://yoursite.com/2018/11/19/单页应用代码分割/</id>
    <published>2018-11-19T13:52:17.000Z</published>
    <updated>2018-11-22T09:46:48.252Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单页面代码分割"><a href="#单页面代码分割" class="headerlink" title="单页面代码分割"></a>单页面代码分割</h2><p>目前单页应用的 bundle.js 一般都会很大，这样的话会对启动时间造成影响。为此我们需要合理拆分 js 文件，然后在需要使用的时候才动态记在。<br>拆分 js 文件，我们通常会采用手段： </p>
<ul>
<li>基于业务逻辑和依赖库分割</li>
<li>基于路由分割  </li>
<li>基于组件分割  </li>
</ul>
<a id="more"></a>

<p>左图所示是基于路由进行分割，有图为基于组件进行分割。基于路由分割的力度比较大，一个路由里会嵌套很多组件。每个路由 react 组件还是有很多，但并不是每个组件都会被立刻使用。同时，多个路由之间还有可能会产生很多重复的组件代码。这显然不如基于组件进行分割效果较好。  </p>
<h2 id="代码分割案例"><a href="#代码分割案例" class="headerlink" title="代码分割案例"></a>代码分割案例</h2><p>假如，我们有个页面，页面的额外信息 extra 组件是不需要的，只有点击查看额外信息按钮后才会出现。我们对 extra 进行惰性加载。代码如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(prop) &#123;</div><div class="line">        <span class="keyword">super</span>(prop);</div><div class="line">        <span class="keyword">this</span>.state = &#123;</div><div class="line">            showExtra: <span class="literal">false</span>,</div><div class="line">            CExtra: &#123;&#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    handleOpenExtra() &#123;</div><div class="line">        <span class="keyword">import</span>(<span class="string">'./components/extra'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</div><div class="line">            <span class="keyword">this</span>.setState(&#123;</div><div class="line">                showExtra: <span class="literal">true</span>,</div><div class="line">                CExtra: res.default</div><div class="line">            &#125;)</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;React.Fragment&gt;</div><div class="line">                &#123;<span class="keyword">this</span>.state.showExtra ? <span class="xml"><span class="tag">&lt;<span class="name">this.state.CExtra</span> /&gt;</span> : null&#125;</span></div><div class="line"><span class="xml">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line"><span class="xml">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleOpenExtra.bind(this)&#125;</span>&gt;</span>点击查看额外信息<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></div><div class="line"><span class="xml">        );</span></div><div class="line"><span class="xml">    &#125;</span></div><div class="line"><span class="xml">&#125;;</span></div><div class="line"><span class="xml">export default App;</span></div></pre></td></tr></table></figure>
<p>demo 中我们利用了 webpack 分包加载功能，当点击按钮时利用 import 来加载 extra 组件，而不是在开头直接引入。  </p>
<h3 id="动态导入-dynamic-imports"><a href="#动态导入-dynamic-imports" class="headerlink" title="动态导入(dynamic imports)"></a>动态导入(dynamic imports)</h3><p>上述案例，我们借助 import 函数来引入 extra 包。webpack 在打包的时候会自动检测这样的 import 引入的文件，为其单独生成一个打包 js 文件。如图所示：  </p>
  
<p>当我们点击加载按钮后，红线处的 js 包会被异步载入   </p>
 
<p>webpack 实现动态导如的代码如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">__webpack_require__.e = <span class="function"><span class="keyword">function</span> <span class="title">requireEnsure</span>(<span class="params">chunkId</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> promises = [];</div><div class="line">	<span class="comment">// JSONP chunk loading for javascript</span></div><div class="line">	<span class="keyword">var</span> installedChunkData = installedChunks[chunkId];</div><div class="line">	<span class="keyword">if</span>(installedChunkData !== <span class="number">0</span>) &#123; <span class="comment">// 0 means "already installed".</span></div><div class="line">		<span class="comment">// a Promise means "currently loading".</span></div><div class="line">		<span class="keyword">if</span>(installedChunkData) &#123;</div><div class="line">			promises.push(installedChunkData[<span class="number">2</span>]);</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="comment">// 每次需要进行异步加载chunk时，会将这个chunk的加载状态进行初始化为一个数组,并以key/value的形式保存在installedChunks里</span></div><div class="line">			<span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">				installedChunkData = installedChunks[chunkId] = [resolve, reject];</div><div class="line">			&#125;);</div><div class="line">			promises.push(installedChunkData[<span class="number">2</span>] = promise);</div><div class="line">			<span class="comment">// 开始异步 chunk 加载</span></div><div class="line">			<span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>];</div><div class="line">			<span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</div><div class="line">			<span class="keyword">var</span> onScriptComplete;</div><div class="line">			script.charset = <span class="string">'utf-8'</span>;</div><div class="line">			script.timeout = <span class="number">120</span>;</div><div class="line">			<span class="keyword">if</span> (__webpack_require__.nc) &#123;</div><div class="line">				script.setAttribute(<span class="string">"nonce"</span>, __webpack_require__.nc);</div><div class="line">			&#125;</div><div class="line">			script.src = jsonpScriptSrc(chunkId);   <span class="comment">// js 文件名</span></div><div class="line">			onScriptComplete = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;   <span class="comment">// 加载完毕回调</span></div><div class="line">				<span class="comment">// avoid mem leaks in IE.</span></div><div class="line">				script.onerror = script.onload = <span class="literal">null</span>;</div><div class="line">				clearTimeout(timeout);</div><div class="line">				<span class="keyword">var</span> chunk = installedChunks[chunkId];</div><div class="line">				<span class="keyword">if</span>(chunk !== <span class="number">0</span>) &#123;</div><div class="line">					<span class="keyword">if</span>(chunk) &#123;</div><div class="line">						<span class="keyword">var</span> errorType = event &amp;&amp; (event.type === <span class="string">'load'</span> ? <span class="string">'missing'</span> : event.type);</div><div class="line">						<span class="keyword">var</span> realSrc = event &amp;&amp; event.target &amp;&amp; event.target.src;</div><div class="line">						<span class="keyword">var</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Loading chunk '</span> + chunkId + <span class="string">' failed.\n('</span> + errorType + <span class="string">': '</span> + realSrc + <span class="string">')'</span>);</div><div class="line">						error.type = errorType;</div><div class="line">						error.request = realSrc;</div><div class="line">						chunk[<span class="number">1</span>](error);</div><div class="line">					&#125;</div><div class="line">					installedChunks[chunkId] = <span class="literal">undefined</span>;</div><div class="line">				&#125;</div><div class="line">			&#125;;</div><div class="line">			<span class="keyword">var</span> timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">				onScriptComplete(&#123; <span class="attr">type</span>: <span class="string">'timeout'</span>, <span class="attr">target</span>: script &#125;);</div><div class="line">			&#125;, <span class="number">120000</span>);</div><div class="line">			script.onerror = script.onload = onScriptComplete;</div><div class="line">			head.appendChild(script);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="built_in">Promise</span>.all(promises);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>注意，使用 import 导入这种形式的话，我们需要使用 dynamic-import 包：  </p>
<blockquote>
<p>npm install –save-dev @babel/plugin-syntax-dynamic-import  </p>
</blockquote>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"plugins"</span>: [<span class="string">"@babel/plugin-syntax-dynamic-import"</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或者你也可以使用 webpack 提供的 require.ensure 来代替。</p>
<h2 id="react-loadable"><a href="#react-loadable" class="headerlink" title="react-loadable"></a>react-loadable</h2><p>上述代码，我们粗略的实现了一个分包加载的demo，业务上我们还要有很多问题来处理。比如：import 失败怎么办？加载前需要 loading 占位怎么做？服务端渲染怎么做？<br>这里介绍一个库 react-loadable。他会把我们要异步加载的组件封装成一个高阶组件供我们使用<br>例如，我们异步加载 extra 组件，并且引入一个 loading 作为加载占位，代码如下： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> LoadableComponent = Loadable(&#123;</div><div class="line">     loader: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./components/extra'</span>),</div><div class="line">     loading: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;div&gt;组件加载中&lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">        );</span></div><div class="line"><span class="regexp">     &#125;</span></div><div class="line"><span class="regexp">&#125;);</span></div></pre></td></tr></table></figure>
<p>使用的时候我们直接在恰当的时机渲染 LoadableComponent 组件即可。<br>除此之外，react-loadable 还提供了预加载，服务端渲染等功能。这里就不详细介绍使用了，主要我们看一下源码实现的过程。</p>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><h4 id="函数入口"><a href="#函数入口" class="headerlink" title="函数入口"></a>函数入口</h4><p><code>react-loadable</code> 本质上就是一个高阶组件封装的过程。代码入口如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Loadable</span>(<span class="params">opts</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> createLoadableComponent(load, opts);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Loadable 接受我们传入的参数 opts, 再调用了createLoadableComponent函数，传入了 <code>load</code> 函数和 opts。 </p>
<h4 id="load-函数"><a href="#load-函数" class="headerlink" title="load 函数"></a>load 函数</h4><p>这里我们先来看一下 <code>load</code> 函数：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params">loader</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> promise = loader();</div><div class="line">    <span class="keyword">let</span> state = &#123;</div><div class="line">        loading: <span class="literal">true</span>,</div><div class="line">        loaded: <span class="literal">null</span>,    <span class="comment">// 组件实例</span></div><div class="line">        error: <span class="literal">null</span></div><div class="line">    &#125;;</div><div class="line">    state.promise = promise</div><div class="line">        .then(<span class="function"><span class="params">loaded</span> =&gt;</span> &#123;</div><div class="line">            state.loading = <span class="literal">false</span>;</div><div class="line">            state.loaded = loaded;</div><div class="line">            <span class="keyword">return</span> loaded;</div><div class="line">        &#125;)</div><div class="line">        .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</div><div class="line">            state.loading = <span class="literal">false</span>;</div><div class="line">            state.error = err;</div><div class="line">            <span class="keyword">throw</span> err;</div><div class="line">        &#125;);</div><div class="line">    <span class="keyword">return</span> state;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>load</code> 函数里初始化了一个state对象，执行 loader 方法(即我们传入的 loader 参数 (import(…))) 来加载异步组件。之后将返回结果保存在 state 的 loaded 属性中，加载状态保存在其他属性上。返回这个 state 供后续使用。 </p>
<h4 id="createLoadableComponent"><a href="#createLoadableComponent" class="headerlink" title="createLoadableComponent"></a>createLoadableComponent</h4><p>接下来，开始分析整个代码的主体部分 <code>createLoadableComponent</code> 函数。其作用就是包装加载后的异步组件，返回一个高阶组件供我们使用。代码如下：</p>

<p>首先检测必须含有 loading 组件，给参数添加默认值等。然后初始化一个 init 方法，用于执行上文的 <code>load</code> 函数以加载异步组件，并记录状态给 res 变量。之后就是返回 LoadableComponent 组件的过程。<br>在 LoadableComponent 中，发生如下情况：</p>
<ol>
<li><code>constructor</code> 阶段：调用 init 方法，保存状态到 state 上</li>
<li><code>componentWillMount</code> 阶段：<ul>
<li>设置 this._mounted 状态默认为 ture 表示加载完成</li>
<li>进行一些判断，如果 res.loading 为 false，说明之前的 init 执行出错，直接return</li>
<li>如果opts.delay 和 opts.timeout有值，且为number属性的话，就加个定时器用来延迟显示 loading 组件（避免闪烁）</li>
<li>声明 update 函数，用来根据异步组件加载的结果更新 state 值</li>
<li>如果 this.state.loading 或者 this.state.error 为 true，就是整体状态是正在加载或者出错了，就用 React.createElement 生成出loading的过渡组件</li>
<li>如果 this.state.loaded 有值了，说明传入的loader的promise异步操作执行完成，就开始渲染真正的组件，调用opts.render方法</li>
</ul>
</li>
</ol>
<p>大致过程就是这样，不贴代码了。还有一些细节，对 webpack 等处理，preload 静态方法等，也就一两句话，看看就知道了。  </p>
<h2 id="React-lazy"><a href="#React-lazy" class="headerlink" title="React.lazy"></a>React.lazy</h2><p>在 React 16.0.0 中，加入了 React.lazy 方法渲染动态导入为常规组件(尚不能用在服务端)。</p>
<img src="/2018/11/19/单页应用代码分割/a5.png" alt="a5.png" title=""> 
<p>主要用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> OtherComponent = React.lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./OtherComponent'</span>));</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">        &lt;div&gt;</div><div class="line">            &lt;OtherComponent /&gt;</div><div class="line">        &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">    );</span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure>
<p>当渲染此组件时，这将自动加载包含 OtherComponent 包。如果我们需要加载时的 Loading 组件做为<br>过度使用。我们需要调用 Suspense 组件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> OtherComponent = React.lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./OtherComponent'</span>));</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">        &lt;div&gt;</div><div class="line">            &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;<span class="regexp">/div&gt;&#125;&gt;</span></div><div class="line"><span class="regexp">                &lt;OtherComponent /</span>&gt;</div><div class="line">            &lt;<span class="regexp">/Suspense&gt;</span></div><div class="line"><span class="regexp">        &lt;/</span>div&gt;</div><div class="line">    );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>fallback prop（属性） 接受在等待加载组件时要渲染的任何 React 元素。</p>
<h2 id="异步加载时机"><a href="#异步加载时机" class="headerlink" title="异步加载时机"></a>异步加载时机</h2><p>想这么一个问题，如果 extra 包很大，我们点击打开 open 按钮后，要花很长一段时间才能看到组件内容。这样同样也不是什么好的体验。甚至，如果我们加载的包里面逻辑复杂，js 运行时间过长会阻塞掉用户的交互。这样要如何处理呢？</p>
<h3 id="Idle-Until-Urgent-（空闲等待-amp-紧急优先）"><a href="#Idle-Until-Urgent-（空闲等待-amp-紧急优先）" class="headerlink" title="Idle Until Urgent （空闲等待 &amp; 紧急优先）"></a>Idle Until Urgent （空闲等待 &amp; 紧急优先）</h3><p>点击 extra 肯定是延后操作，我们希望在主要任务都完成后，如果浏览器有空闲时间就来预加载组件(空闲等待)。如果我们点击打开按钮，这时候组件还没有加载完毕，那么我们就立刻加载组件(紧急优先)。<br>实现该操作，我们可以借助 requestIdleCallback 函数。改造代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"></div><div class="line"><span class="keyword">let</span> rIc = <span class="built_in">window</span>.requestIdleCallback;</div><div class="line"><span class="keyword">let</span> cIc = <span class="built_in">window</span>.cancelIdleCallback;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(prop) &#123;</div><div class="line">        <span class="keyword">super</span>(prop);</div><div class="line">        <span class="keyword">this</span>.state = &#123;</div><div class="line">            showExtra: <span class="literal">false</span></div><div class="line">        &#125;;</div><div class="line">        <span class="comment">// 开始空闲加载</span></div><div class="line">        <span class="keyword">this</span>.idleHandle = rIC(<span class="keyword">this</span>.loadComponent.bind(<span class="keyword">this</span>));</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 打开 extra 列表</span></div><div class="line">    <span class="keyword">async</span> handleOpenExtra() &#123;</div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.CExtra) &#123;</div><div class="line">            <span class="comment">// 如果没有加载好，则取消空闲加载，直接进入加载阶段</span></div><div class="line">            cIC(<span class="keyword">this</span>.idleHandle);</div><div class="line">            <span class="keyword">await</span> <span class="keyword">this</span>.loadComponent();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.setState(&#123;</div><div class="line">            showExtra: <span class="literal">true</span>;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 异步加载内容</span></div><div class="line">    <span class="keyword">async</span> loadComponent() &#123;</div><div class="line">        <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">'./components/extra'</span>).then();</div><div class="line">        <span class="keyword">this</span>.CExtra = result;</div><div class="line">    &#125;</div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;React.Fragment&gt;</div><div class="line">                &#123;<span class="keyword">this</span>.state.showExtra ? <span class="xml"><span class="tag">&lt;<span class="name">this.CExtra.default</span> /&gt;</span> : null&#125;</span></div><div class="line"><span class="xml">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line"><span class="xml">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleOpenExtra.bind(this)&#125;</span>&gt;</span>点击查看额外信息<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></div><div class="line"><span class="xml">        );</span></div><div class="line"><span class="xml">    &#125;</span></div><div class="line"><span class="xml">&#125;;</span></div><div class="line"><span class="xml">export default App;</span></div></pre></td></tr></table></figure>
<p>当然，你也可以用 react-loadable 来实现该例子，简要改动如下： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> LoadableMyComponent = Loadable(&#123;</div><div class="line">    loader: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./components/extra'</span>),</div><div class="line">    ...</div><div class="line">&#125;)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="comment">//...</span></div><div class="line">        <span class="keyword">this</span>.idleHandle = rIC(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">            LoadableMyComponent.preload()</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种空闲执行的方案，同样使用于执行那些不是很紧急但是耗时很长的函数。例如处理大量数据集，localStorage 中获取数据等等。合理利用 requestIdleCallback 可以减少网页的阻塞，提高效果。</p>
<h4 id="空闲任务队列"><a href="#空闲任务队列" class="headerlink" title="空闲任务队列"></a>空闲任务队列</h4><p>上面技术适用于可以通过单个函数计算出来的属性，但在某些情况下，逻辑可能无法写到单个函数里，或者，即使技术上可行，您仍然希望将其拆分为更小的一些函数，以免其长时间阻塞主线程。 这里提供一个 <a href="https://github.com/GoogleChromeLabs/idlize" target="_blank" rel="external">IdleQueue</a> 你可以在里面找到利用 requestIdleCallback 的姿势。</p>
<h2 id="mobx-是否需要拆分"><a href="#mobx-是否需要拆分" class="headerlink" title="mobx 是否需要拆分"></a>mobx 是否需要拆分</h2><p>通常我们在写业务的时候，会把 store 写在 <code>&lt;Provider&gt;</code> 上直直接注入。那我们需要对 mobx 的 store 也异步加载呢？理论上没有这个必要，因为 store 里面的内容确实一般不会很大并不是造成包体积过大的原因。优化效果不太明显。<br>当然如果非要异步加载的话，我这里有个想法，我们将 store 和 action 拆分出来。store 里面只包含数据：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexStore</span> </span>&#123;</div><div class="line">    @observable list = [];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtraStore</span> </span>&#123;</div><div class="line">    @observable extra = [];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>store 依然在全局在 Provider 注入，每个业务的 action 单独抽离成一个文件： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexAction</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(store) &#123;</div><div class="line">        <span class="keyword">this</span>.store = store;</div><div class="line">    &#125;</div><div class="line">    @action getList() &#123;</div><div class="line">        <span class="keyword">this</span>.store.list = [</div><div class="line">            <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span></div><div class="line">        ];</div><div class="line">    &#125;</div><div class="line">    @action addItem() &#123;</div><div class="line">        <span class="keyword">this</span>.store.list.push(<span class="keyword">this</span>.list.length + <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>action 们单独在一个全局变量中维护，需要异步加载的时候如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// actions 为一个全局变量</span></div><div class="line"><span class="keyword">import</span>(<span class="string">'../../actions/extra'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> ExtraAction = res &amp;&amp; res.__esModule ? res.default : res;</div><div class="line">    actions.extra = <span class="keyword">new</span> ExtraAction(self.props.rootStore.extraStore);</div><div class="line">    <span class="comment">// ....</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://webpack.docschina.org/guides/code-splitting/#%E5%8A%A8%E6%80%81%E5%AF%BC%E5%85%A5-dynamic-imports-" target="_blank" rel="external">webpack 动态导入</a></li>
<li><a href="https://juejin.im/post/5bdec712e51d4505525b0fba" target="_blank" rel="external">[译] Google 工程师提升网页性能的新策略：空闲执行，紧急优先</a></li>
<li><a href="https://book.douban.com/subject/30290509/" target="_blank" rel="external">React状态管理与同构实战</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;单页面代码分割&quot;&gt;&lt;a href=&quot;#单页面代码分割&quot; class=&quot;headerlink&quot; title=&quot;单页面代码分割&quot;&gt;&lt;/a&gt;单页面代码分割&lt;/h2&gt;&lt;p&gt;目前单页应用的 bundle.js 一般都会很大，这样的话会对启动时间造成影响。为此我们需要合理拆分 js 文件，然后在需要使用的时候才动态记在。&lt;br&gt;拆分 js 文件，我们通常会采用手段： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于业务逻辑和依赖库分割&lt;/li&gt;
&lt;li&gt;基于路由分割  &lt;/li&gt;
&lt;li&gt;基于组件分割  &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>从 javascript 角度看 Dart【三】</title>
    <link href="http://yoursite.com/2018/09/19/%E4%BB%8Ejs%E8%A7%92%E5%BA%A6%E7%9C%8Bdart3/"/>
    <id>http://yoursite.com/2018/09/19/从js角度看dart3/</id>
    <published>2018-09-19T06:06:54.000Z</published>
    <updated>2019-03-18T07:55:47.734Z</updated>
    
    <content type="html"><![CDATA[<p>前两篇文章，已经介绍了 Dart 的基础语法部分，并适当的结合 js 来进行对比。总的来看，Dart 设计的还是和 JS 很像的。本文，是最后一篇介绍 Dart 语言的。本文将着重介绍一下，Dart 的一些基础库。  </p>
<a id="more"></a>
<h2 id="库"><a href="#库" class="headerlink" title="库"></a>库</h2><p>使用import 和 library 机制可以方便的创建一个模块或分享代码。一个Dart 库不仅能够提供相应的API，还可以包含一些以_开头的变量用于在库内部使用。</p>
<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>用 <code>import</code> 来引入一个定义好的库。例如：  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">'dart:html'</span>;</div></pre></td></tr></table></figure>
<p>在import语句后面需要接上库文件的 URI。</p>
<ul>
<li>对Dart 语言提供的库文件以dart:xx 格式</li>
<li>其它第三方的库文件使用package:xx格式</li>
</ul>
<h4 id="设置库的前缀"><a href="#设置库的前缀" class="headerlink" title="设置库的前缀"></a>设置库的前缀</h4><p>如果两个库具有同样的标识符，则会出现命名冲突，可以用库前缀解决命名冲突。  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">'package:lib1/lib1.dart'</span>;</div><div class="line"><span class="keyword">import</span> <span class="string">'package:lib2/lib2.dart'</span> <span class="keyword">as</span> lib2;</div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">var</span> element1 = <span class="keyword">new</span> <span class="built_in">Element</span>();      <span class="comment">// 用 lib1 的 Element</span></div><div class="line"><span class="keyword">var</span> element2 = <span class="keyword">new</span> lib2.<span class="built_in">Element</span>(); <span class="comment">// 用 lib2 的 Element</span></div></pre></td></tr></table></figure>
<h4 id="只导入库的一部分"><a href="#只导入库的一部分" class="headerlink" title="只导入库的一部分"></a>只导入库的一部分</h4><p>如果你只使用库的一部分，可以导入只使用的功能 <code>show</code>, <code>hide</code>  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">'package:lib1/lib1.dart'</span> show foo; <span class="comment">// 仅导入 foo</span></div><div class="line"><span class="keyword">import</span> <span class="string">'package:lib2/lib2.dart'</span> hide foo; <span class="comment">// 除了 foo 外都导出</span></div></pre></td></tr></table></figure>
<h4 id="延迟加载库"><a href="#延迟加载库" class="headerlink" title="延迟加载库"></a>延迟加载库</h4><p>延迟加载机制，可以在需要使用的时候再加载库。关键字 <code>deferred as</code>  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">'package:deferred/hello.dart'</span> deferred <span class="keyword">as</span> hello;</div></pre></td></tr></table></figure>
<p>然后在需要使用的时候调用loadLibrary()方法。  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hello.loadLibrary();</div></pre></td></tr></table></figure>
<p>可以在代码中多次调用loadLibrary()方法。但是实际上它只会被执行一次。</p>
<h3 id="实现一个库"><a href="#实现一个库" class="headerlink" title="实现一个库"></a>实现一个库</h3><p>使用 <code>library</code> 加上一个标示符定义当前库的名字:  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span> point; <span class="comment">// 定义这个库的名字是 point</span></div></pre></td></tr></table></figure>
<h4 id="part-amp-part-of"><a href="#part-amp-part-of" class="headerlink" title="part &amp; part of"></a>part &amp; part of</h4><p>如果一个库的所有代码都写在一个文件中，会导致文件太大不好维护。Dart 允许你把代码写在多个文件中，并使用类似 include 的机制把多个文件包含到库的主文件中。库的主文件就是定义 library 语句所在的文件，在这个文件中可以使用 part 语句包含其它文件。part 语句的语法是 part 加上字符串形式的 fileUri 。与 part 语句相对应的是 part of 语句，需要在被包含的文件的顶部使用 part of 语句声明这个文件属于哪个库。  </p>
<p>library 语句所在的主文件中可以使用 import 和 part 语句，但 part of 所在的实现文件中不能使用任何 import、library 和 part 语句。库使用的所有 import 和 part 语句都必需放在主文件中声明。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 主文件 定义一个 math 库。它由 base，random 两部分组成</span></div><div class="line"><span class="keyword">library</span> math;</div><div class="line"><span class="keyword">part</span> <span class="string">'base.dart'</span>;</div><div class="line"><span class="keyword">part</span> <span class="string">'random.dart'</span>;</div></pre></td></tr></table></figure>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在 base.dart 文件的开头</span></div><div class="line"><span class="keyword">part</span> of math</div></pre></td></tr></table></figure>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在 random.dart 文件的开头</span></div><div class="line"><span class="keyword">part</span> of math;</div></pre></td></tr></table></figure>
<h4 id="export"><a href="#export" class="headerlink" title="export"></a>export</h4><p>你可以使用 export 语句重新导出库，比如：把多个较小的库组合为一个较大的库或者重新导出库的一部分作为一个新的库。既可以导出库的全部，也可以导出库的一部分（使用 show 和 hide）。</p>
<h2 id="dart-async-异步编程"><a href="#dart-async-异步编程" class="headerlink" title="dart:async - 异步编程"></a>dart:async - 异步编程</h2><h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>Future 通常座位异步函数得返回值出现，一个 Future 对象保证在未来的某个时间返回一个结果， 当一个 future 完成的时候，返回的值就可以使用了。这个东西，类似于 js 中的 Promise。利用 Dart 异步读取文件如下：  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">File f = <span class="keyword">new</span> File(<span class="string">"..."</span>);</div><div class="line">f.readAsString().then((<span class="built_in">String</span> str) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;).catchError((e) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>对比一下 js 的 Promise  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">path</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">        fs.readFile(path, (err, data) =&gt; &#123;</div><div class="line">            <span class="keyword">if</span>(err) &#123;</div><div class="line">                reject(err);</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                resolve(err);</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">readFile(<span class="string">'...'</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>可以看到，Future 和 Promise 本质是一个概念的。<br>使用 Future.wait() 静态函数来管理多个 Future 并等待所有 Future 一起完成。这一点类似 Promis.all。 </p>
<h3 id="async-amp-await"><a href="#async-amp-await" class="headerlink" title="async &amp; await"></a>async &amp; await</h3><p>和 js 一样， Dart 中 async 与 await 都是用来生命异步功能的，且 Dart 和 js 中关于这部分的用法几乎一样。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> readAllFile() <span class="keyword">async</span> &#123;</div><div class="line">    File f1 = <span class="keyword">new</span> File(<span class="string">"..."</span>);</div><div class="line">    File f2 = <span class="keyword">new</span> File(<span class="string">"..."</span>);</div><div class="line">    <span class="built_in">String</span> str1 = <span class="keyword">await</span> f1.readAsString();</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="built_in">String</span> str2 = <span class="keyword">await</span> f2.readAsString();</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line">readAllFile();</div></pre></td></tr></table></figure>
<h2 id="dart-convert-编解码"><a href="#dart-convert-编解码" class="headerlink" title="dart:convert 编解码"></a>dart:convert 编解码</h2><p>dart:convert 库 提供了 JSON 和 UTF-8 编码的转换器，还支持创建自定义转换器。 JSON 是一个用来表达结构化对象和集合的文本格式。 UTF-8 是一个常用的 Unicode 字符编码。<br>web 应用和命令行应用都可以使用 dart:convert 库。 import dart:convert 即可使用。</p>
<ul>
<li>编解码JSON：JSON.decode(), JSON.encode()</li>
<li>编解码UTF-8： UTF8.decode(),  UTF8.encode() </li>
</ul>
<p>其他的还有类似操作 dom 的 <code>dart:html</code> 库，命令行应用的 I/O 操作 <code>dart:io</code>，数学库 <code>dart:math</code> 等。就不多介绍了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两篇文章，已经介绍了 Dart 的基础语法部分，并适当的结合 js 来进行对比。总的来看，Dart 设计的还是和 JS 很像的。本文，是最后一篇介绍 Dart 语言的。本文将着重介绍一下，Dart 的一些基础库。  &lt;/p&gt;
    
    </summary>
    
      <category term="Flutter" scheme="http://yoursite.com/categories/Flutter/"/>
    
    
      <category term="Dart 语言" scheme="http://yoursite.com/tags/Dart-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="移动开发" scheme="http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>从 javascript 角度看 Dart【二】</title>
    <link href="http://yoursite.com/2018/09/13/%E4%BB%8Ejs%E8%A7%92%E5%BA%A6%E7%9C%8Bdart2/"/>
    <id>http://yoursite.com/2018/09/13/从js角度看dart2/</id>
    <published>2018-09-13T03:12:32.000Z</published>
    <updated>2018-09-17T11:19:04.349Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章，主要介绍了 Dart 的基本语法（数据类型，函数等），并与 js 进行了简单的对比，方便大家从 js 的角度来快速理解 Dart。本文主要介绍 Dart 中类的使用，总的来看差别不大，在构造函数上我们需要格外注意即可。还有几个 Dart 特有的内容也简单介绍下。    </p>
<a id="more"></a> 
<h2 id="新的运算符"><a href="#新的运算符" class="headerlink" title="新的运算符"></a>新的运算符</h2><p>在 Dart 中多出了一个类型测试操作符，具体如下：  </p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>类型转换</th>
</tr>
</thead>
<tbody>
<tr>
<td>as</td>
<td>类型转换</td>
</tr>
<tr>
<td>is</td>
<td>如果 对象是该类型 则返回 true</td>
</tr>
<tr>
<td>is!</td>
<td>如果 对象是该类型 则返回 false</td>
</tr>
</tbody>
</table>
<p>如果obj 实现了T 所定义的借口，那么obj is T 将返回 true。比如， obj is Object 必然返回 true。使用as 操作符可以把一个对象转换为特定类型。一般来说，如果在is 测试之后还有一些关于对象的表达式。 </p>
<h2 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h2><p>首先我们看下 js 简单声明一个类：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> id = <span class="string">"Point Map"</span>;</div><div class="line">	_prop = <span class="string">"prototype"</span>;</div><div class="line">	<span class="keyword">constructor</span>(x, y) &#123;</div><div class="line">    	<span class="keyword">this</span>.x = x;</div><div class="line">      	<span class="keyword">this</span>.y = y;</div><div class="line">    &#125;;</div><div class="line">	get prop() &#123;</div><div class="line">    	<span class="keyword">return</span> <span class="keyword">this</span>._prop;</div><div class="line">    &#125;</div><div class="line">    set prop(prop) &#123;</div><div class="line">    	<span class="keyword">this</span>._prop = prop + <span class="string">"test"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而用 Dart 翻译上面的 js 代码为：  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="built_in">double</span> y;</div><div class="line">    <span class="built_in">double</span> x;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">String</span> id = <span class="string">"Point Map"</span>;</div><div class="line">    <span class="built_in">String</span> _prop = <span class="string">"prototype"</span>;</div><div class="line">    Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</div><div class="line">    <span class="built_in">String</span> <span class="keyword">get</span> prop =&gt; <span class="keyword">this</span>._prop + <span class="string">"test"</span>;</div><div class="line">    <span class="keyword">void</span> <span class="keyword">set</span> prop(<span class="built_in">String</span> prop) =&gt; <span class="keyword">this</span>._prop = prop;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>Dart 的构造函数的名字和类名一样，其中 this 关键字引用当前实例。和 js 不同的是，Dart 提供了一个语法糖来方便我们赋值：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  num x;</div><div class="line">  num y;</div><div class="line">  <span class="comment">// 在构造函数体执行之前设置实例变量的语法糖</span></div><div class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="构造函数规则"><a href="#构造函数规则" class="headerlink" title="构造函数规则"></a>构造函数规则</h4><p>这一部分，完全和 js 的规则不一样， Dart 对构造函数有如下限制：</p>
<h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4><p>如果没有定义构造函数，则会生成一个默认构造函数。 默认构造函数没有参数，并调用没有参数的 superclass（父类） 构造函数。</p>
<h4 id="命名构造函数"><a href="#命名构造函数" class="headerlink" title="命名构造函数"></a>命名构造函数</h4><p>对于 Dart 语言，同样不支持函数重载。那么如果我想要我的类有多个构造方法该如何呢？Dart 使用命名构造来提供多个构造函数：  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="built_in">num</span> x;</div><div class="line">    <span class="built_in">num</span> y;</div><div class="line">    Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</div><div class="line">    <span class="comment">// 命名构造函数</span></div><div class="line">    Point.fromJson(<span class="built_in">Map</span> json) &#123;</div><div class="line">        x = json[<span class="string">'x'</span>];</div><div class="line">        y = json[<span class="string">'y'</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Point p = <span class="keyword">new</span> Point.fromJson(&#123;&#125;);</div></pre></td></tr></table></figure>
<h4 id="构造函数不支持继承"><a href="#构造函数不支持继承" class="headerlink" title="构造函数不支持继承"></a>构造函数不支持继承</h4><p>任何类型的构造函数都不支持继承。 如果你想让子类也能用父类的构造函数，则你必需在子类中定义并实现该构造函数。默认情况下，子类的构造函数，会调用父类无名无参数的默认构造函数。但是大多数情况下，我们的父类肯定有自己实现的构造函数。这样父类就不会有默认构造函数了，因此我们必须为子类的构造函数手工调用一个父类的构造函数。在冒号 (:) 后面和构造函数体之前指定要调用的父类构造函数。  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="built_in">double</span> x;</div><div class="line">    <span class="built_in">double</span> y;</div><div class="line">    Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</div><div class="line">    Point.fromJson(<span class="built_in">Map</span> data) &#123;</div><div class="line">        <span class="keyword">this</span>.x = data[<span class="string">'x'</span>];</div><div class="line">        <span class="keyword">this</span>.y = data[<span class="string">'y'</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3D</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="built_in">double</span> z;</div><div class="line">    Point3D(x, y, <span class="keyword">this</span>.z): <span class="keyword">super</span>(x, y);</div><div class="line">    Point3D.fromJson(<span class="built_in">Map</span> data): <span class="keyword">super</span>.fromJson(data) &#123;</div><div class="line">        <span class="comment">// 这里如果 this.z = data.z 就会报错</span></div><div class="line">        <span class="keyword">this</span>.z = data[<span class="string">"z"</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="常量构造函数"><a href="#常量构造函数" class="headerlink" title="常量构造函数"></a>常量构造函数</h4><p>如果你的类生成从来不改变的对象，则可以把这些对象定义为编译期常量。 用一个 const 构造函数并把实例变量设置为 final 来实现该功能。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImmutablePoint</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="built_in">num</span> x;</div><div class="line">    <span class="keyword">final</span> <span class="built_in">num</span> y;</div><div class="line">    <span class="keyword">const</span> ImmutablePoint(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ImmutablePoint origin = <span class="keyword">const</span> ImmutablePoint(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="工厂构造函数"><a href="#工厂构造函数" class="headerlink" title="工厂构造函数"></a>工厂构造函数</h4><p>如果一个构造函数并不总是创建一个新的对象，则可以用 factory 关键字来实现构造函数。 例如，一个工厂构造函数可以从缓存中返回一个实例，也可以返回一个子类型的实例。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="built_in">String</span> name;</div><div class="line">    <span class="built_in">bool</span> mute = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">// _cache is library-private, thanks to the _ in front of its name.</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Logger&gt; _cache = &lt;<span class="built_in">String</span>, Logger&gt;&#123;&#125;;</div><div class="line">  </div><div class="line">    <span class="keyword">factory</span> Logger(<span class="built_in">String</span> name) &#123;</div><div class="line">        <span class="keyword">if</span> (_cache.containsKey(name)) &#123;</div><div class="line">            <span class="keyword">return</span> _cache[name];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">final</span> logger = <span class="keyword">new</span> Logger._internal(name);</div><div class="line">            _cache[name] = logger;</div><div class="line">            <span class="keyword">return</span> logger;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    Logger._internal(<span class="keyword">this</span>.name);</div><div class="line">  </div><div class="line">    <span class="keyword">void</span> log(<span class="built_in">String</span> msg) &#123;</div><div class="line">        <span class="keyword">if</span> (!mute) &#123;</div><div class="line">            <span class="built_in">print</span>(msg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>工厂构造函数无法访问 this</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>Dart 为我们提供了 abstract 抽象类  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 该类为 abstract 的，所以无法实例化</span></div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractContainer</span> </span>&#123;</div><div class="line">    <span class="comment">// ...Define constructors, fields, methods...</span></div><div class="line">    <span class="keyword">void</span> updateChildren(); <span class="comment">// 抽象函数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="隐式接口"><a href="#隐式接口" class="headerlink" title="隐式接口"></a>隐式接口</h3><p>每个类都隐式的定义了一个包含所有实例变量和所实现所有接口的接口。 如果你想创建一个类 A 支持 类 B 的 API，但是又不想继承类 B 的实现，则类 A 可以实现 类 B 的隐式接口。<br>类通过 implements 语句来定义其实现的其他类的接口， 并实现需要的 API。 例如：  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 一个  person 类， 隐式接口包含  greet().</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> _name;          <span class="comment">// 该变量在隐式接口中，但是是库返回可见的</span></div><div class="line">    Person(<span class="keyword">this</span>._name);   <span class="comment">// 这是个构造函数，不在隐式接口中</span></div><div class="line">    <span class="built_in">String</span> greet(who) =&gt; <span class="string">'Hello, $who. I am $_name.'</span>; <span class="comment">// 在隐式接口中</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 实现 Person 的隐式接口。</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Imposter</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> _name = <span class="string">""</span>;      <span class="comment">// We have to define this, but we don't use it.</span></div><div class="line">    <span class="built_in">String</span> greet(who) =&gt; <span class="string">'Hi $who. Do you know who I am?'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>关键字 <code>extends</code> 和 js 继承没有太大区别，唯一需要注意的就是构造函数，之前已经说过了。另外在 Dart 中提供了注解功能。我们可以用 @override 来表明正在重写的函数或者变量。这一点有点类似 java。  </p>
<h3 id="类（静态）变量和函数"><a href="#类（静态）变量和函数" class="headerlink" title="类（静态）变量和函数"></a>类（静态）变量和函数</h3><p>关键字 <code>static</code> 和 js 没有太大区别。</p>
<h3 id="Typedefs"><a href="#Typedefs" class="headerlink" title="Typedefs"></a>Typedefs</h3><p>在 js 里面，我们很容易的就可以将函数作为参数进行传递。在 Dart 中我们也可以像 js 一样方便的传递函数。但是这样，有时候我们需要指明函数的类型，比如有多少个参数啊，返回值之类的，从而方便类型检查。<br>在 Dart 中函数也是对象。我们可以用 <code>typedef</code> 来定义一个名称来指明函数名字, 并且定义参数和返回值。  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">int</span> CalFunc(<span class="built_in">int</span> num1, <span class="built_in">int</span> num2);</div><div class="line">main() &#123;</div><div class="line">    <span class="built_in">int</span> num1 = <span class="number">1</span>;</div><div class="line">    <span class="built_in">int</span> num2 = <span class="number">2</span>;</div><div class="line">    <span class="built_in">int</span> calculate(CalFunc func) &#123;</div><div class="line">        <span class="keyword">return</span> func(num1, num2);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="built_in">int</span> result = calculate((<span class="built_in">int</span> num1, <span class="built_in">int</span> num2) &#123;</div><div class="line">        <span class="keyword">return</span> num1 - num2;</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">print</span>(result);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>（思考了下，java 能不能将函数作为参数直接传递？不能直接简单的传递，我们可以利用 interface 继承的方式；在 java8 中我们还可以用 lambada 表达式。）   </p>
<h3 id="Metadata（元数据）"><a href="#Metadata（元数据）" class="headerlink" title="Metadata（元数据）"></a>Metadata（元数据）</h3><p>用元数据给你的代码提供额外的信息。元数据注解 使用 @ 字符开头，后面跟着一个引用合作 编译期常量（例如 deprecated）或者调用一个 常量构造函数。<br>下面三个注解，所有的 Dart 代码都可以使用： @deprecated、 @override、 和 @proxy。<br>Metadata 可以出现在 library、 class、 typedef、 type parameter、 constructor、factory、 function、 field、 parameter、或者 variable declaration 、import 或者 export 之前。 以后，可以通过反射来获取元数据信息。 </p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型，由于 js 是动态类型的语言，因此没有泛型的概念。Dart 中我们可以使用泛型，也可以不适用。个人倾向于应该主动使用泛型，来帮助我们更好的表达意图。也方便 IDE 对代码的错误的检查，提高效率。具体内容比较杂，就不对比了。  </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Dart 语言的基础到这里就介绍的差不多了，总的来看还算简单。我觉得从 js 的角度 和 java 的角度综合分析下，还是蛮好玩的。下篇文章主要介绍下 Dart 常用库。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文章，主要介绍了 Dart 的基本语法（数据类型，函数等），并与 js 进行了简单的对比，方便大家从 js 的角度来快速理解 Dart。本文主要介绍 Dart 中类的使用，总的来看差别不大，在构造函数上我们需要格外注意即可。还有几个 Dart 特有的内容也简单介绍下。    &lt;/p&gt;
    
    </summary>
    
      <category term="Flutter" scheme="http://yoursite.com/categories/Flutter/"/>
    
    
      <category term="Dart 语言" scheme="http://yoursite.com/tags/Dart-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="移动开发" scheme="http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>从 javascript 角度看 Dart【一】</title>
    <link href="http://yoursite.com/2018/09/10/%E4%BB%8Ejs%E8%A7%92%E5%BA%A6%E7%9C%8Bdart/"/>
    <id>http://yoursite.com/2018/09/10/从js角度看dart/</id>
    <published>2018-09-10T04:09:50.000Z</published>
    <updated>2018-09-17T07:34:36.805Z</updated>
    
    <content type="html"><![CDATA[<p>最近准备尝试下谷歌的 Flutter 开发，因此需要学习一下 dart 语言。本文主要将 javascript 和 dart 进行对比，从而帮助我们快速入门 dart 语言。  </p>
<h2 id="Dart-简介"><a href="#Dart-简介" class="headerlink" title="Dart 简介"></a>Dart 简介</h2><blockquote>
<p>Dart是谷歌开发的计算机编程语言，后来被Ecma (ECMA-408)认定为标准。它被用于web、服务器、移动应用和物联网等领域的开发。它是宽松开源许可证（修改的BSD证书）下的开源软件。Dart是面向对象的、类定义的、单继承的语言。它的语法类似C语言，可以转译为JavaScript，支持接口(interfaces)、混入(mixins)、抽象类(abstract classes)、具体化泛型(reified generics)、可选类型(optional typing)和 sound type system。     </p>
</blockquote>
<a id="more"></a> 
<h3 id="Dart-应用"><a href="#Dart-应用" class="headerlink" title="Dart 应用"></a>Dart 应用</h3><p>Dart 语言最早提出的目的就是来做为浏览器开发语言， Google 本来打算将 Dart 的虚拟机放入浏览器中。后来没有实现，目前 Dart 可以被看做类似 typescript 一样。<br>在移动开发中，Google 开发的移动端 UI 框架 Flutter 采用的就是 Dart 语言。  </p>
<h2 id="Dart-语法"><a href="#Dart-语法" class="headerlink" title="Dart 语法"></a>Dart 语法</h2><h3 id="Dart-的几个基本概念"><a href="#Dart-的几个基本概念" class="headerlink" title="Dart 的几个基本概念"></a>Dart 的几个基本概念</h3><p>关于 Dart 语法有下面几个概念需要注意：  </p>
<ul>
<li>每个变量都是一个对象，。甚至数字，函数，和null都是对象。所有对象都继承自Object 类。这一点和 js 保持一致。  </li>
<li>Dart 的变量可以指定静态类型，也可以不指定，这里建议所有变量都要指明其类型。  </li>
<li>Dart 支持顶级方法（例如 main()），也支持实例函数和类函数（静态函数）。 你还可以在一个方法内创建另外一个方法（nested（嵌入方法） 或者 local functions（本地方法））。</li>
<li>同样，Dart 也支持顶级 变量，也支持实例变量和类变量（静态变量）。 实例变量有时候被称之为 值域或者属性（fields 或者 properties）。 </li>
<li>Dart 有两种 运行模式： 生产模式和检测模式（ production and checked）。生产模式效率高，但是测试模式可以在开发的时候帮助调试代码。</li>
</ul>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>对比如下：  </p>
<img src="/2018/09/10/从js角度看dart/a.png" alt="a.png" title="">     
<p>总的来说 Numbers, String 差异不多，这里仅仅列出一些不同点。  </p>
<p>在 dart 定义常量用关键字: <code>final</code>, <code>const</code> 两个，区别在于：  </p>
<ol>
<li>final 要求变量只能初始化一次，并不要求赋的值一定是编译时常量，可以是常量也可以不是。而 const 要求在声明时初始化，并且赋值必需为编译时常量。</li>
<li>final 是惰性初始化，即在运行时第一次使用前才初始化。而 const 是在编译时就确定值了。<br>(<code>编译时常量</code>指的是：字面量（如数字、bool、字符串、List的字面量形式）、其它常量 或者 常量的算术运算，也可以是这些的组合形式（递归要求），简单地说常量就是可以在编译时确定的值)</li>
</ol>
<p>注意： </p>
<ul>
<li>字符串的其他操作也和 js 一致(dart 中字符串没有 slice 方法)。 </li>
<li>在 dart 中字符串模板使用的是 单引号 ‘ ，而不是反引号 ` </li>
<li>我们可以用（’’’）来包含换行文本内容   </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String str = &apos;&apos;&apos;</div><div class="line">换行文本内容&apos;&apos;&apos;;</div></pre></td></tr></table></figure>
<p>对于 List 和 Maps 上的操作，不同的地方如下。  </p>
<h4 id="List-的差别"><a href="#List-的差别" class="headerlink" title="List 的差别"></a>List 的差别</h4><h5 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h5><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="comment">// 添加一个元素，类似 arr.push(5)</span></div><div class="line">arr.add(<span class="number">5</span>);  </div><div class="line"><span class="comment">// 一次添加多项, 类似 arr.concat(5, 6, 7, 8)</span></div><div class="line">arr.addAll([<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]);</div><div class="line"><span class="comment">// 指定位置添加元素, 类似 arr.splice(0, 0, 0);</span></div><div class="line">arr.insert(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line"><span class="comment">// 指定位置添加多个元素，类似 arr.splice(0, 0, -1, -2);</span></div><div class="line">arr.insertAll(<span class="number">0</span>, [<span class="number">-1</span>, <span class="number">-2</span>])</div></pre></td></tr></table></figure>
<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 删除第一个匹配到的元素  </span></div><div class="line">arr.remove(<span class="number">3</span>);</div><div class="line"><span class="comment">// 删除第几个元素，类似 arr.splice(1, 1);</span></div><div class="line">arr.removeAt(<span class="number">1</span>);</div><div class="line"><span class="comment">// 删除所有元素  </span></div><div class="line">arr.clear(); </div><div class="line"><span class="comment">// 移除开始下标（包括）至结束下标（不包括）内的元素  </span></div><div class="line">arr.removeRange(<span class="number">1</span>, <span class="number">4</span>);</div><div class="line"><span class="comment">// 移除并替换开始下标（包括）至结束下标（不包括）内的元素  </span></div><div class="line">arr.replaceRange(<span class="number">1</span>, <span class="number">4</span>, [<span class="number">6</span>, <span class="number">7</span>]);</div></pre></td></tr></table></figure>
<h5 id="查询-amp-排序"><a href="#查询-amp-排序" class="headerlink" title="查询 &amp; 排序"></a>查询 &amp; 排序</h5><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回从开始下标（包括）到结束下标（不包括）元素的列表; 类似： arr.slice(1, 3)  </span></div><div class="line">arr.sublist(<span class="number">1</span>, <span class="number">2</span>);  </div><div class="line"><span class="comment">// 数组随机排序  </span></div><div class="line">arr.shuffle();</div></pre></td></tr></table></figure>
<p>List 的操作 和 Set 操作几乎一致，这里就不在列出 Set 了。 </p>
<h4 id="Maps-的差别"><a href="#Maps-的差别" class="headerlink" title="Maps 的差别"></a>Maps 的差别</h4><p>map 通常被称之为 dictionary 或者 hash， map 是一个无序的 key-value（键-值） 对。 map 中每个值都有一个对应的键便于访问。和 JavaScript 不同， Dart 对象不是 map。    </p>
<h5 id="所有属性"><a href="#所有属性" class="headerlink" title="所有属性"></a>所有属性</h5><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">int</span>&gt; map = &#123;<span class="string">"a"</span>:<span class="number">1</span>, <span class="string">"b"</span>:<span class="number">2</span>, <span class="string">"c"</span>:<span class="number">3</span>&#125;;</div><div class="line"><span class="comment">// 返回映射的哈希码</span></div><div class="line">map.hashCode  </div><div class="line"><span class="comment">// 映射上是否没有键值对  </span></div><div class="line">map.isEmpty</div><div class="line"><span class="comment">// 映射上是否有键值对  </span></div><div class="line">map.isNotEmpty  </div><div class="line"><span class="comment">// 返回映射的所有键, 类似 Object.keys(map)</span></div><div class="line">map.keys    </div><div class="line"><span class="comment">// 返回对象运行时的类型  </span></div><div class="line">map.runtimeType</div></pre></td></tr></table></figure>
<p>注意：这里的 Map 并不像是简单的 js 的对象。如果你想访问属性建议使用 <code>[]</code> 的方式，例如：<code>map[&quot;a&quot;]</code>。不要使用 <code>.</code> 的方式 (在 Map 作为参数的时候会报错);</p>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 按顺序迭代映射    </span></div><div class="line">map.forEach((key, value)&#123;</div><div class="line">    <span class="built_in">print</span>(key + <span class="string">" : "</span> + value.toString());</div><div class="line">&#125;);  </div><div class="line"><span class="comment">// 添加其他键值对到映射中  </span></div><div class="line">map.addAll(&#123;<span class="string">"d"</span>:<span class="number">4</span>, <span class="string">"e"</span>:<span class="number">5</span>&#125;);  </div><div class="line"><span class="comment">// 映射是否包含指定键  </span></div><div class="line">map.containsKey(<span class="string">"d"</span>);  </div><div class="line"><span class="comment">// 映射是否包含指定值  </span></div><div class="line">map.containsValue(<span class="number">5</span>);  </div><div class="line"><span class="comment">// 删除指定键值对  </span></div><div class="line">map.remove(<span class="string">"a"</span>);</div><div class="line"><span class="comment">// 删除所有键值对</span></div><div class="line">map.clear();  </div><div class="line"><span class="comment">// 如果想在 key 不存在的时候 才设置该值，则可以用 putIfAbsent() 函数。该函数 的参数为返回设置的值的方法  </span></div><div class="line">m.putIfAbsent(<span class="string">"d"</span>, () =&gt; <span class="number">4</span>);</div></pre></td></tr></table></figure>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>在 Dart 中函数的基本语法和 JavaScript 类似，但是不需要输入 function 关键字，定义一个函数：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> printNumber(<span class="built_in">int</span> <span class="built_in">num</span>) &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="built_in">num</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><p>在 dart 中，比 js 多一个 可选参数的概念；可选参数可以是 <code>命名参数</code> 或者 <code>位置参数</code>，但是不能同时使用两种类型。</p>
<h5 id="可选-命名参数"><a href="#可选-命名参数" class="headerlink" title="可选 - 命名参数"></a>可选 - 命名参数</h5><p>用 {param1, param2, …} 来定义方法的 命名参数：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> text(&#123;<span class="built_in">int</span> a, <span class="built_in">int</span> b&#125;) &#123;</div><div class="line">    <span class="built_in">print</span>(a);</div><div class="line">    <span class="built_in">print</span>(b);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>注意</code>：对于这种方式如果想要设置参数默认值，需要用 <code>:</code> ; 其他的情况，我们可以采用 <code>=</code> 来设置默认值。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> text(&#123;<span class="built_in">int</span> a: <span class="number">1</span>, <span class="built_in">int</span> b&#125;) &#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当我们想给参数 b 设置内容的时候，调用如下： </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">text(b: <span class="number">5</span>);    <span class="comment">// 输出 null, 5</span></div></pre></td></tr></table></figure>
<h5 id="可选-位置参数"><a href="#可选-位置参数" class="headerlink" title="可选 - 位置参数"></a>可选 - 位置参数</h5><p>位于 [] 中间的参数为可选位置 参数：  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> setPersonInfo(<span class="built_in">String</span> name, <span class="built_in">int</span> age, [<span class="built_in">String</span> addr]) &#123;</div><div class="line">    <span class="comment">//....</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="main-函数"><a href="#main-函数" class="headerlink" title="main 函数"></a>main 函数</h4><p>每一个应用都必须有一个顶级函数main() ，这个函数就是整个应用的入口函数。main() 函数返回值类型为 void 并且有一个可选参数List<string> ，这点也是和 js 完全不同的。  </string></p>
<h4 id="语法作用域"><a href="#语法作用域" class="headerlink" title="语法作用域"></a>语法作用域</h4><p>Dart 是一种语法作用域语言，也就是说 变量的作用域 是根据代码布局静态判断的。 可以根据“变量位于花括号内外”来判断一个变量是否在作用域中。  </p>
<h4 id="语法闭包"><a href="#语法闭包" class="headerlink" title="语法闭包"></a>语法闭包</h4><p>一个 closure（闭包） 是一个可以 访问位于其语法作用域内变量的方法对象，即时该方法用在其定义的作用域之外，也可以访问这些变量。方法可以覆盖定义在附近作用域的变量。</p>
<h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><p>对于只有一个表达式的方法，你可以用缩写形式：<br>printNumber(number) =&gt; print(‘The number is $number.’);  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">printNumber(<span class="built_in">num</span> number) =&gt; <span class="built_in">print</span>(<span class="string">'The number is $number.'</span>);</div></pre></td></tr></table></figure>
<p>但是请注意，和 js 不同，dart 只有简写的时候 <code>=&gt;</code> 才是函数，如果不是简写，不能用这个 <code>=&gt;</code> 来表示一个函数。在 Dart 中，匿名函数是没有 <code>=&gt;</code> 的形式。 例如，匿名函数:  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// IIFE </span></div><div class="line"><span class="comment">// 在 javascript 这是正确的  </span></div><div class="line">(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</div><div class="line">&#125;)()  </div><div class="line"></div><div class="line"><span class="comment">// 在 Dart 中  </span></div><div class="line"></div><div class="line">() &#123;</div><div class="line">    print(<span class="number">1</span>);</div><div class="line">&#125;();</div><div class="line"></div><div class="line">lists.forEach((item) &#123;</div><div class="line">    <span class="comment">//....</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了，Dart 的基础语法部分。对于运算符，循环，判断等就不介绍了，因为和 js 一样。总的来看，Dart 和 js 语法相似度还是很高的。下篇，讲介绍 类与泛型。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近准备尝试下谷歌的 Flutter 开发，因此需要学习一下 dart 语言。本文主要将 javascript 和 dart 进行对比，从而帮助我们快速入门 dart 语言。  &lt;/p&gt;
&lt;h2 id=&quot;Dart-简介&quot;&gt;&lt;a href=&quot;#Dart-简介&quot; class=&quot;headerlink&quot; title=&quot;Dart 简介&quot;&gt;&lt;/a&gt;Dart 简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Dart是谷歌开发的计算机编程语言，后来被Ecma (ECMA-408)认定为标准。它被用于web、服务器、移动应用和物联网等领域的开发。它是宽松开源许可证（修改的BSD证书）下的开源软件。Dart是面向对象的、类定义的、单继承的语言。它的语法类似C语言，可以转译为JavaScript，支持接口(interfaces)、混入(mixins)、抽象类(abstract classes)、具体化泛型(reified generics)、可选类型(optional typing)和 sound type system。     &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Flutter" scheme="http://yoursite.com/categories/Flutter/"/>
    
    
      <category term="Dart 语言" scheme="http://yoursite.com/tags/Dart-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="移动开发" scheme="http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序架构原理</title>
    <link href="http://yoursite.com/2018/09/03/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/09/03/微信小程序架构原理/</id>
    <published>2018-09-03T07:09:20.000Z</published>
    <updated>2018-09-12T08:25:22.827Z</updated>
    
    <content type="html"><![CDATA[<p>好久没有整理文章了，懒了啊，补一个最近工作中调研的内容吧。本文主要从源码方面介绍微信小程序的架构原理，并简单总结下这么做的好处。</p>
<h2 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h2><p>微信小程序包含下面四种文件：  </p>
<ul>
<li>js </li>
<li>json    配置文件</li>
<li>wxml  小程序专用 xml 文件</li>
<li>wxss   小程序专用 css 文件     </li>
</ul>
<a id="more"></a>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">"window"</span>&gt;</span>&#123;&#123; text &#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Page(&#123;</div><div class="line">  data:&#123;</div><div class="line">    text:<span class="string">"这是一个页面"</span></div><div class="line">  &#125;,</div><div class="line">  onLoad:<span class="function"><span class="keyword">function</span>(<span class="params">options</span>)</span>&#123;</div><div class="line">    <span class="comment">// 页面初始化 options为页面跳转所带来的参数</span></div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// ........</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>微信小程序只能通过其 mvvm 的模板语法来动态改变页面，本身 js 并不支持 BOM 和 DOM 操作。  </p>
<h2 id="从开发工具看微信小程序架构"><a href="#从开发工具看微信小程序架构" class="headerlink" title="从开发工具看微信小程序架构"></a>从开发工具看微信小程序架构</h2><p> 在 mac 端直接解压应用 发现 app.nw 文件夹，即开发工具源码。可以知道该项目由 nw.js 编写；<br> 在 package.json 文件下找到应用入口：<code>app/html/index.html</code>。入口 js 为 <code>dist/app.js</code> 我们可以看到整个编辑器的大致逻辑。<br> 但我们关心的是构建过程，在 weapp 文件夹下存在 build.js 文件。没有找到有用的信息，只看到了 <code>upload</code> 模块，包括对大小限制，上传包命名。<br>为此怀疑，微信小程序本身和 RN 类似。是在服务端打包成 native 语言的。但是通过 android 边框测试发现，微信小程序根本不是 native 原生内容。<br>原生界面效果<br><img src="/2018/09/03/微信小程序架构原理/tgy-wx-a.jpg" alt="tgy-wx-a.jpg" title=""> </p>
<h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p>继续在 trans 文件夹下发现了编译模板。  </p>
<ul>
<li>transWxmlToJs     wxml 转 js</li>
<li>transWxssToCss    wxss 转 css</li>
<li>transConfigToPf   模板页配置</li>
<li>transWxmlToHtml   wxml 转 html</li>
<li>transManager      管理器  </li>
</ul>
<p>用到的内容：  </p>
<ul>
<li>发现用到了一个模板：<code>app.nw/app/dist/weapp/tpl/pageFrameTpl.js</code>, <code>app.mw/app.dist.weapp/tpl/appserviceTpl.js</code>  </li>
<li>wcc 可执行程序，wcc 用于转换 wxml 中的自定义 tag 为 virtual_dom</li>
<li>wcsc 可执行程序，用于将 wxss 转为 view 模块使用的 css 代码，使用方式为 wcsc xxx.wxss</li>
</ul>
<p>在模板中，我们发现使用了 <code>WAWebview.js</code> 文件，<code>WAService.js</code>文件。<br>在 transWxmlToJs 中我们发现一段 generateFuncReady 事件的函数。对比注册该事件的函数在 <code>WAWebview.js</code> 中。<br>我们尝试使用 wcc 对input.xml 文件进行编译。</p>
<blockquote>
<p>wcc -d input.xml  </p>
</blockquote>
<p>生成了一段脚本：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.__wcc_version__ = <span class="string">'v0.6vv_20161230_fbi'</span></div><div class="line"><span class="keyword">var</span> $gwxc</div><div class="line"><span class="keyword">var</span> $gaic = &#123;&#125;</div><div class="line">$gwx = <span class="function"><span class="keyword">function</span> (<span class="params">path, global</span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">        b &amp;&amp; a.children.push(b);</div><div class="line">    &#125;</div><div class="line">    ....</div></pre></td></tr></table></figure>
<p>通过代码我们发现，调用 $gwx 函数会再生成一个有返回值的函数(前提是 path 填写正确)；于是我们执行如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$gwx(<span class="string">"input.xml"</span>)(<span class="string">"test"</span>)</div></pre></td></tr></table></figure>
<p>得出如下内容：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"tag"</span>: <span class="string">"wx-page"</span>,</div><div class="line">    <span class="string">"children"</span>: [</div><div class="line">        &#123;</div><div class="line">            <span class="string">"tag"</span>: <span class="string">"wx-view"</span>,</div><div class="line">            <span class="string">"attr"</span>: &#123;</div><div class="line">                <span class="string">"class"</span>: <span class="string">"section"</span></div><div class="line">            &#125;,</div><div class="line">            <span class="string">"children"</span>: [</div><div class="line">                &#123;</div><div class="line">                    <span class="string">"tag"</span>: <span class="string">"wx-input"</span>,</div><div class="line">                    <span class="string">"attr"</span>: &#123;</div><div class="line">                        <span class="string">"autoFocus"</span>: <span class="literal">true</span>,</div><div class="line">                        <span class="string">"placeholder"</span>: <span class="string">"这是一个可以自动聚焦的input"</span></div><div class="line">                    &#125;,</div><div class="line">                    <span class="string">"children"</span>: []</div><div class="line">                &#125;</div><div class="line">            ]</div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这应该是一个类似 Virtual dom 的对象，交给了 WAWebivew.js 来渲染，标签名为 <code>wx-view</code>, <code>wx-input</code>。  </p>
<h4 id="WAWebview-js"><a href="#WAWebview-js" class="headerlink" title="WAWebview.js"></a>WAWebview.js</h4><ol>
<li><p>代码在最一开始提供的是兼容性工具，还有一个 WeixinJSBridge 引入。</p>
</li>
<li><p>接下来是一个 Reporter 对象，它的作用就是发送错误和性能统计数据给后台。</p>
<img src="/2018/09/03/微信小程序架构原理/tgy-wx-b.jpg" alt="tgy-wx-b.jpg" title="">  
</li>
<li><p>wx 核心对象，包含了 wx 对象下的 api。但是这里的 api 数量远远少于官方的 api 文档数量。</p>
  
<p>我们可以在代码里面发现，wx 下注册的 api 最终都会调用 WeixinJSBridge 方法，这个方法。应该是在打包的时候端上注入的。然而，我们也可以在 WAServeice.js 中找到该方法的定义。  </p>
<img src="/2018/09/03/微信小程序架构原理/tgy-wx-d.jpg" alt="tgy-wx-d.jpg" title="">    
<p>所以我们得到了一个结论，WAService.js 是编辑器用来接受 wx 方法回调的代码。</p>
</li>
<li>wxparser 对象，提供 dom 到 wx element 对象之间的映射操作，提供元素操作管理和事件管理功能。</li>
<li><p>之后代码是对 exparser 对象的处理，包括注册 WeixinJSBridge 全局事件，Virtual dom 算法实现，样式注入等。介绍几个组件重要的内容  </p>
<ul>
<li><p>exparser.registerBehavior 注册组件基础行为，供组件继承。</p>
<img src="/2018/09/03/微信小程序架构原理/tgy-wx-e.jpg" alt="tgy-wx-e.jpg" title="">      
</li>
<li><p>exparser.registerElement 为各种内置组件，注册模板，行为，属性，监听器等内容</p>
</li>
</ul>
</li>
</ol>
 
<p>这里我们观察到，组件：<code>wx-video</code>, <code>wx-canvas</code>, <code>wx-contact-button</code>, <code>wx-map</code>, <code>wx-textarea</code> 等 behaviors 都含有 “wx-native” 属性。这是不是意味着，这类组件都是 native 原生实现的呢。我们打开边框检查，发现这类组件确实都是原生的组件。<br><img src="/2018/09/03/微信小程序架构原理/tgy-wx-g.jpg" alt="tgy-wx-g.jpg" title="">   </p>
<img src="/2018/09/03/微信小程序架构原理/tgy-wx-h.jpg" alt="tgy-wx-h.jpg" title="">   
<p>综上，微信小程序的界面有部分组件使用原生方式实现的，native 组件层在 WebView 层之上。大部分还是用前端实现的，这样解释了微信小程序的一个bug。</p>
<blockquote>
<p>微信官方文档：<br><img src="/2018/09/03/微信小程序架构原理/tgy-wx-i.jpg" alt="tgy-wx-i.jpg" title="">  </p>
</blockquote>
<p>因为 scroll-view 是前端实现，在里面使用 native 组件，这样就无法监听滚动了。  </p>
<h4 id="WeixinJSBridge"><a href="#WeixinJSBridge" class="headerlink" title="WeixinJSBridge"></a>WeixinJSBridge</h4><p>组件是需要数据来渲染的，查看文档我们知道发送请求的 api 为 <code>wx.request</code>;通过上面分析，我么你知道 wx.request 实际调用的是 <code>WeixinJSBridge</code>。现在我们看看 <code>WeixinJSBridge</code><br><img src="/2018/09/03/微信小程序架构原理/tgy-wx-j.jpg" alt="tgy-wx-j.jpg" title=""><br>WeixinJSBridge 真正发送处理数据请求的是这端代码；如果当前环境是 ios, 那么调用 WKWebview的 window.webkit.messageHandlers.invokeHandler.postMessage。如果所处环境是 android 则调用 WeixinJSCore.invokeHandler(调用的时候，默认会带上当前webviewID)。  </p>
<h4 id="WAService-js"><a href="#WAService-js" class="headerlink" title="WAService.js"></a>WAService.js</h4><p>在对 WeixinJSBridge.js 分析中，我们并没有发现前端的通讯功能，路由能力，数据绑定等内容。进一步查看找到了一个 <code>WAService.js</code> 文件。<br>查看 <code>WAService.js</code> 文件源码：  </p>
<ol>
<li>在代码最开始，跟 WAWebview.js 一样的 WeixinJSBridge 兼容模块</li>
<li>然后是跟 WAWebview.js 一样的 Reporter 模块。</li>
<li>比 WAWebview.js 中 wx 功能更为丰富 wx 接口模块。(剩余的那部分 wx api 都在这里)</li>
<li>appServiceEngine 模块，提供 Page，App，GetApp 接口</li>
<li>为 window 对象添加 AMD 接口 require define  </li>
</ol>
<p>综上，WAService.js 主要实现的功能：  </p>
<ul>
<li>App() 小程序的入口；Page( ) 页面的入口</li>
<li>wx API;</li>
<li>页面有的作用域，提供模块化能力</li>
<li>数据绑定、事件分发、生命周期管理、路由管理</li>
</ul>
<p>到这里我们得出结论，小程序的架构方案：<br>   </p>
<p>整个小程序由两个 webview 组成，代码分为 UI 层和逻辑层。UI 层运行在第一个 WebView 当中，执行 DOM 操作和交互事件的响应，里面是 WAWebview.js 代码及编译后的内容。逻辑层执行在（第二个webview 中）独立的 JS 引擎中（iOS：JavaScriptCore, android：X5 JS解析器；统称 JSCore；开发工具中，nwjs Chrome 内核），WAService.js 代码和业务逻辑。</p>
<p>当我们对 view 层进行事件操作后，会通过 WeixinJSBridge 将数据传递到 Native 系统层。Native 系统层决定是否要用 native 处理，然后丢给 逻辑层进行用户的逻辑代码处理。逻辑层处理完毕后会将数据通过 WeixinJSBridge 返给 View 层。View 渲染更新视图。</p>
<h2 id="架构的讨论"><a href="#架构的讨论" class="headerlink" title="架构的讨论"></a>架构的讨论</h2><p>微信的这种架构，对逻辑和UI进行了完全隔离，小程序逻辑和UI完全运行在2个独立的Webview里面来处理。那么这么做的好处是啥？总感觉更加麻烦了。除了小程序外，还有人采用这种架构设计么？<br>在网上搜索了一下，目前使用这种架构的项目还真有一个：<a href="http://ued.qunar.com/yis/index.html" target="_blank" rel="external">去哪儿最新的 YIS 框架</a>   </p>
<blockquote>
<p>YIS 采取了类似小程序的架构，分为逻辑层和UI层。UI 层运行在 WebView 中，而逻辑层运行在独立的 JS 引擎中。相应地，整个应用的代码，也分为两个大的部分，一部分运行在 WebView 中，一部分运行在JS引擎中。JS引擎计算DOM结构输出给WebView，WebView转发用户的点击事件给JS引擎。</p>
</blockquote>
<p>该项目做法和小程序十分类似，唯一缺少的就是没有 native 的组件吧。然而官方文档上也没有任何介绍，为什么要这么做，只是说更流畅了。  </p>
<h3 id="一些看法"><a href="#一些看法" class="headerlink" title="一些看法"></a>一些看法</h3><p>传统 web 页面显示需要经历一下几个步骤:  </p>
<ol>
<li>webview 初始化</li>
<li>加载 HTML, CSS, JS</li>
<li>编译 JS</li>
<li>Render 计算</li>
<li>DOM Path</li>
</ol>
<p>而利用小程序架构后，我们就可以将上述过程拆解成两部分并行执行：<br>webview 部分：</p>
<ol>
<li>webview 初始化</li>
<li>加载HTML，CSS, JS (经过拆分后，体积大幅度减小)</li>
<li>编译JS</li>
<li>等待页面需要的数据</li>
<li>反序列化数据</li>
<li>执行Patch</li>
<li>渲染页面</li>
<li>等待更多消息</li>
</ol>
<p>jscore 部分：</p>
<ol>
<li>初始化</li>
<li>加载框架 js 代码</li>
<li>编译 js</li>
<li>加载业务逻辑 js 代码</li>
<li>编译 js</li>
<li>计算首屏虚拟 DOM 结构</li>
<li>序列化数据，传输</li>
<li>等待 webview 消息，或者 Native 消息  </li>
</ol>
<p>这样渲染进程和逻辑进程分离，并行处理：加速首屏渲染速度；避免单线程模型下，js 运算时间过长，UI 出现卡顿。<br>完全采用数据驱动的方式，不能直接操作 DOM，避免低质量的代码。</p>
<p>当然这种架构方案也有这一定的缺点：  </p>
<ol>
<li>不能灵活操作 DOM，无法实现较为复杂的效果。</li>
<li>部分和NA相关的视图有使用限制，如微信的 scrollView 内不能有 textarea。</li>
<li>页面大小、打开页面数量都受到限制。</li>
<li>需要单独开发适配，不能复用现有代码资源。</li>
<li>在 jscore 中JS 体积比较大的情况下，其初始化时间会产生影响。</li>
<li>传输数据中，序列化和反序列化耗时需要考虑</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.zhihu.com/question/50920642" target="_blank" rel="external">微信小程序底层的实现原理是怎样的</a></li>
<li><a href="http://www.bbs0101.com/archives/1495.html" target="_blank" rel="external">微信小程序架构解析，工作原理解析</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/22754296" target="_blank" rel="external">微信小程序架构分析</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久没有整理文章了，懒了啊，补一个最近工作中调研的内容吧。本文主要从源码方面介绍微信小程序的架构原理，并简单总结下这么做的好处。&lt;/p&gt;
&lt;h2 id=&quot;微信小程序&quot;&gt;&lt;a href=&quot;#微信小程序&quot; class=&quot;headerlink&quot; title=&quot;微信小程序&quot;&gt;&lt;/a&gt;微信小程序&lt;/h2&gt;&lt;p&gt;微信小程序包含下面四种文件：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;js &lt;/li&gt;
&lt;li&gt;json    配置文件&lt;/li&gt;
&lt;li&gt;wxml  小程序专用 xml 文件&lt;/li&gt;
&lt;li&gt;wxss   小程序专用 css 文件     &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Hybrid 开发" scheme="http://yoursite.com/categories/Hybrid-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="架构设计" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Hybird 开发" scheme="http://yoursite.com/tags/Hybird-%E5%BC%80%E5%8F%91/"/>
    
      <category term="微信小程序" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>immer.js 源码分析</title>
    <link href="http://yoursite.com/2018/08/16/immer-js%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/08/16/immer-js源码分析/</id>
    <published>2018-08-16T09:28:12.000Z</published>
    <updated>2018-08-16T09:28:20.674Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Riot.js 源码解析 【二】 组件详解</title>
    <link href="http://yoursite.com/2017/10/18/riot-js%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%902/"/>
    <id>http://yoursite.com/2017/10/18/riot-js源码解析2/</id>
    <published>2017-10-18T06:24:12.000Z</published>
    <updated>2017-11-22T02:54:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="riot-组件"><a href="#riot-组件" class="headerlink" title="riot 组件"></a>riot 组件</h1><p>使用 riot 编写组件是以 .tag 后缀结尾的文件，我们的 html, css, js 都可以放在里面。这些文件在编译阶段会被编译成对应的js代码(见<a href="">Riot.js 源码解析 【一】 基础内容</a>)。每个组件都是一个 Tag 对象(代码在 /tag/tag.js 里面)，里面包含了对象的各种属性和方法。本文主要介绍，riot 组件的生命周期，更新原理(一个粗粒度的 virtual dom)以及简单更新优化手段。<br><a id="more"></a>     </p>
<h1 id="Tag-对象"><a href="#Tag-对象" class="headerlink" title="Tag 对象"></a>Tag 对象</h1><p>每一个 riot.js 组件其实就是一个 Tag 对象。Tag 类被定义在 /tag/tag.js 文件下面。Tag 类基本内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// impl 包含组件的模板，逻辑等属性  </span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Tag</span>(<span class="params">impl = &#123;&#125;, conf = &#123;&#125;, innerHTML</span>) </span>&#123;</div><div class="line">    ...各种属性初始化</div><div class="line">    defineProperty(<span class="keyword">this</span>, <span class="string">'__'</span>, &#123;...&#125;)</div><div class="line">    defineProperty(<span class="keyword">this</span>, <span class="string">'_riot_id'</span>, ++__uid)</div><div class="line">    defineProperty(<span class="keyword">this</span>, <span class="string">'refs'</span>, &#123;&#125;)</div><div class="line">    ...</div><div class="line">    <span class="comment">// 定义组件更新方法</span></div><div class="line">    defineProperty(<span class="keyword">this</span>, <span class="string">'update'</span>, <span class="function"><span class="keyword">function</span> <span class="title">tagUpdate</span>(<span class="params">data</span>)</span>&#123;...&#125;.bind(<span class="keyword">this</span>))</div><div class="line">    <span class="comment">// 定义组件 mixin 方法</span></div><div class="line">    defineProperty(<span class="keyword">this</span>, <span class="string">'update'</span>, <span class="function"><span class="keyword">function</span> <span class="title">tagMixin</span>(<span class="params">data</span>)</span>&#123;...&#125;.bind(<span class="keyword">this</span>))</div><div class="line">    <span class="comment">// 定义组件加载方法</span></div><div class="line">    defineProperty(<span class="keyword">this</span>, <span class="string">'mount'</span>, <span class="function"><span class="keyword">function</span> <span class="title">tagMount</span>(<span class="params">data</span>)</span>&#123;...&#125;.bind(<span class="keyword">this</span>))</div><div class="line">    <span class="comment">// 定义组件卸载方法</span></div><div class="line">    defineProperty(<span class="keyword">this</span>, <span class="string">'mount'</span>, <span class="function"><span class="keyword">function</span> <span class="title">tagUnmount</span>(<span class="params">data</span>)</span>&#123;...&#125;.bind(<span class="keyword">this</span>))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="riot-生命周期"><a href="#riot-生命周期" class="headerlink" title="riot 生命周期"></a>riot 生命周期</h1><p>riot 组件状态分为以下几个部分：  </p>
<ul>
<li>before-mount：标签被加载之前</li>
<li>mount：标签实例被加载到页面上以后</li>
<li>update：允许在更新之前重新计算上下文数据</li>
<li>updated：标签模板更新后</li>
<li>before-unmount：标签实例被卸载之前</li>
<li>unmount：标签实例被从页面上卸载后    </li>
</ul>
<p>riot.js 采用事件驱动的方式来进行通讯，我们可以采用如下函数来监听上面的事件，例如处理 update 事件：  </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">riot-demo</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript">        <span class="keyword">this</span>.on(<span class="string">'update'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></div><div class="line"><span class="javascript">            <span class="comment">// 标签更新后的处理</span></span></div><div class="line"><span class="undefined">        &#125;)</span></div><div class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">riot-demo</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="组件状态触发时机"><a href="#组件状态触发时机" class="headerlink" title="组件状态触发时机"></a>组件状态触发时机</h2><p>当我们调用 <code>riot.mount()</code> 渲染指定组件的时候，riot 会从 <code>__TAG_IMPL</code> 中获取相对应的已经注册好的模板内容，并生成相应的 <code>Tag</code> 实例对象。并且触发其上的 <code>Tag.mount()</code> 函数，最后将 <code>Tag</code> 对象缓存到 <code>__TAGS_CACHE</code> 中。代码如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountTo</span>(<span class="params">root, tagName, opts, ctx</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> impl = __TAG_IMPL[tagName],   <span class="comment">// 获取 html 模板</span></div><div class="line">        implClass = __TAG_IMPL[tagName].class, <span class="comment">// ?</span></div><div class="line">        tag = ctx || (implClass ? <span class="built_in">Object</span>.create(implClass.prototype) : &#123;&#125;),</div><div class="line">        innerHTML = root._innerHTML = root._innerHTML || root.innerHTML</div><div class="line">    <span class="keyword">var</span> conf = extend(&#123;</div><div class="line">        root: root,</div><div class="line">        opts: opts</div><div class="line">    &#125;, &#123;</div><div class="line">        parent: opts ? opts.parent : <span class="literal">null</span></div><div class="line">    &#125;)</div><div class="line">    <span class="keyword">if</span> (impl &amp;&amp; root) Tag.apply(tag, [impl, conf, innerHTML]);</div><div class="line">    <span class="keyword">if</span> (tag &amp;&amp; tag.mount) &#123;</div><div class="line">        tag.mount(<span class="literal">true</span>)</div><div class="line">        <span class="comment">// add this tag to the virtualDom variable</span></div><div class="line">        <span class="keyword">if</span> (!contains(__TAGS_CACHE, tag)) __TAGS_CACHE.push(tag)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> tag</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Tag.mount()</code> 函数流程如下：      </p>
<img src="/2017/10/18/riot-js源码解析2/a.png" alt="a.png" title="">  
<p>组件加载阶段，首先会整理标签上所有的 attribute 的内容，区分普通属性，和带有表达式 expr 的属性。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">defineProperty(<span class="keyword">this</span>, <span class="string">'mount'</span>, <span class="function"><span class="keyword">function</span> <span class="title">tagMount</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    ...</div><div class="line"></div><div class="line">    parseAttributes.apply(parent, [root, root.attributes, (attr, expr) =&gt; &#123;</div><div class="line">        <span class="comment">// 检测 expr 是否在 RefExpr 的原型链中</span></div><div class="line">        <span class="keyword">if</span> (!isAnonymous &amp;&amp; RefExpr.isPrototypeOf(expr)) expr.tag = <span class="keyword">this</span>;</div><div class="line">        <span class="comment">// 挂载在 root.attributs 上面 root 为组件所在的 dom 对象</span></div><div class="line">        attr.expr = expr</div><div class="line">        instAttrs.push(attr)</div><div class="line">    &#125;])   </div><div class="line"></div><div class="line">    <span class="comment">// impl 对象包含组件上的各种属性，包括模板，逻辑等内容</span></div><div class="line">    implAttrs = []</div><div class="line">    walkAttrs(impl.attrs, (k, v) =&gt; &#123;</div><div class="line">        implAttrs.push(&#123;</div><div class="line">            name: k,</div><div class="line">            value: v</div><div class="line">        &#125;)</div><div class="line">    &#125;)</div><div class="line">    <span class="comment">// 检查的是 implAttrs</span></div><div class="line">    parseAttributes.apply(<span class="keyword">this</span>, [root, implAttrs, (attr, expr) =&gt; &#123;</div><div class="line">        <span class="keyword">if</span> (expr) expressions.push(expr)   <span class="comment">//插入表达式</span></div><div class="line">        <span class="keyword">else</span> setAttr(root, attr.name, attr.value)</div><div class="line">    &#125;])</div><div class="line"></div><div class="line">    ... </div><div class="line">&#125;).bind(<span class="keyword">this</span>)</div></pre></td></tr></table></figure>
<p>初始化这些表达式内容，然后为组件添加全局注册的mixin 内容。接下来，会执行我们为组件添加的函数内容，此时触发 <code>before-mount</code> 事件。触发完毕后，解析标签上的表达式，比如 if each 等内容，然后执行组件的 <code>update()</code> 函数。    </p>
<p>在 <code>update()</code> 函数中，首先会检查用户是否定义了组件的 <code>shouldUpdate()</code> 函数，如果有定义则传入两个参数，第一个是想要更新的内容(即调用this.update() 时传入的参数)。第二个为接收的父组件更新的 opts 内容。若该函数返回值为 true 则更新渲染，否则放弃。  (这里需要注意，<code>Tag.mount()</code> 阶段由于组件尚未处于记载完毕状态，因此不会触发 shouldUpdate() 函数)。    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">defineProperty(<span class="keyword">this</span>, <span class="string">'update'</span>, <span class="function"><span class="keyword">function</span> <span class="title">tagUpdate</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">// shouldUpdate 返回值检测</span></div><div class="line">    <span class="keyword">if</span> (canTrigger &amp;&amp; <span class="keyword">this</span>.isMounted &amp;&amp; isFunction(<span class="keyword">this</span>.shouldUpdate) &amp;&amp; !<span class="keyword">this</span>.shouldUpdate(data, nextOpts)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span></div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">    <span class="comment">// 扩展opts</span></div><div class="line">    extend(opts, nextOpts)</div><div class="line">    <span class="keyword">if</span> (canTrigger) <span class="keyword">this</span>.trigger(<span class="string">'update'</span>, data)</div><div class="line">    update.call(<span class="keyword">this</span>, expressions)</div><div class="line">    <span class="keyword">if</span> (canTrigger) <span class="keyword">this</span>.trigger(<span class="string">'updated'</span>)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span></div><div class="line">&#125;).bind(<span class="keyword">this</span>);</div></pre></td></tr></table></figure>
<p>之后会触发 <code>update</code> 事件，开始渲染新的组件。渲染完毕后触发 <code>updated</code> 事件。   </p>
<p>加载完毕后，修改组件状态 <code>defineProperty(this, &#39;isMounted&#39;, true)</code>。如果渲染的组件不是作为子组件的话，我们就触发自身的 <code>mount</code> 事件。否则的话，需要等到父组件加载完毕后，或者更新完毕后(已经加载过了)，再触发。    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">defineProperty(<span class="keyword">this</span>, <span class="string">'mount'</span>, <span class="function"><span class="keyword">function</span> <span class="title">tagMount</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    ...</div><div class="line">    defineProperty(<span class="keyword">this</span>, <span class="string">'root'</span>, root)</div><div class="line">    defineProperty(<span class="keyword">this</span>, <span class="string">'isMounted'</span>, <span class="literal">true</span>)</div><div class="line">    <span class="keyword">if</span> (skipAnonymous) <span class="keyword">return</span></div><div class="line">    <span class="comment">// 如果不是子组件则触发</span></div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.parent) &#123;</div><div class="line">        <span class="keyword">this</span>.trigger(<span class="string">'mount'</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 否则需要等待父组件的状态渲染状态</span></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">const</span> p = getImmediateCustomParentTag(<span class="keyword">this</span>.parent)</div><div class="line">        p.one(!p.isMounted ? <span class="string">'mount'</span> : <span class="string">'updated'</span>, () =&gt; &#123;</div><div class="line">            <span class="keyword">this</span>.trigger(<span class="string">'mount'</span>)</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span></div><div class="line">&#125;).bind(<span class="keyword">this</span>)</div></pre></td></tr></table></figure>
<p>当我们调用 <code>tag.unmount</code> 卸载组件的时候，首先会触发 <code>before-unmount</code> 事件。再接下来清除所有的属性和事件监听等内容后，触发 ‘unmount’ 事件。  </p>
<h2 id="update-问题"><a href="#update-问题" class="headerlink" title="update 问题"></a>update 问题</h2><p>我们知道除了手动调用 <code>tag.update</code>的方式更新组件，我们通过绑定 dom 事件也能自动触发。这主要是因为在 riot 组件中绑定事件，默认会追加调用 update 的方法。相关代码如下：   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleEvent</span>(<span class="params">dom, handler, e</span>) </span>&#123;</div><div class="line">    <span class="comment">// 执行事件回调</span></div><div class="line">    handle.call(<span class="keyword">this</span>, e);</div><div class="line">    ...</div><div class="line">    <span class="comment">// 阻止 自动 update</span></div><div class="line">    <span class="keyword">if</span> (!settings.autoUpdate) <span class="keyword">return</span>  </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样的话，任何事件操作即使没有引起UI重新渲染，也会触发 update, updated 阶段。我们可以通过设置 <code>riot.settings.autoUpdate (default true)</code> 来更改这种行为。  </p>
<h1 id="更新原理"><a href="#更新原理" class="headerlink" title="更新原理"></a>更新原理</h1><p>在 riot.js 中，想要更新组件我们必须手动调用 <code>tag.update()</code> 方法才可以或者通过绑定 dom 事件触发(通过模板绑定的事件，会在回调执行完毕后自动触发 tag.update )，并不能做到实时的更新处理。例如：    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;riot-demo&gt;</div><div class="line">    &lt;h1&gt;&#123; title &#125;&lt;<span class="regexp">/h1&gt;</span></div><div class="line"><span class="regexp">    &lt;button click=&#123; handleClick &#125;&gt;修改内容&lt;/</span>button&gt;</div><div class="line">    &lt;script&gt;</div><div class="line">        <span class="keyword">this</span>.title = <span class="string">"标题"</span></div><div class="line">        handleClick() &#123;</div><div class="line">            <span class="keyword">this</span>.title = <span class="string">"新标题"</span>;</div><div class="line">            <span class="keyword">this</span>.update();   <span class="comment">// 调用 update 方法才能重新渲染组件</span></div><div class="line">        &#125;</div><div class="line">    &lt;<span class="regexp">/script&gt;</span></div><div class="line"><span class="regexp">&lt;/</span>riot-demo&gt;</div></pre></td></tr></table></figure>
<p>riot.js 并没有提供 virtual dom 的功能，而是实现了一个粗粒度的 virtual dom。riot.js 为每个组件创建的 tag 对象中都保存一个 expressions 数组，更新的时候遍历 expressions 数组，对比旧值，如果有变化就更新DOM。这种更新机制类似angular的脏检查，但是仅有一轮检查（单项数据流）。更新处理依照模板类型来处理：  </p>
<ul>
<li>文本内容的，直接： dom.nodeValue = value</li>
<li>值为空，而且关联的 DOM 属性是 checked/selected 等这种没有属性值的，移除对应的属性</li>
<li>值为函数的，则进行事件绑定</li>
<li>属性名为 if，则做条件判断处理</li>
<li>做了 show/hide 的语法糖处理：   </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">toggleVisibility</span>(<span class="params">dom, show</span>) </span>&#123;</div><div class="line">    dom.style.display = show ? <span class="string">''</span> : <span class="string">'none'</span></div><div class="line">    dom[<span class="string">'hidden'</span>] = show ? <span class="literal">false</span> : <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>普通属性的，直接设置其值</li>
</ul>
<p>riot.js 和 react 一样也有 props(静态，riot 中为 opts) 和本身数据(动态)，具有和 react 一样的输入。但是输出的时候，由于没有 virtual dom UI的更新并没有集中处理，是分散的。<br>riot.js 采用的这种方式，代码量上大大的减少，但是也带来了比较严重的性能问题。  </p>
<h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><p>首先我们来看一段 vue 代码：    </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span>&gt;</span></div><div class="line">            &#123;&#123; item.name &#125;&#125; --- &#123;&#123; item.age &#125;&#125;</div><div class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"handleClick"</span>&gt;</span>更新列表项<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> demo = <span class="keyword">new</span> Vue(&#123;</div><div class="line">    el: <span class="string">'#demo'</span>,</div><div class="line">    data: &#123;</div><div class="line">        items: [</div><div class="line">          &#123; <span class="attr">name</span>: <span class="string">'tgy'</span>, <span class="attr">age</span>: <span class="number">23</span>&#125;,</div><div class="line">        ]</div><div class="line">    &#125;,</div><div class="line">    methods: &#123;</div><div class="line">        handleClick: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.items = [</div><div class="line">                &#123; <span class="attr">name</span>: <span class="string">'tgy'</span>, <span class="attr">age</span>: <span class="number">23</span>&#125;,</div><div class="line">                &#123; <span class="attr">name</span>: <span class="string">'hy'</span>, <span class="attr">age</span>: <span class="number">22</span>&#125;,</div><div class="line">            ]</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    mounted: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">         <span class="built_in">console</span>.log(<span class="string">"组件挂载完毕"</span>);</div><div class="line">         <span class="built_in">document</span>.querySelector(<span class="string">"li"</span>).extraType = <span class="string">"origin"</span>;</div><div class="line">    &#125;,</div><div class="line">    updated: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">         <span class="built_in">console</span>.log(<span class="string">"组件更新完毕"</span>);</div><div class="line">         <span class="built_in">console</span>.log(<span class="built_in">document</span>.querySelector(<span class="string">"li"</span>).extraType);</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>代码很简单，单击按钮，为列表添加一条新数据。在组件挂载完毕后，为第一个 li 的 property 上面添加了 extraType 属性。列表更新后，再去访问这个 li 的 extraType 属性。运行结果如下：  </p>
<img src="/2017/10/18/riot-js源码解析2/b.png" alt="b.png" title="">  
<p>不出意料，可以正常访问到 li 的type属性。这说明了，在更新过程中，第一个 li 节点仅仅是 textContent 发生了改变而不是重新创建的。这样的结果得益于 virtual dom 算法，保证更新最小变动。同样的我们用 riot 来重写上面的代码。      </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">content-demo</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">each</span>=<span class="string">&#123;</span> <span class="attr">items</span> &#125;&gt;</span>&#123; name &#125; -- &#123; age &#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn"</span> <span class="attr">click</span>=<span class="string">&#123;</span> <span class="attr">handleClick</span> &#125;&gt;</span>订阅内容<span class="tag">&lt;/<span class="name">button</span>&gt;</span>  </div><div class="line">   <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript">        <span class="keyword">let</span> self = <span class="keyword">this</span>;</span></div><div class="line"><span class="javascript">        <span class="keyword">this</span>.items = [</span></div><div class="line"><span class="javascript">            &#123;<span class="string">"name"</span>: <span class="string">"tgy"</span>, <span class="attr">age</span>: <span class="number">23</span>&#125;</span></div><div class="line"><span class="undefined">        ];</span></div><div class="line"><span class="undefined">        handleClick() &#123;</span></div><div class="line"><span class="javascript">            <span class="keyword">this</span>.items = [</span></div><div class="line"><span class="javascript">                &#123;<span class="string">"name"</span>: <span class="string">"tgy"</span>, <span class="attr">age</span>: <span class="number">23</span>&#125;,</span></div><div class="line"><span class="javascript">                &#123;<span class="string">"name"</span>: <span class="string">"hy"</span>, <span class="attr">age</span>: <span class="number">22</span>&#125;</span></div><div class="line"><span class="undefined">            ]</span></div><div class="line"><span class="undefined">        &#125;</span></div><div class="line"><span class="javascript">        <span class="keyword">this</span>.on(<span class="string">'mount'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></div><div class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"组件加载完毕"</span>);</span></div><div class="line"><span class="javascript">            <span class="built_in">document</span>.querySelector(<span class="string">"li"</span>).extraType = <span class="string">"origin"</span>;</span></div><div class="line"><span class="undefined">        &#125;)</span></div><div class="line"><span class="javascript">        <span class="keyword">this</span>.on(<span class="string">'updated'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></div><div class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"组件更新完毕"</span>);</span></div><div class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="built_in">document</span>.querySelector(<span class="string">"li"</span>).extraType);</span></div><div class="line"><span class="undefined">        &#125;)</span></div><div class="line"><span class="undefined">   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">content-demo</span>&gt;</span></div></pre></td></tr></table></figure>
<p>查看运行结果：  </p>
<img src="/2017/10/18/riot-js源码解析2/c.png" alt="c.png" title="">
<p>extraType 找不到了，所有的 li 节点都被重新构建了。这里面发生了什么，查看源码 /tag/each.js。渲染逻辑代码如下：     </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">_each</span>(<span class="params">dom, parent, expr</span>) </span>&#123;</div><div class="line">    ...</div><div class="line">    expr.update = <span class="function"><span class="keyword">function</span> <span class="title">updateEach</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        ...</div><div class="line">        each(items, <span class="function"><span class="keyword">function</span> (<span class="params">item, i</span>) </span>&#123;</div><div class="line">            <span class="comment">// 仅仅记录 items 是对象的</span></div><div class="line">            <span class="keyword">var</span></div><div class="line">                doReorder = mustReorder &amp;&amp; <span class="keyword">typeof</span> item === T_OBJECT &amp;&amp; !hasKeys,</div><div class="line">                <span class="comment">// 旧数据</span></div><div class="line">                oldPos = oldItems.indexOf(item),</div><div class="line">                <span class="comment">// 是新的</span></div><div class="line">                isNew = oldPos === <span class="number">-1</span>,</div><div class="line">                pos = !isNew &amp;&amp; doReorder ? oldPos : i,</div><div class="line">                tag = tags[pos],</div><div class="line">                <span class="comment">// 必须追加</span></div><div class="line">                mustAppend = i &gt;= oldItems.length,</div><div class="line">                <span class="comment">// 必须创建 isNew</span></div><div class="line">                mustCreate = doReorder &amp;&amp; isNew || !doReorder &amp;&amp; !tag</div><div class="line">                <span class="comment">// 有key值得时候需要 mkitem</span></div><div class="line">            item = !hasKeys &amp;&amp; expr.key ? mkitem(expr, item, i) : item</div><div class="line">            <span class="comment">// 必须创建一个新 tag </span></div><div class="line">            <span class="keyword">if</span> (mustCreate) &#123;</div><div class="line">                tag = <span class="keyword">new</span> Tag(impl, &#123;</div><div class="line">                    parent,</div><div class="line">                    isLoop,</div><div class="line">                    isAnonymous,</div><div class="line">                    tagName,</div><div class="line">                    root: dom.cloneNode(isAnonymous),</div><div class="line">                    item,</div><div class="line">                    index: i,</div><div class="line">                &#125;, dom.innerHTML)</div><div class="line"></div><div class="line">                <span class="comment">// mount the tag</span></div><div class="line">                tag.mount()</div><div class="line">                <span class="keyword">if</span> (mustAppend)</div><div class="line">                    append.apply(tag, [frag || root, isVirtual])</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    insert.apply(tag, [root, tags[i], isVirtual])</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (!mustAppend) oldItems.splice(i, <span class="number">0</span>, item)</div><div class="line">                tags.splice(i, <span class="number">0</span>, tag)</div><div class="line">                <span class="keyword">if</span> (child) arrayishAdd(parent.tags, tagName, tag, <span class="literal">true</span>)</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pos !== i &amp;&amp; doReorder) &#123;</div><div class="line">                <span class="comment">// move</span></div><div class="line">                <span class="comment">// 移动</span></div><div class="line">                <span class="keyword">if</span> (contains(items, oldItems[pos])) &#123;</div><div class="line">                    move.apply(tag, [root, tags[i], isVirtual])</div><div class="line">                    <span class="comment">// move the old tag instance</span></div><div class="line">                    tags.splice(i, <span class="number">0</span>, tags.splice(pos, <span class="number">1</span>)[<span class="number">0</span>])</div><div class="line">                    <span class="comment">// move the old item</span></div><div class="line">                    oldItems.splice(i, <span class="number">0</span>, oldItems.splice(pos, <span class="number">1</span>)[<span class="number">0</span>])</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (expr.pos) tag[expr.pos] = i</div><div class="line">                <span class="keyword">if</span> (!child &amp;&amp; tag.tags) moveNestedTags.call(tag, i)</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 缓存原始数据到节点上</span></div><div class="line">            tag.__.item = item</div><div class="line">            tag.__.index = i</div><div class="line">            tag.__.parent = parent;</div><div class="line">            <span class="comment">// 如果不是创建的，我们需要更新节点内容。</span></div><div class="line">            <span class="keyword">if</span> (!mustCreate) tag.update(item)</div><div class="line">        &#125;)</div><div class="line">        <span class="comment">// remove the redundant tags</span></div><div class="line">        <span class="comment">// 删除多余的标签</span></div><div class="line">        unmountRedundant(items, tags)</div><div class="line">        <span class="comment">// 记录旧的数据</span></div><div class="line">        <span class="comment">// clone the items array</span></div><div class="line">        oldItems = items.slice()</div><div class="line">        <span class="comment">// dom 插入节点</span></div><div class="line">        root.insertBefore(frag, placeholder)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段为列表渲染逻辑，遍历新的数据items中的每一下 item。在原始数据 oldItems 中去查找(oldItems.indexOf(itemId))，是否存在 item 项。如果不存在，则标记 isNews 为 true。之后走到 if 的 mustCreaete 为 true 的分支，去创建一个新的 tag(将 li 节点看成是一个tag)。以此类推，当全部创建完毕后，删除旧的节点(unmountRedundant(items, tags))。在断点下，可以清楚看到节点的变化情况：   </p>
<img src="/2017/10/18/riot-js源码解析2/d.gif" alt="d.gif" title="">    
<h2 id="优化手段"><a href="#优化手段" class="headerlink" title="优化手段"></a>优化手段</h2><p>综上所述，riot.js 的更新逻辑仅仅是判断新旧数据项是否为同一对象。为此，为了减少 DOM 的变动，降低渲染逻辑。我们修改<code>handleClick</code>函数：   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">handleClick() &#123;</div><div class="line">    <span class="keyword">this</span>.items.push(&#123;<span class="string">"name"</span>: <span class="string">"hy"</span>, <span class="attr">age</span>: <span class="number">22</span>&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样输出结果就会和 vue 的保持一致，并没有创建新的 tag，而是利用了已经存在的内容。源码中，这种情况下 isNews 为 false，从而避开了 创建标签。而仅仅是通过 <code>tags.splice(i, 0, tags.splice(pos, 1)[0]);</code> 来移动位置，<code>if (!mustCreate) { tag.update(item); }</code> 更新节点内容。<br>保证数据项对象地址不变，仅仅是修改上面的不可变对象的值，将大大的提高 riot.js 的渲染效率。     </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 更新第一个li内容  </span></div><div class="line"></div><div class="line"><span class="comment">// 不推荐写法，对象发生变化；</span></div><div class="line"><span class="keyword">this</span>.items[<span class="number">0</span>] = &#123;<span class="string">"name"</span>: <span class="string">"hy"</span>, <span class="attr">age</span>: <span class="number">23</span>&#125;;   </div><div class="line"></div><div class="line"><span class="comment">// 推荐写法，仅仅是修改对象中的值</span></div><div class="line"><span class="keyword">this</span>.items[<span class="number">0</span>].name = <span class="string">"hy"</span>;</div><div class="line"><span class="keyword">this</span>.items[<span class="number">0</span>].age = <span class="number">22</span>;</div></pre></td></tr></table></figure>
<h2 id="数据处理插件"><a href="#数据处理插件" class="headerlink" title="数据处理插件"></a>数据处理插件</h2><p>实际阶段，我们就需要有一个插件，能够帮我们在处理数据项变动的时候，尽量保证大部分数据项地址不发生变化，从而提高 riot 的渲染性能。曾经考虑过使用 Immutable.js 来处理，但是需要修改 riot.js 代码才能实现。所以觉得自己弄个，开发中….  </p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://techblog.toutiao.com/2016/12/13/riotjs/" target="_blank" rel="external">头条PC站基于RIOT的组件化开发实践</a>  </li>
<li><a href="http://imweb.io/topic/573e766f1156025b1dce9404" target="_blank" rel="external">深入探讨前端UI框架</a>  </li>
<li><a href="https://gist.github.com/teabyii/7f6bddf5934915081c5d" target="_blank" rel="external">Riot 源码阅读笔记</a>  </li>
<li><a href="https://github.com/riot/riot/blob/7fe907d161731568c4d7755ab05493ddec12c6fd/lib/browser/tag" target="_blank" rel="external">Riot.js 源代码</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" target="_blank" rel="external">MVC，MVP 和 MVVM 的图示</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;riot-组件&quot;&gt;&lt;a href=&quot;#riot-组件&quot; class=&quot;headerlink&quot; title=&quot;riot 组件&quot;&gt;&lt;/a&gt;riot 组件&lt;/h1&gt;&lt;p&gt;使用 riot 编写组件是以 .tag 后缀结尾的文件，我们的 html, css, js 都可以放在里面。这些文件在编译阶段会被编译成对应的js代码(见&lt;a href=&quot;&quot;&gt;Riot.js 源码解析 【一】 基础内容&lt;/a&gt;)。每个组件都是一个 Tag 对象(代码在 /tag/tag.js 里面)，里面包含了对象的各种属性和方法。本文主要介绍，riot 组件的生命周期，更新原理(一个粗粒度的 virtual dom)以及简单更新优化手段。&lt;br&gt;
    
    </summary>
    
      <category term="前端源码解析" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="前端源码解析" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Riot.js" scheme="http://yoursite.com/tags/Riot-js/"/>
    
  </entry>
  
  <entry>
    <title>Riot.js 源码解析 【一】 基础内容</title>
    <link href="http://yoursite.com/2017/09/21/riot-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%901/"/>
    <id>http://yoursite.com/2017/09/21/riot-js-源码解析1/</id>
    <published>2017-09-21T14:36:37.000Z</published>
    <updated>2017-10-18T07:14:27.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Simple and elegant component-based UI library (Riot.js)    </p>
</blockquote>
<p>riot.js 是一个简单优雅的 js UI框架。具有自定义标签，简单语法，API简单，体积小，学习成本低等特点。riot.js 使用Model-View-Presenter (MVP)设计模式来组织代码，这样它能够更模块化、更具可测试性且易于理解。riot.js 仅仅提供了帮助UI渲染相关的基础功能，并不具备其它复杂的功能，因此其体积很小，压缩后仅有 10.39KB (react.min.js 大约 47.6KB )，很适合组件类的业务开发。<br>目前今日头条PC站，百度Hi的JS组件部分都是基于riot.js来开发的。<br>本系列文章，将会在介绍 riot.js 的使用方法的同时，解析其对应的源码内容，riot.js 版本为3.6.1。<br><a id="more"></a></p>
<h1 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h1><p>来一个简单的例子，基于 webpack 构建，依赖 riotjs-loader。<br>自定义标签代码，content-demo.tag   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> riot <span class="keyword">from</span> <span class="string">'riot'</span>;</div><div class="line">&lt;content-demo&gt; </div><div class="line">    &lt;style&gt;</div><div class="line">        h1 &#123;</div><div class="line">            color: pink;</div><div class="line">        &#125;</div><div class="line">    &lt;<span class="regexp">/style&gt;</span></div><div class="line"><span class="regexp">    &lt;h1&gt;&#123; message &#125;&lt;/</span>h1&gt;</div><div class="line">    &lt;ul&gt;</div><div class="line">        &lt;li each=&#123; lists &#125;&gt;&#123; name &#125;&lt;<span class="regexp">/li&gt;</span></div><div class="line"><span class="regexp">        &lt;script&gt;</span></div><div class="line"><span class="regexp">            this.message = 'hello world';</span></div><div class="line"><span class="regexp">            this.lists = [</span></div><div class="line"><span class="regexp">                &#123;</span></div><div class="line"><span class="regexp">                    'name': 'caelumtian'</span></div><div class="line"><span class="regexp">                &#125;,</span></div><div class="line"><span class="regexp">                &#123;</span></div><div class="line"><span class="regexp">                    'name': 'hyang'</span></div><div class="line"><span class="regexp">                &#125;</span></div><div class="line"><span class="regexp">            ]</span></div><div class="line"><span class="regexp">        &lt;/</span>script&gt;</div><div class="line">    &lt;<span class="regexp">/ul&gt;</span></div><div class="line"><span class="regexp">&lt;/</span>content-demo&gt;</div></pre></td></tr></table></figure>
<p>html 页面代码如下：  </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">content-demo</span>&gt;</span><span class="tag">&lt;/<span class="name">content-demo</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./dist/bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure>
<p>webpack 入口js文件    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> riot <span class="keyword">from</span> <span class="string">'riot'</span>;</div><div class="line"><span class="keyword">import</span> <span class="string">'./tags/content-demo.tag'</span>;</div><div class="line">riot.mount(<span class="string">'*'</span>);</div></pre></td></tr></table></figure>
<p>总体来说，riot.js 采用自定义标签的方式来书写UI组件，组件的生命周期仅有 update,updated,mount,unmount 四个。我们通过调用 riot.mount() 函数来决定页面加载哪些组件。  </p>
<h1 id="riot-js-运行流程"><a href="#riot-js-运行流程" class="headerlink" title="riot.js 运行流程"></a>riot.js 运行流程</h1><p>在上述 demo 中，我们将 <code>&lt;content-demo&gt;</code> 自定义标签写在了 *.tag 格式的文件中，作为一个组件。然后 webpack 打包时会利用 riot-compiler(官方编译工具)，将其编译成 js 代码 riot.tag2()，然后将其内容注册在<code>__TAG_IMPL</code>变量中。 最后用户调用 <code>riot.mount()</code> 函数来指定渲染哪个组件。运行流程，如下图所示：    </p>
<img src="/2017/09/21/riot-js-源码解析1/a.png" alt="a.png" title="">  
<h2 id="自定义标签命名"><a href="#自定义标签命名" class="headerlink" title="自定义标签命名"></a>自定义标签命名</h2><p>riot.js 对自定义标签的书写本身没有任何要求，但是 HTML5 引入了对自定义元素的标准 - <a href="https://w3c.github.io/webcomponents/spec/custom/#custom-elements" target="_blank" rel="external">Custom Elements 标准</a>。标准中对自定义元素名称有了限制：  </p>
<blockquote>
<p>“自定义元素的名字必须包含一个破折号（-）所以 <code>&lt;x-tags&gt;</code>、<code>&lt;my-element&gt;</code>和<code>&lt;my-awesome-app&gt;</code>都是正确的名字，而<tabs>和<foo_bar>是不正确的。这样的限制使得 HTML 解析器可以分辨那些是标准元素，哪些是自定义元素。”   </foo_bar></tabs></p>
</blockquote>
<p>距离来说，如果你的标签名称不带有破折号，那么浏览器会认为自定义元素是 <code>HTMLUnKnownElement</code>，如图所示：  </p>
<img src="/2017/09/21/riot-js-源码解析1/b.png" alt="b.png" title="">    
<p>所以，这里推荐在使用 riot.js 自定义标签的时候，遵守带有破折号的命名方式。  </p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>编译阶段的主要工作就是将riot语法写的<code>.tag</code>文件转换为可执行的.js文件，这部分主要靠编译器来完成。例子中，content-demo 最终会被编译成如下js代码：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">riot.tag2(<span class="string">'content-demo'</span>, <span class="string">'&lt;h1&gt;&#123;message&#125;&lt;/h1&gt; &lt;ul&gt; &lt;li each="&#123;lists&#125;"&gt;&#123;name&#125;&lt;/li&gt; &lt;/ul&gt;'</span>, <span class="string">'content-demo h1,[data-is="content-demo"] h1&#123; color: pink; &#125;'</span>, <span class="string">''</span>, <span class="function"><span class="keyword">function</span> (<span class="params">opts</span>) </span>&#123;</div><div class="line">	<span class="keyword">this</span>.message = <span class="string">'hello world'</span>;</div><div class="line">	<span class="keyword">this</span>.lists = [&#123;</div><div class="line">	    <span class="string">'name'</span>: <span class="string">'caelumtian'</span></div><div class="line">	&#125;, &#123;</div><div class="line">	    <span class="string">'name'</span>: <span class="string">'hyang'</span></div><div class="line">	&#125;];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>riot.tag2 函数在 riot.js 源码中的 core.js 文件中，代码如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">tag2</span>(<span class="params">name, tmpl, css, attrs, fn</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (css) styleManager.add(css, name)</div><div class="line">    <span class="comment">// tags implementation cache 标签接口缓存</span></div><div class="line">    __TAG_IMPL[name] = &#123;</div><div class="line">        name,</div><div class="line">        tmpl,</div><div class="line">        attrs,</div><div class="line">        fn</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> name</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参数含义如下：  </p>
<ul>
<li>name: riot 自定义标签的名称</li>
<li>tmpl: 标签的html内容</li>
<li>css: <code>&lt;style&gt;</code> 标签中的内容</li>
<li>attrs: riot 自定义标签的属性</li>
<li>fn: 用户自定义函数,即 <code>&lt;script&gt;</code> 标签中的内容  </li>
</ul>
<p><code>riot.tag2()</code> 函数将 riot tag 注册到了 <code>__TAG_IMP</code> 对象中，方便之后的使用，css部分则被添加到了 <code>byName</code> 变量中，用于之后统一添加到页面中。在源代码中，还有一个 <code>riot.tag()</code>函数，这个函数用于直接直接创建一个 riot tag 实例的接口，而 <code>riot.tag2()</code> 是暴露给编辑器的接口，本质上功能是一样的。</p>
<h2 id="加载-riot-mount"><a href="#加载-riot-mount" class="headerlink" title="加载 riot.mount()"></a>加载 riot.mount()</h2><p>组件被注册号以后，并没有被渲染，直到我们调用 <code>riot.mount()</code> 函数后，相应的组件才会渲染到页面上。riot.mount 主要用法如下：  </p>
<ul>
<li>riot.mount(‘*’, [opts]): 将注册好的所有 riot tag 都渲染到页面上</li>
<li>riot.mount(customTagSelector, [opts]): 根据标签选择器，渲染指定的 riot tag。 例如：上述示例中，我们也可以这样写 riot.mount(‘content-demo’)。  </li>
<li>riot.mount(selector, tagName, [opts]): 将 riot tag 渲染到指定的节点中。例如： riot.mount(“div#main”, “content-demo”, api)   将 <code>&lt;my-tag&gt;</code>挂载到 <code>div#main</code> 内。  </li>
</ul>
<p>这里面的 opts 为可选参数，是用户设置的标签的其他属性内容。这里就不过多介绍了，之后的文章会有解释。下面为 riot.mount 注释过的源码：      </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params">selector, tagName, opts</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> tags = []</div><div class="line">    <span class="keyword">let</span> elem, allTags</div><div class="line">    <span class="comment">// root &#123;HTMLElement&#125; riot-tag 标签节点</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">pushTagsTo</span>(<span class="params">root</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root.tagName) &#123;</div><div class="line">            <span class="keyword">let</span> riotTag = getAttr(root, IS_DIRECTIVE),    <span class="comment">// 要么 data-is 要么 root.tagName 本身</span></div><div class="line">                tag</div><div class="line">            <span class="comment">// ① 设置 data-is 属性指向</span></div><div class="line">            <span class="keyword">if</span> (tagName &amp;&amp; riotTag !== tagName) &#123;</div><div class="line">                riotTag = tagName</div><div class="line">                setAttr(root, IS_DIRECTIVE, tagName)</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// ② mountTo 创建一个新的 riot tag 实例</span></div><div class="line">            tag = mountTo(root, riotTag || root.tagName.toLowerCase(), opts)</div><div class="line">            <span class="keyword">if</span> (tag)</div><div class="line">                tags.push(tag)</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.length)</div><div class="line">            each(root, pushTagsTo)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// DOM 注入 style 标签</span></div><div class="line">    styleManager.inject()</div><div class="line">    <span class="keyword">if</span> (isObject(tagName)) &#123;</div><div class="line">        opts = tagName</div><div class="line">        tagName = <span class="number">0</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (isString(selector)) &#123;</div><div class="line">        selector = selector === <span class="string">'*'</span> ?</div><div class="line">            allTags = selectTags() :</div><div class="line">            selector + selectTags(selector.split(<span class="regexp">/, */</span>))</div><div class="line">        <span class="comment">// ③ 利用 $$ 来判断 这些 tag 是否已经挂载在 html 上面</span></div><div class="line">        elem = selector ? $$(selector) : []</div><div class="line">    &#125; <span class="keyword">else</span></div><div class="line">        elem = selector</div><div class="line">    <span class="comment">// 将所有元素挂载在根元素中</span></div><div class="line">    <span class="keyword">if</span> (tagName === <span class="string">'*'</span>) &#123;</div><div class="line">        tagName = allTags || selectTags()</div><div class="line">        <span class="keyword">if</span> (elem.tagName)</div><div class="line">            <span class="comment">// 查找elem下的 tagName</span></div><div class="line">            elem = $$(tagName, elem)</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 将查找到的所有节点都 放入 nodeList中</span></div><div class="line">            <span class="keyword">var</span> nodeList = []</div><div class="line">            each(elem, _el =&gt; nodeList.push($$(tagName, _el)))</div><div class="line">            elem = nodeList</div><div class="line">        &#125;</div><div class="line">        tagName = <span class="number">0</span></div><div class="line">    &#125;</div><div class="line">    pushTagsTo(elem)</div><div class="line">    <span class="keyword">return</span> tags</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当调用 riot.mount 后，通过 selector 参数来查找 html 页面上对应的节点。<code>不在 html 上的节点是不会被渲染的</code>。③处代码为查找过程，其中$$为 <code>document.querySelectAll</code>。之后调用 pushTagsTo 函数来渲染 riot tag。<br><code>IS_DIRECTIVE = &#39;data-is&#39;</code> 渲染前，要检查是否含有 tagName 参数，如果有的话即为 上述 riot.mount 的第三个用法。此时需要检测 root 的 data-is 属性值是否和 tagName 相等，如①处。不相等则将 root 设置其 data-is 为 tagName。即 riot.mount(‘div#main’, ‘content-demo’) 渲染出的节点为 :  </p>
<blockquote>
<p><code>&lt;div id=&quot;main&quot; data-is=&quot;content-demo&quot;&gt;&lt;content-demo&gt;...&lt;/content-demo&gt;&lt;/div&gt;</code> </p>
</blockquote>
<p>最后，通过 mountTo 函数渲染处理好的 riot tag，如②处。mountTo 函数后续会有详解。  </p>
<blockquote>
<p>代码中使用了 tagName 而不是 nodeName 原因如下：nodeName是node 接口上的property，而tagName是element 接口上的property，所有的节点（元素节点，属性节点，文本节点等12种）都继承了node接口，而只有元素节点才继承了element节点。  </p>
</blockquote>
<h2 id="取消注册-riot-unregister"><a href="#取消注册-riot-unregister" class="headerlink" title="取消注册 riot.unregister()"></a>取消注册 riot.unregister()</h2><p>riot 全局变量上还包含 riot.unregister(name) 函数用户取消注册过的内容，通常我们在测试程序的时候，创建同名标签使用。示例如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个测试标签</span></div><div class="line">riot.tag(<span class="string">'test-tag'</span>, <span class="string">'&lt;p&gt;&#123; message &#125;&lt;/p&gt;'</span>)</div><div class="line"><span class="comment">// 注册标签</span></div><div class="line"><span class="keyword">var</span> tag = riot.mount(<span class="built_in">document</span>.createElement(<span class="string">'div'</span>), <span class="string">'test-tag'</span>)[<span class="number">0</span>]</div><div class="line">expect(tag.root.querySelector(<span class="string">'p'</span>)).to.be.ok</div><div class="line"><span class="comment">// 取消注册</span></div><div class="line">riot.unregister(<span class="string">'test-tag'</span>)</div><div class="line"><span class="comment">// 重新创建一个同名，但是不一样的标签</span></div><div class="line">riot.tag(<span class="string">'test-tag'</span>, <span class="string">'&lt;div&gt;&#123; message &#125;&lt;/div&gt;'</span>)</div></pre></td></tr></table></figure>
<p>riot.unregister() 源码十分简单，如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">unregister</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    __TAG_IMPL[name] = <span class="literal">null</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>暴露在 riot 全局变量上的函数，还包括 <code>riot.update</code> 和 <code>riot.mixin</code> 两个，将在后面的内容介绍。  </p>
<h1 id="源码目录结构"><a href="#源码目录结构" class="headerlink" title="源码目录结构"></a>源码目录结构</h1><p>riot 3.6.1 的源码目录结构如下：</p>
<pre><code>|____browser
| |____common
| | |____global-variables.js // 使用到的常量
| | |____util                    
| | | |____check.js   // 变量类型，属性等检查
| | | |____dom.js     // dom 操作
| | | |____misc.js    // 用到的工具类函数
| | | |____tags.js    // riot tag 操作      
| |____compiler
| | |____index.js     // riot tag 模板解析
| |____tag
| | |____core.js      // riot 对外暴露函数接口
| | |____each.js      // riot tag each操作渲染
| | |____if.js        // riot tag if操作渲染
| | |____mkdom.js     // 创建 dom 节点
| | |____parse.js     // riot tag 解析
| | |____ref.js       // riot tag ref
| | |____setEventHandler.js  // riot tag 事件绑定
| | |____styleManager.js     // 样式管理
| | |____tag.js              // riot tag 标签类
|___|____update.js           // riot tag 更新操作
</code></pre><p>本文涉及到的源码，主要出自 <code>core.js</code> 和 <code>styleManager.js</code>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Simple and elegant component-based UI library (Riot.js)    &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;riot.js 是一个简单优雅的 js UI框架。具有自定义标签，简单语法，API简单，体积小，学习成本低等特点。riot.js 使用Model-View-Presenter (MVP)设计模式来组织代码，这样它能够更模块化、更具可测试性且易于理解。riot.js 仅仅提供了帮助UI渲染相关的基础功能，并不具备其它复杂的功能，因此其体积很小，压缩后仅有 10.39KB (react.min.js 大约 47.6KB )，很适合组件类的业务开发。&lt;br&gt;目前今日头条PC站，百度Hi的JS组件部分都是基于riot.js来开发的。&lt;br&gt;本系列文章，将会在介绍 riot.js 的使用方法的同时，解析其对应的源码内容，riot.js 版本为3.6.1。&lt;br&gt;
    
    </summary>
    
      <category term="前端源码解析" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="前端源码解析" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Riot.js" scheme="http://yoursite.com/tags/Riot-js/"/>
    
  </entry>
  
  <entry>
    <title>js增量更新算法研究</title>
    <link href="http://yoursite.com/2017/09/18/js%E5%A2%9E%E9%87%8F%E6%9B%B4%E6%96%B0%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6/"/>
    <id>http://yoursite.com/2017/09/18/js增量更新算法研究/</id>
    <published>2017-09-18T03:42:55.000Z</published>
    <updated>2017-09-28T08:21:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="serviceWorker-方案-js增量更新算法研究"><a href="#serviceWorker-方案-js增量更新算法研究" class="headerlink" title="serviceWorker 方案 - js增量更新算法研究"></a>serviceWorker 方案 - js增量更新算法研究</h1><h2 id="调研背景"><a href="#调研背景" class="headerlink" title="调研背景"></a>调研背景</h2><blockquote>
<p>根据之前 serviceWorker 的调研，当服务端文件更新后，serviceWorker 会做对比，并请求这些新的文件。所有发生变化的文件都会被更新。现在 new-mini 内嵌页面，js 都被压缩成了一个文件。这样每次很小的文件改动，都会导致客户端需要下载整个js文件，这样会造成流量的浪费，同时也对服务器造成过大的流量压力。为此我们需要减少更新文件的体积，来更好的完成 serviceWorker 的架构。  </p>
</blockquote>
<a id="more"></a>
<h2 id="js-增量更新算法"><a href="#js-增量更新算法" class="headerlink" title="js 增量更新算法"></a>js 增量更新算法</h2><p>利用增量更新算法，我们大大的降低每次文件变动后传输的大小。这里调研了4中常见的js 增量更新算法：  </p>
<h3 id="基于chunk的增量更新算法"><a href="#基于chunk的增量更新算法" class="headerlink" title="基于chunk的增量更新算法"></a>基于chunk的增量更新算法</h3><p>首先将旧的文件分成n块并并编号<br><img src="/2017/09/18/js增量更新算法研究/a.png" alt="a.png" title=""><br>然后在新文件上进行，滚动查找。如果找到匹配的则记录块号，如果没找到则块往前移动 1 个字符，并把上个字符压入新数据块,然后扫描下一块，最终得到一个新数据和数据块号的组合的增量文件（这一步可以用上线 JavaScript 时用的打包工具或者请求 JavaScript 服务器程序实时计算出来）。<br><img src="/2017/09/18/js增量更新算法研究/b.png" alt="b.png" title=""><br>最终得到的增量文件如下所示：  </p>
<blockquote>
<p>1, data1, 2, 3, data2, 4, 5, 6  </p>
</blockquote>
<p>进一步合并顺序快得到：  </p>
<blockquote>
<p>[1, 1], data1, [2, 2], data2, [4, 4]  </p>
</blockquote>
<p>客户端根据旧文件的 chunk 数据和增量更新数据，我们可以得出新版本数据由如下数据组成：  </p>
<blockquote>
<p>chunk0+data1+chunk1+chunk2+data2+chunk3+chunk4+chunk5  </p>
</blockquote>
<p>例如以 s = ‘‘1345678abcdefghijklmnopq’ 修改为 a = ‘‘13456<code>f</code>78abcd<code>2</code>efghijklmnopq’为例, 设块长度为4 则， 源文件分成：<br><br>通过滚动查找，得到新文件<br><br>最终增量文件表示如下数组: [“a=‘1”,2,”f”,3,”cd2ef”,5,6,7]。 进一步合并顺序块，可用一个js数组表示为： [“a=‘1”,[2,1],“f”,[3,1],“cd2ef”,[5,3]。<br>在 serviceWorker 客户端这边，调用如下函数，进行文件更新：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//source 是上一个版本内容，trunkSize 是块大小，checksumcode 是两个版本间的增量文件数组</span></div><div class="line"><span class="keyword">var</span> rsyncjs = <span class="function"><span class="keyword">function</span>(<span class="params">source,trunkSize,checksumcode</span>)</span>&#123;</div><div class="line">   <span class="keyword">var</span> strResult=<span class="string">""</span>;</div><div class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; checksumcode.length; i++)&#123;</div><div class="line">       <span class="keyword">var</span> code = checksumcode[i];</div><div class="line">       <span class="keyword">if</span>(<span class="keyword">typeof</span> code === <span class="string">'string'</span>)&#123;</div><div class="line">            strResult+=code;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">var</span> start = code[<span class="number">0</span>] * trunkSize;</div><div class="line">            <span class="keyword">var</span> len = code[<span class="number">1</span>] * trunkSize;</div><div class="line">            <span class="keyword">var</span> oldcode = source.substr(start, len);</div><div class="line">            strResult += oldcode;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> strResult;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法存在的问题为：增量更新的精确度依赖于chunk的大小，在实际使用中总是会有不少代码需要冗余下载。  </p>
<h3 id="Myer’s-diff-algorithm"><a href="#Myer’s-diff-algorithm" class="headerlink" title="Myer’s diff algorithm"></a>Myer’s diff algorithm</h3><p>Myer’s diff algorithm 首次出是在1986年一篇论文中<a href="https://neil.fraser.name/software/diff_match_patch/myers.pdf" target="_blank" rel="external">“An O(ND) Difference Algorithm and Its Variations”</a>, 在文中实现上介绍了两种此diff算法 的实现。两种实现的核心思想是一致的，只是在具体的实现过程中，为进一步提升算法的性能及空间利用率，采取了不一致的迭代方式。<br>算法原理比较复杂，github 上有根据该算法实现的 <a href="https://github.com/kpdecker/jsdiff" target="_blank" rel="external">jsdiff 插件</a><br>简单的演示如下：   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>(<span class="string">'colors'</span>);</div><div class="line"><span class="keyword">let</span> jsdiff = <span class="built_in">require</span>(<span class="string">'diff'</span>);</div><div class="line"><span class="keyword">let</span> oldStr = <span class="string">'bcdsgaff2 123'</span>;</div><div class="line"><span class="keyword">let</span> newStr = <span class="string">'accdgadff2 42356'</span>;</div><div class="line"><span class="keyword">let</span> diff = jsdiff.diffChars(oldStr, newStr);</div><div class="line"><span class="built_in">console</span>.log(diff);</div><div class="line">diff.forEach(<span class="function"><span class="params">part</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> color = part.added ? <span class="string">'green'</span> : part.removed ? <span class="string">'red'</span> : <span class="string">'gray'</span>;</div><div class="line">    process.stderr.write(part.value[color]); </div><div class="line">&#125;) </div><div class="line"><span class="string">``</span><span class="string">`    </span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">&#123;% asset_img 5.png %&#125;  </span></div><div class="line"><span class="string">可以清楚的看到差异信息，这里我们利用下面这个函数 简化一下jsdiff输出信息，方便传输。    </span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">`</span><span class="string">``</span>javascript  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">minimizeDiffInfo</span>(<span class="params">originalInfo</span>)</span>&#123;</div><div class="line">    <span class="keyword">let</span> result = originalInfo.map(<span class="function"><span class="params">info</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">if</span>(info.added)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">'+'</span> + info.value;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(info.removed)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">'-'</span> + info.count;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> info.count;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(result);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果为：<br><img src="/2017/09/18/js增量更新算法研究/6.png" alt="6.png" title=""><br>客户端，采用如下函数，更新 serviceWorker 中的资源：  </p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">mergeDiff</span>(<span class="params">oldString, diffInfo</span>)</span>{
    <span class="keyword">let</span> newString = <span class="string">''</span>;
    <span class="keyword">let</span> diffInfo = <span class="built_in">JSON</span>.parse(diffInfo);
    <span class="keyword">let</span> index = <span class="number">0</span>;
    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; diffInfo.length; i++){
        <span class="keyword">let</span> info = diffInfo[i];
        <span class="keyword">if</span>(<span class="keyword">typeof</span> info === <span class="string">'number'</span>){
            newString += oldString.slice(index, index + info);
            index += info;
            <span class="keyword">continue</span>;
        }
        <span class="keyword">if</span>(<span class="keyword">typeof</span> info === <span class="string">'string'</span>){
            <span class="keyword">if</span>(info[<span class="number">0</span>] === <span class="string">'+'</span>){
                <span class="keyword">let</span> addedString = info.slice(<span class="number">1</span>, info.length);
                newString += addedString;
            }
            <span class="keyword">if</span>(info[<span class="number">0</span>] === <span class="string">'-'</span>){
                <span class="keyword">let</span> removedCount = <span class="built_in">parseInt</span>(info.slice(<span class="number">1</span>, info.length));
                index += removedCount;
            }
        }
    }
    <span class="keyword">return</span> newString;
}
</code></pre>
<p>该方案，实际测试结果很糟糕，对于文件很大的内容比对时间都够我睡一觉了。    </p>
<h2 id="基于编辑距离的比对算法"><a href="#基于编辑距离的比对算法" class="headerlink" title="基于编辑距离的比对算法"></a>基于编辑距离的比对算法</h2><h3 id="什么是编辑距离"><a href="#什么是编辑距离" class="headerlink" title="什么是编辑距离"></a>什么是编辑距离</h3><blockquote>
<p>编辑距离是针对二个字符串（例如英文字）的差异程度的量化量测，量测方式是看至少需要多少次的处理才能将一个字符串变成另一个字符串。编辑距离可以用在自然语言处理中，例如拼写检查可以根据一个拼错的字和其他正确的字的编辑距离，判断哪一个（或哪几个）是比较可能的字。DNA也可以视为用A、C、G和T组成的字符串，因此编辑距离也用在生物信息学中，判断二个DNA的类似程度。Unix 下的 diff 及 patch 即是利用编辑距离来进行文本编辑对比的例子。  </p>
</blockquote>
<h4 id="求解算法"><a href="#求解算法" class="headerlink" title="求解算法"></a>求解算法</h4><p>比如要计算cafe和coffee的编辑距离。cafe→caffe→coffe→coffee。先创建一个6×8的表（cafe长度为4，coffee长度为6，各加2):<br><img src="/2017/09/18/js增量更新算法研究/8.png" alt="8.png" title=""><br>接着，在如下位置添加数字<br><img src="/2017/09/18/js增量更新算法研究/9.png" alt="9.png" title=""><br>从3,3格开始，开始计算。取以下三个值的最小值：    </p>
<ul>
<li>如果最上方的字符等于最左方的字符，则为左上方的数字。否则为左上方的数字+1。（对于3,3来说为0）</li>
<li>左方数字+1（对于3,3格来说为2）</li>
<li>上方数字+1（对于3,3格来说为2）  </li>
</ul>
<p>因此为格3,3为0:<br><img src="/2017/09/18/js增量更新算法研究/10.png" alt="10.png" title=""><br>循环操作，推出下表：<br><img src="/2017/09/18/js增量更新算法研究/11.png" alt="11.png" title=""><br>取右下角，得编辑距离为3。   </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;serviceWorker-方案-js增量更新算法研究&quot;&gt;&lt;a href=&quot;#serviceWorker-方案-js增量更新算法研究&quot; class=&quot;headerlink&quot; title=&quot;serviceWorker 方案 - js增量更新算法研究&quot;&gt;&lt;/a&gt;serviceWorker 方案 - js增量更新算法研究&lt;/h1&gt;&lt;h2 id=&quot;调研背景&quot;&gt;&lt;a href=&quot;#调研背景&quot; class=&quot;headerlink&quot; title=&quot;调研背景&quot;&gt;&lt;/a&gt;调研背景&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;根据之前 serviceWorker 的调研，当服务端文件更新后，serviceWorker 会做对比，并请求这些新的文件。所有发生变化的文件都会被更新。现在 new-mini 内嵌页面，js 都被压缩成了一个文件。这样每次很小的文件改动，都会导致客户端需要下载整个js文件，这样会造成流量的浪费，同时也对服务器造成过大的流量压力。为此我们需要减少更新文件的体积，来更好的完成 serviceWorker 的架构。  &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[译] 使用Web Speech API和Node.js构建简单的AI Chatbot</title>
    <link href="http://yoursite.com/2017/09/02/%E8%AF%91-%E4%BD%BF%E7%94%A8WebSpeechAPI/"/>
    <id>http://yoursite.com/2017/09/02/译-使用WebSpeechAPI/</id>
    <published>2017-09-02T11:55:05.000Z</published>
    <updated>2017-09-22T07:09:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>随着语音技术的普及，越来越多的手机用户开始使用Siri和Cortana等语音助理软件。Amazon Echo和Google Home等语音软件同样走入了我们的日常生活。这些系统基于语音识别软件构建允许用户直接通过语音下达命令。现在，浏览器也已经支持了Web Speech API，它允许用户在web应用程序中集成语音数据。<br>基于现在的web应用程序，我们可以使用多种UI元素来和用户交互。使用Web Speech API，我们可以开发更加自然地小巧的web可视化界面。这样我们就能开发更丰富的web应用程序。此外，该API也可以帮助身体或认知障碍的人更好的访问web信息。<br><a id="more"></a>   </p>
<blockquote>
<p>增强用户体验<br>Web Speeh API可以使网站和Web app不仅仅可以交谈还可以聆听。这里有一些关于猪呢个条用户体验的很好的例子。<a href="https://www.smashingmagazine.com/2014/12/enhancing-ux-with-the-web-speech-api/" target="_blank" rel="external">阅读更多</a>  </p>
</blockquote>
<p>在本教程中，我们将使用API在浏览器中创建人工智能（AI）语音聊天界面。该应用将听取用户的声音并以合成语音回复。因为Web Speech API依然是实现性的，所以目前仅能支持在有限的浏览器中。本文使用的语音识别和语音合成功能目前仅基于Chromium浏览器，包括Chrome 25+和Opera 27+，而Firefox，Edge和Safari目前仅支持语音合成。    </p>
<img src="/2017/09/02/译-使用WebSpeechAPI/1.png" alt="1.png" title="">  
<img src="/2017/09/02/译-使用WebSpeechAPI/2.png" alt="2.png" title="">  
<p>要构建该程序，我们主要采取三个步骤：    </p>
<ol>
<li>使用Web Speech API的SpeechRecognition接口来聆听用户的语音  </li>
<li>将用户消息作为字符串文本发送给商业的自然语言处理API</li>
<li>一旦API.AI返回响应文本，我们就利用SpeechSynthesis接口返回给用户一个合成声音    </li>
</ol>
<img src="/2017/09/02/译-使用WebSpeechAPI/3.png" alt="3.png" title="">
<p>本教程使用的<a href="https://github.com/girliemac/web-speech-ai" target="_blank" rel="external">完整的源代码</a>在GitHub上。  </p>
<h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><p>本教程依赖于Node.js,你需要对JavaScript和Node.js有一定的了解并确保您的电脑上已经安装了Noded.js。  </p>
<h2 id="构建你的Node-js应用"><a href="#构建你的Node-js应用" class="headerlink" title="构建你的Node.js应用"></a>构建你的Node.js应用</h2><p>首先，让我们搭建一个Node.js的应用框架。创建你的应用目录，并设置如下的目录结构：   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">├── index.js</div><div class="line">├── public</div><div class="line">│   ├── css</div><div class="line">│   │   └── style.css</div><div class="line">│   └── js</div><div class="line">│       └── script.js</div><div class="line">└── views</div><div class="line">    └── index.html</div></pre></td></tr></table></figure>
<p>之后利用如下命令来初始化你的Node.js应用：  </p>
<blockquote>
<p>npm init -f    </p>
</blockquote>
<p>我们将使用Express(一个Node.js Web应用框架)来搭建本地服务。为了实现服务器和浏览器之间的双向通信，我们将使用Socket.IO。同时，我们还将使用自然语言处理工具API.AI，来构建可以人工交谈的AI聊天工具。<br>Socket.IO，能够让我们更方便的使用WebSocket。通过在客户端和服务端建立socket连接。当Web Speech API或API.AI 返回文本数据的时候，我们能将聊天信息在浏览器和服务器之间传递。<br>首先，我们创建index.js文件并实例化Express作为服务器：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</div><div class="line"><span class="keyword">const</span> app = express();</div><div class="line"></div><div class="line">app.use(express.static(__dirname + <span class="string">'/views'</span>)); <span class="comment">// html</span></div><div class="line">app.use(express.static(__dirname + <span class="string">'/public'</span>)); <span class="comment">// js, css, images</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> server = app.listen(<span class="number">5000</span>);</div><div class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</div><div class="line">  res.sendFile(<span class="string">'index.html'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>下一步，我们将Web Speech API集成到前端代码。  </p>
<h2 id="利用-SpeechRecognition-接口接收语音"><a href="#利用-SpeechRecognition-接口接收语音" class="headerlink" title="利用 SpeechRecognition 接口接收语音"></a>利用 SpeechRecognition 接口接收语音</h2><p>Web Speech API具有名为SpeechRecognition的接口，用来从麦克风中获取用户们的讲话并了解他们在说什么。 </p>
<h3 id="创建用户界面"><a href="#创建用户界面" class="headerlink" title="创建用户界面"></a>创建用户界面</h3><p>该程序的UI界面很简单，仅有一个按钮来触发语音识别。让我们创建一个index.html文件，其中包含js文件和Socket.IO，稍后我们将用它启动实时通讯：  </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span>…<span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    …</div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.0.1/socket.io.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/script.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>然后，在页面中加入按钮接口：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>Talk<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div></pre></td></tr></table></figure>
<p>要想查看按钮的样式，你何以查看<a href="https://github.com/girliemac/web-speech-ai" target="_blank" rel="external">源代码</a>中的style.css文件。  </p>
<h3 id="使用JavaScript捕获语音"><a href="#使用JavaScript捕获语音" class="headerlink" title="使用JavaScript捕获语音"></a>使用JavaScript捕获语音</h3><p>在script.js中，创建SpeechRecognition实例来识别语音： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> SpeechRecognition = <span class="built_in">window</span>.SpeechRecognition || <span class="built_in">window</span>.webkitSpeechRecognition;</div><div class="line"><span class="keyword">const</span> recognition = <span class="keyword">new</span> SpeechRecognition();</div></pre></td></tr></table></figure>
<p>我们使用了带有前缀和不带的两个对象做判断，因为Chrome当前支持带有前缀的API。<br>同时，我们在本教程中使用了一些ES6语法，包括const，箭头函数等等，他们都可以在支持语音接口的浏览器中使用。<br>你可以设置各种属性，来自定义语音识别：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">recognition.lang = <span class="string">'en-US'</span>;</div><div class="line">recognition.interimResults = <span class="literal">false</span>;</div></pre></td></tr></table></figure>
<p>之后，监听button UI的DOM节点的点击事件来启动语音识别：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.querySelector(<span class="string">'button'</span>).addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</div><div class="line">    recognition.start();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>一旦语音开始，我们就调用result事件，来获取语音文本：   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">recognition.addEventListener(<span class="string">'result'</span>, (e) =&gt; &#123;</div><div class="line">  <span class="keyword">let</span> last = e.results.length - <span class="number">1</span>;</div><div class="line">  <span class="keyword">let</span> text = e.results[last][<span class="number">0</span>].transcript;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Confidence: '</span> + e.results[<span class="number">0</span>][<span class="number">0</span>].confidence);</div><div class="line">  <span class="comment">// We will use the Socket.IO here later…</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这将返回一个包含结果的SpeechRecognitionResultList兑现，你可以在数组中检索文字信息。接下来我们使用Socket.IO来传递数据额给我们的服务器。</p>
<h2 id="Socket-IO做实时通讯"><a href="#Socket-IO做实时通讯" class="headerlink" title="Socket.IO做实时通讯"></a>Socket.IO做实时通讯</h2><p>Socket.IO是一个做实时通讯web应用的库。他可以实现web客户端和服务端之间的双向通讯。我们将使用它将语音结果传递给Node.js，将相应信息传回浏览器。<br>你也许会有疑虑为什么我们不使用简单的HTTP协议或者AJAX。你可以发送POST请求来传奇数据。但是我们通过Socket.IO来创建webscoket，是因为这是最好的实现双向通讯的解决方案。特别是服务器向浏览器发送数据，如果采用AJAX来实现我们就不得不再用轮训的方式： </p>
<img src="/2017/09/02/译-使用WebSpeechAPI/4.png" alt="4.png" title=""> 
<p>在script.js中实例化Socket.IO：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> socket = io();</div></pre></td></tr></table></figure>
<p>然后将下面这段代码加入到监听reuslt事件的回调函数中：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">socket.emit(<span class="string">'chat message'</span>, text);</div></pre></td></tr></table></figure>
<p>我们回到Node.js代码中，来接受这些文本并使用API来回复用户的消息。  </p>
<h2 id="从AI中获取回复"><a href="#从AI中获取回复" class="headerlink" title="从AI中获取回复"></a>从AI中获取回复</h2><p>许多平台提供的服务可以将带有自然语言处理的AI系统结合到项目中，包括IBM的Watson，微软的LUIS和Wit.ai。为了快速构建一个会话接口，我们使用API.AI。因为它提供了免费的开发者帐户，并允许我们使用其Web界面和Node.js库快速设置一个小型的系统。  </p>
<h3 id="设置API-AI"><a href="#设置API-AI" class="headerlink" title="设置API.AI"></a>设置API.AI</h3><p>首先创建一个账户和代理。更多内容可以参考<a href="https://docs.api.ai/docs/get-started" target="_blank" rel="external">入门指南</a>中的第一步。<br>然后，创建entities和intents。点击左侧菜单中的”Small Talk”，然后切换开关即可开启服务。  </p>
<img src="/2017/09/02/译-使用WebSpeechAPI/5.png" alt="5.png" title="">
<p>根据你的喜好，自定义API.AI接口的代理。  </p>
<h3 id="使用API-AI的Node-js-SDK"><a href="#使用API-AI的Node-js-SDK" class="headerlink" title="使用API.AI的Node.js SDK"></a>使用API.AI的Node.js SDK</h3><p>我们利用Node.js SDK来链接Node.js应用和API.AI。回到你的index.js文件中，利用你的access token来初始化API.AI：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> apiai = <span class="built_in">require</span>(<span class="string">'apiai'</span>)(APIAI_TOKEN);</div></pre></td></tr></table></figure>
<p>如果您只想在本地运行代码，可以在此处对API密钥进行编码。这里有多种方式来设置环境变量，我通常使用设置 .env 文件来包含变量信息。在GitHub源码中，我将包含凭证的信息文件添加到了.gitignroe中，你可以查看 <a href="https://github.com/girliemac/web-speech-ai/blob/master/.env_test" target="_blank" rel="external">.env-test</a> 文件来查看他是如何设置的。  </p>
<p>现在我么能使用服务端的Socket.IO来获取浏览器的结果。<br>一旦接收到消息，我们就用API.AI的API来检索并回复用户信息：    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">io.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">socket</span>) </span>&#123;</div><div class="line">    socket.on(<span class="string">'chat message'</span>, (text) =&gt; &#123;</div><div class="line">        <span class="comment">// Get a reply from API.AI</span></div><div class="line">        <span class="keyword">let</span> apiaiReq = apiai.textRequest(text, &#123;</div><div class="line">            sessionId: APIAI_SESSION_ID</div><div class="line">        &#125;);</div><div class="line">        apiaiReq.on(<span class="string">'response'</span>, (response) =&gt; &#123;</div><div class="line">            <span class="keyword">let</span> aiText = response.result.fulfillment.speech;</div><div class="line">            socket.emit(<span class="string">'bot reply'</span>, aiText); <span class="comment">// Send the result back to the browser!</span></div><div class="line">        &#125;);</div><div class="line">        apiaiReq.on(<span class="string">'error'</span>, (error) =&gt; &#123;</div><div class="line">            <span class="built_in">console</span>.log(error);</div><div class="line">        &#125;);</div><div class="line">        apiaiReq.end();</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>当API.AI返回结果时，使用Socket.IO socket.emit()将其发送回浏览器。  </p>
<h2 id="利用SpeechSynthesis接口来合成语音"><a href="#利用SpeechSynthesis接口来合成语音" class="headerlink" title="利用SpeechSynthesis接口来合成语音"></a>利用SpeechSynthesis接口来合成语音</h2><p>然我们再次回到script.js中，完成我们的应用！<br>创建一个语音合成器，这次我们使用SpeechSynthesis接口。该函数将接受字符串作为参数，并使浏览器能够说出文本：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">synthVoice</span>(<span class="params">text</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> synth = <span class="built_in">window</span>.speechSynthesis;</div><div class="line">    <span class="keyword">const</span> utterance = <span class="keyword">new</span> SpeechSynthesisUtterance();</div><div class="line">    utterance.text = text;</div><div class="line">    synth.speak(utterance);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该函数中，我们首先创建了一个API入口对象，window.speechSynthesis。这次我们没有在使用前缀，该API的支持度更高，许多浏览器已经移除了该前缀。<br>然后，我们创建一个SpeechSynthesisUtterance实例，并设置要合成语音的文本。你也可以设置其他属性，例如voice类型和操作系统支持的语音类型。<br>最后，我们使用SpeechSynthesis.speak()来是浏览器说话。现在，再次从Socket.IO获取服务器的响应。一旦接收到消息，请调用该功能。    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">socket.on(<span class="string">'bot reply'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">replyText</span>) </span>&#123;</div><div class="line">  synthVoice(replyText);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>至此我们完成了全部功能，你可以试试:  </p>
<img src="/2017/09/02/译-使用WebSpeechAPI/6.gif" alt="6.gif" title="">
<p>请注意，浏览器在首次的时候会询问你是否使用麦克风。像其他Web API（如Geolocation API和Notification API）一样，除非你授予它，否则浏览器将永远不会访问您的敏感信息，因此你的声音不会在不知情的情况下被秘密记录。<br>API.AI是可配置和可训练的。阅读API.AI文档，使其更加智能。   </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>本教程仅涵盖了API的核心功能，但该API实际上是非常灵活和可自定义的。您可以改变识别语言，合成语音，包括口音（如美国或英国英语），语音音调和语速。你可以在这里了解有关API的更多信息：   </p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Speech_API" target="_blank" rel="external">Web Speech API</a> Mozilla Developer Network</li>
<li><a href="https://dvcs.w3.org/hg/speech-api/raw-file/tip/speechapi.html" target="_blank" rel="external">Web Speech API Specification</a> W3C</li>
<li><a href="https://docs.microsoft.com/en-us/microsoft-edge/dev-guide/multimedia/web-speech-api" target="_blank" rel="external">Web Speech API: Speech Synthesis</a> (Microsoft Edge documentation) Microsoft  </li>
</ul>
<p>自然语言处理工具你可以参考如下：  </p>
<ul>
<li><a href="https://api.ai/" target="_blank" rel="external">API.AI</a> Google</li>
<li><a href="https://wit.ai/" target="_blank" rel="external">Wit.ai</a> Facebook</li>
<li><a href="https://www.luis.ai/" target="_blank" rel="external">LUIS</a> Microsoft</li>
<li><a href="https://www.ibm.com/watson/" target="_blank" rel="external">Watson</a> IBM</li>
<li><a href="https://aws.amazon.com/cn/lex/" target="_blank" rel="external">Lex</a> Amazon</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着语音技术的普及，越来越多的手机用户开始使用Siri和Cortana等语音助理软件。Amazon Echo和Google Home等语音软件同样走入了我们的日常生活。这些系统基于语音识别软件构建允许用户直接通过语音下达命令。现在，浏览器也已经支持了Web Speech API，它允许用户在web应用程序中集成语音数据。&lt;br&gt;基于现在的web应用程序，我们可以使用多种UI元素来和用户交互。使用Web Speech API，我们可以开发更加自然地小巧的web可视化界面。这样我们就能开发更丰富的web应用程序。此外，该API也可以帮助身体或认知障碍的人更好的访问web信息。&lt;br&gt;
    
    </summary>
    
      <category term="翻译文章" scheme="http://yoursite.com/categories/%E7%BF%BB%E8%AF%91%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>图片惰性加载 IntersectionObserver</title>
    <link href="http://yoursite.com/2017/08/28/%E5%9B%BE%E7%89%87%E6%83%B0%E6%80%A7%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2017/08/28/图片惰性加载的实现/</id>
    <published>2017-08-28T12:41:11.000Z</published>
    <updated>2017-09-22T07:14:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于惰性加载"><a href="#关于惰性加载" class="headerlink" title="关于惰性加载"></a>关于惰性加载</h2><p>惰性加载又称为延迟加载、懒加载等，’lazyload’，即在长网页中延迟加载图像。当图片未到达可视区域时，不加载图片。如下图所示：  </p>
<img src="/2017/08/28/图片惰性加载的实现/1.gif" alt="1.gif" title="">  
<p>优点：提升用户的体验，如果图片数量较大，打开页面的时候要将将页面上所有的图片全部获取加载，很可能会出现卡顿现象，影响用户体验。因此，有选择性地请求图片，这样能明显减少了服务器的压力和流量，也能够减小浏览器的负担。<br><a id="more"></a>  </p>
<h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><p>惰性加载可以说在很久之前就已经出现了，实现方案也很简单。  </p>
<ul>
<li>在 HTML 文件中将需要惰性加载的图片的 src 属性置为一个相同的地址（一般设置为一张 loading 图），这样这张图只会加载一次（第二次即会读取缓存），或者干脆置为空（用户体验不好），将真实的图片地址存储在别的属性中（比如 data-src 属性)  </li>
<li>监听事件（比如 scroll 事件），判断需要惰性加载的图片是否已经在可视区域，如果是，则将 src 属性替换成 data-src 属性值  </li>
</ul>
<p>方案中，我们主要实现的功能有：判断图片和视口的位置关系，主要判断函数如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 比较元素位置 d2, 在d1中</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">_compareOffset</span>(<span class="params">d1, d2</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> left = d2.right &gt; d1.left &amp;&amp; d2.left &lt; d1.right;</div><div class="line">    <span class="keyword">let</span> top = d2.bottom &gt; d1.top &amp;&amp; d2.top &lt; d1.bottom;</div><div class="line">    <span class="keyword">return</span> left &amp;&amp; top;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>图片的坐标大小信息我们可以通过 <code>getBoundingClientRect</code> 来获得，浏览器窗口信息则为：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> w = &#123;</div><div class="line">    t = <span class="number">0</span>,</div><div class="line">    l = <span class="number">0</span>,</div><div class="line">    r = l + <span class="built_in">window</span>.innerWidth,</div><div class="line">    b = t + <span class="built_in">window</span>.innerHeight</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>剩下的只要监听 <code>scroll</code> 事件，对所有的 img.lazy-load 元素判断就好了。  </p>
<h2 id="监听-scroll-存在的性能问题"><a href="#监听-scroll-存在的性能问题" class="headerlink" title="监听 scroll 存在的性能问题"></a>监听 scroll 存在的性能问题</h2><p>当我们监听 scroll 事件的时候，页面滚动会导致该事件频繁出发，这对浏览器的性能产生很大的影响。为此我们可以加入函数节流(throttle)或函数去抖(debounce)来处理  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> _throttle = <span class="function">(<span class="params">func, wait, mustRunDelay = <span class="literal">Infinity</span></span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> timeout = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">let</span> start_time;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">let</span> context = <span class="keyword">this</span>,</div><div class="line">            args = <span class="built_in">arguments</span>,</div><div class="line">            curr_time = +<span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">        clearTimeout(timeout);</div><div class="line">        <span class="keyword">if</span>(!start_time) &#123;</div><div class="line">            start_time = curr_time;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(curr_time - start_time &gt;= mustRunDelay) &#123;</div><div class="line">            func.apply(context, args);</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                func.apply(context, args);</div><div class="line">            &#125;, wait);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>wait</code> 即判断的间隔事件，我们通常设置成 100ms 就可以不影响用户的体验。如果你想进一步提升图片加载性能我们也可以指定的将某些图片，base64 后存入 <code>localStorage</code> 中，等以后打开的时候，首先判断 <code>localStorage</code> 中是否有图片缓存，没有则去请求。这样就可以进一步加快图片的载入速度。  </p>
<p>完整的代码，可以查看 <a href="https://github.com/T-phantom/si-img" target="_blank" rel="external">si-img 图片优化组件</a>  </p>
<h2 id="IntersectionObserver-API"><a href="#IntersectionObserver-API" class="headerlink" title="IntersectionObserver API"></a>IntersectionObserver API</h2><p>虽然我们使用了函数节流来降低 scroll 的频率，但是检测函数触发的频率依然很高，这之中的大多数检测都是没有意义的(并没有新的图片进入)。为了更好的解决这类问题，浏览器也提供了 <code>IntersectionObserver</code> API 来帮助我们判断元素是否进入可是区域。</p>
<p>由于可见（visible）的本质是，目标元素与视口产生一个交叉区，所以这个 API 叫做”交叉观察器”。</p>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>使用方式十分简单：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> io = <span class="keyword">new</span> IntersectionObserver(callback, option);</div></pre></td></tr></table></figure>
<p>上面代码中，IntersectionObserver是浏览器原生提供的构造函数，接受两个参数：callback是可见性变化时的回调函数，option是配置对象（该参数可选）。<br>构造函数的返回值是一个观察器实例。实例的observe方法可以指定观察哪个 DOM 节点。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 开始观察</span></div><div class="line">io.observe(<span class="built_in">document</span>.getElementById(<span class="string">'example'</span>));</div><div class="line"></div><div class="line"><span class="comment">// 停止观察</span></div><div class="line">io.unobserve(element);</div><div class="line"></div><div class="line"><span class="comment">// 关闭观察器</span></div><div class="line">io.disconnect();</div></pre></td></tr></table></figure>
<p>上面代码中，observe的参数是一个 DOM 节点对象。如果要观察多个节点，就要多次调用这个方法。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">io.observe(elementA);</div><div class="line">io.observe(elementB);</div></pre></td></tr></table></figure>
<h3 id="callback"><a href="#callback" class="headerlink" title="callback"></a>callback</h3><p>目标元素的可见性变化时，就会调用观察器的回调函数callback。<br>callback一般会触发两次。一次是目标元素刚刚进入视口（开始可见），另一次是完全离开视口（开始不可见）。    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> io = <span class="keyword">new</span> IntersectionObserver(</div><div class="line">  entries =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(entries);</div><div class="line">  &#125;</div><div class="line">);</div></pre></td></tr></table></figure>
<p>callback函数的参数（entries）是一个数组，每个成员都是一个IntersectionObserverEntry对象。如果同时有两个被观察的对象的可见性发生变化，entries数组就会有两个成员。  </p>
<h3 id="IntersectionObserverEntry-对象"><a href="#IntersectionObserverEntry-对象" class="headerlink" title="IntersectionObserverEntry 对象"></a>IntersectionObserverEntry 对象</h3><p>IntersectionObserverEntry对象提供目标元素的信息，一共有六个属性：  </p>
<ul>
<li>time：可见性发生变化的时间ms</li>
<li>target：被观察的目标元素，是一个 DOM 节点对象</li>
<li>rootBounds：根元素的矩形区域的信息，getBoundingClientRect()方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回null</li>
<li>boundingClientRect：目标元素的矩形区域的信息</li>
<li>intersectionRect：目标元素与视口（或根元素）的交叉区域的信息</li>
<li>intersectionRatio：目标元素的可见比例，即intersectionRect占boundingClientRect的比例，完全可见时为1，完全不可见时小于等于0     </li>
</ul>
<h3 id="options-参数"><a href="#options-参数" class="headerlink" title="options 参数"></a>options 参数</h3><p>其中，options 整个参数对象以及它的三个属性都是可选的：</p>
<h4 id="root-属性"><a href="#root-属性" class="headerlink" title="root 属性"></a>root 属性</h4><p>IntersectionObserver API 的适用场景主要是这样的：一个可以滚动的元素，我们叫它根元素，它有很多后代元素，想要做的就是判断它的某个后代元素是否滚动进了自己的可视区域范围。这个 root 参数就是用来指定根元素的，默认值是 null。<br>如果它的值是 null，根元素就不是个真正意义上的元素了，而是这个浏览器窗口了，可以理解成 window。  </p>
<h4 id="threshold-属性"><a href="#threshold-属性" class="headerlink" title="threshold 属性"></a>threshold 属性</h4><p>当目标元素和根元素相交时，用相交的面积除以目标元素的面积会得到一个 0 到 1（0% 到 100%）的数值：<br>IntersectionObserver API 的基本工作原理就是：当目标元素和根元素相交的面积占目标元素面积的百分比到达或跨过某些指定的临界值时就会触发回调函数。threshold 参数就是用来指定那个临界值的，默认值是 0，表示俩元素刚刚挨上就触发回调。可以指定多个临界值，用数组形式，比如 [0, 0.5, 1]，表示在两个矩形开始相交，相交一半，完全相交这三个时刻都要触发一次回调函数。  </p>
<h4 id="rootMagin-属性"><a href="#rootMagin-属性" class="headerlink" title="rootMagin 属性"></a>rootMagin 属性</h4><p>rootMargin 可以给根元素添加一个假想的 margin，从而对真实的根元素区域进行缩放。比如当 root 为 null 时设置 rootMargin: “100px”，实际的根元素矩形四条边都会被放大 100px。</p>
<h2 id="利用-IntersectionObserver-实现高效的图片惰性加载"><a href="#利用-IntersectionObserver-实现高效的图片惰性加载" class="headerlink" title="利用 IntersectionObserver 实现高效的图片惰性加载"></a>利用 IntersectionObserver 实现高效的图片惰性加载</h2><p>首先获取哪儿些图片需要被IntersectionObserver 观测，这里我们认为带有 <code>.lazy-load</code> 类的图片：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取所有要观测的图片</span></div><div class="line"><span class="keyword">const</span> images = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.lazy-load'</span>);</div><div class="line"><span class="keyword">const</span> config = &#123;</div><div class="line">   <span class="comment">// 如果图像在Y轴上的50像素内，则开始下载。</span></div><div class="line">    rootMargin: <span class="string">'50px 0px'</span>,</div><div class="line">    threshold: <span class="number">0.01</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 观察图片</span></div><div class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> IntersectionObserver(onIntersection, config);</div><div class="line">    images.forEach(<span class="function"><span class="params">image</span> =&gt;</span> &#123;</div><div class="line">        observer.observe(image);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"><span class="string">``</span><span class="string">`  </span></div><div class="line"><span class="string">之后我们在 `</span>onIntersection<span class="string">` 中处理图片加载逻辑：  </span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">`</span><span class="string">``</span>javascript    </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onIntersection</span>(<span class="params">entries</span>) </span>&#123;</div><div class="line">    <span class="comment">// 查看所有观察的图片</span></div><div class="line">    entries.forEach(<span class="function"><span class="params">entry</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">if</span> (entry.intersectionRatio &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// 停止观察，并加载图片</span></div><div class="line">            observer.unobserve(entry.target);</div><div class="line">            preloadImage(entry.target);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样重写后的惰性加载插件性能将大大的提升，而且逻辑也变得十分简单。  </p>
<h2 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h2><p>下图为该API的支持情况：<br><img src="/2017/08/28/图片惰性加载的实现/2.png" alt="2.png" title=""><br>很遗憾safari还不支持该属性，你可以利用下面代码来简单实现降级方案：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!(<span class="string">'IntersectionObserver'</span> <span class="keyword">in</span> <span class="built_in">window</span>)) &#123;</div><div class="line">    <span class="comment">// 如果不支持，则立刻加载所有图片</span></div><div class="line">    <span class="built_in">Array</span>.from(images).forEach(<span class="function"><span class="params">image</span> =&gt;</span> preloadImage(image));</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    observer = <span class="keyword">new</span> IntersectionObserver(onIntersection, config);</div><div class="line">    images.forEach(<span class="function"><span class="params">image</span> =&gt;</span> &#123;</div><div class="line">        observer.observe(image);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果，你真的想在不支持的浏览器下体验该属性，你可以下载下面这个 polyfill。<a href="https://github.com/w3c/IntersectionObserver/tree/gh-pages/polyfill" target="_blank" rel="external">w3c/IntersectionObserver</a>  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于惰性加载&quot;&gt;&lt;a href=&quot;#关于惰性加载&quot; class=&quot;headerlink&quot; title=&quot;关于惰性加载&quot;&gt;&lt;/a&gt;关于惰性加载&lt;/h2&gt;&lt;p&gt;惰性加载又称为延迟加载、懒加载等，’lazyload’，即在长网页中延迟加载图像。当图片未到达可视区域时，不加载图片。如下图所示：  &lt;/p&gt;
&lt;img src=&quot;/2017/08/28/图片惰性加载的实现/1.gif&quot; alt=&quot;1.gif&quot; title=&quot;&quot;&gt;  
&lt;p&gt;优点：提升用户的体验，如果图片数量较大，打开页面的时候要将将页面上所有的图片全部获取加载，很可能会出现卡顿现象，影响用户体验。因此，有选择性地请求图片，这样能明显减少了服务器的压力和流量，也能够减小浏览器的负担。&lt;br&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>[译] 将你的网站改造为PWA</title>
    <link href="http://yoursite.com/2017/08/23/%E8%AF%91-%E5%B0%86%E4%BD%A0%E7%9A%84%E7%BD%91%E7%AB%99%E5%8D%87%E7%BA%A7%E4%B8%BAPWA/"/>
    <id>http://yoursite.com/2017/08/23/译-将你的网站升级为PWA/</id>
    <published>2017-08-23T12:07:14.000Z</published>
    <updated>2017-09-22T07:16:06.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文翻译自：<a href="https://www.sitepoint.com/retrofit-your-website-as-a-progressive-web-app/?utm_source=mobilewebweekly&amp;utm_medium=email" target="_blank" rel="external">Retrofit Your Website as a Progressive Web App</a><br>如果原文打不开请移步：<a href="https://www.zybuluo.com/caelumtian/note/860343" target="_blank" rel="external">这里</a>     </p>
</blockquote>
<p>最近大家都在讨论渐进增强web应用(Progressive Web Apps 简称PWA)，许多人质疑PWA是否能代表移动web的未来。这里我不会介入navtive app 和 PWA的争论之中，但是有件事是可以确定的-PWA在很大的长度上增强移动端提高了用户的体验。到2018年移动设备的web接入的数量注定要超过其他所有设备总量和，这种趋势是不可忽视的。<br><a id="more"></a><br>好消息是制作PWA程序并不是很困难。实际上，将现有的网站转换成PWA是很有可能的。在本文中，我将会介绍如何将一个网站改造成像native app一样。它可以离线工作，并且拥有自己的应用图标。  </p>
<h2 id="什么是渐进增强web应用？"><a href="#什么是渐进增强web应用？" class="headerlink" title="什么是渐进增强web应用？"></a>什么是渐进增强web应用？</h2><p>Progressiv Web App (简称PWA)是web上一个令人兴奋的创新。PWA由一系列技术组成，用来是web应用程序更像native应用。对于开发人员和用户来说，它可以突破web和native上面的限制因素：    </p>
<ol>
<li>你只需要开发一个符合W3c标准的web程序，不必开发单独的native版本  </li>
<li>用户可以在安装前就使用你的程序  </li>
<li>我们不在需要使用 AppStore，忍受那些难懂的规则或付费。应用程序可以自动更新，不再需要用户手动操作  </li>
<li>网页可以提醒用户是否在主屏幕上添加应用图标    </li>
<li>当程序启动时，PWA的具有吸引力的展示效果</li>
<li>如果有必要，可以修改浏览器设置达到全屏浏览的效果   </li>
<li>基本的文件被缓存在本地因此PWA具有比普通web应用更快的响应速度（他们设置比native app还要快  </li>
<li>安装更加的轻量，也许只是几百KB的缓存数据  </li>
<li>PWA处于离线状态可以在连接返回后同步数据  </li>
</ol>
<p>现在PWA技术还有些不成熟，但是已经有了积极的案例。印度最大的商务网站Flipkart 通过将native app转换成PWA使得销售增长了70%。全球最大的交易平台Alibaba转换率也达到了70%。<br>PWA技术已经被支持与Firefox,Chrome和其他基于Blink内核的浏览器中。微软的Edge也在努力的实现。尽管Apple在webkit五年计划上发表了很多积极的言论，但是依然没有支持PWA。  </p>
<h2 id="“渐进增强”-web-应用"><a href="#“渐进增强”-web-应用" class="headerlink" title="“渐进增强” web 应用"></a>“渐进增强” web 应用</h2><p>你的网站有可能依然运行在不支持PWA的浏览器中。这样做仅仅是让用户不能使用离线等功能，网站依然可以像网站一样正常运行。鉴于利益的汇报，我们没有理由不去将PWA技术添加到我们的网站之中。  </p>
<h2 id="这不仅仅是应用程序"><a href="#这不仅仅是应用程序" class="headerlink" title="这不仅仅是应用程序"></a>这不仅仅是应用程序</h2><p>Google 引领了PWA运动，以至于许多教程都在讲述如何在基于Chrome的基础上从头开始构建PWA应用。然而，你并不一定需要一个单页应用或者遵循界面设计指南。大多数网站都可以在几个小时能升级到PWA。这包括你的WordPress或者静态页面。在编写本文的时候，<code>Smashing</code> 杂志宣布，他们正在支持PWA的建设。  </p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>你可以在这里找到示例代码：<a href="https://github.com/sitepoint-editors/pwa-retrofit" target="_blank" rel="external">https://github.com/sitepoint-editors/pwa-retrofit</a><br>demo 提供了一个带有一些图片，一个样式表和一些主要的javascrit文件的四页网站。该网站可以运行在所有的现在浏览器中(IE10+)。如果您的浏览器支持PWA，那么你可以在离线时浏览整个网站。<br>运行代码请确保Node.js环境，在终端中执行下面的命令启动服务器:  </p>
<blockquote>
<p>node ./server.js [port]  </p>
</blockquote>
<p>打开Chrome或者基于Blik内核的浏览器，访问 <a href="http://localhost:8888/" target="_blank" rel="external">http://localhost:8888/</a> 来查看页面。你可以打开 Developer Tools来查看控制台输出信息。   </p>
<img src="/2017/08/23/译-将你的网站升级为PWA/1.png" alt="1.png" title=""> 
<p>下面的方案可以帮你离线查看： 关闭 web 服务器，或者在Developer Tools的 Network或Application中点击offline复选框。 重新访问你之前的页面，他们依然会加载。访问你没有看到过的网站，则会显示 <code>您处于离线状态</code>的页面，其中包含了网页列表信息。<br><img src="/2017/08/23/译-将你的网站升级为PWA/2.png" alt="2.png" title=""> </p>
<h3 id="连接移动设备"><a href="#连接移动设备" class="headerlink" title="连接移动设备"></a>连接移动设备</h3><p>你也可以通过USB线将移动设备连接到PC/MAC上，来查看页面。打开浏览器 More tools选中的Remote devices面板。    </p>
<img src="/2017/08/23/译-将你的网站升级为PWA/3.png" alt="3.png" title="">
<p>选择左侧的设置，点击 Add rule 添加 localhost:8888。现在你可以在移动设备上打开Chrome浏览器访问 <a href="http://localhost:8888。" target="_blank" rel="external">http://localhost:8888。</a>  </p>
<p>你可以使用浏览器菜单中的<code>Add to Home screen</code>。几次访问后，浏览器也会提醒你是否安装。上述两种方法都可以将应用程序添加到你的主屏幕。浏览几个页面后关闭Chrome断开设备链接。之后打开你的 PWA 网站，你可以看见启动屏幕并且依然能够查看之前的页面，尽管这时候你处于离线状态。  </p>
<h2 id="如何使用PWA技术"><a href="#如何使用PWA技术" class="headerlink" title="如何使用PWA技术"></a>如何使用PWA技术</h2><p>将你的网站转换成PWA仅需要一下三个基本步骤：  </p>
<h3 id="步骤1：设置HTTPS"><a href="#步骤1：设置HTTPS" class="headerlink" title="步骤1：设置HTTPS"></a>步骤1：设置HTTPS</h3><p>PWA需要HTTPS的支持，原因不言而喻。设置HTTPS在不同的主机上有不同的流程，但是HTTPS网站会在 Google 获得更高的 Rank 这使得一切都是值得的。<br>Chrome 允许使用 localhost 或者任何 127.x.x.x 来进行HTTPS测试。你也可以在Chrome启动中添加下面的命令，来使得PWA运行在HTTP中：  </p>
<blockquote>
<p>– user-data-dir<br>– unsafety-treat-insecure-origin-as-secure  </p>
</blockquote>
<h3 id="步骤2：创建-manifest-文件"><a href="#步骤2：创建-manifest-文件" class="headerlink" title="步骤2：创建 manifest 文件"></a>步骤2：创建 manifest 文件</h3><p>提供一个web应用程序相关的信息，包括名称，描述和配置到主屏幕的图标，启动图片和viewport。实际上，manifest 文件是提供上述信息的文件。<br>manifest 是一个JSON格式的文件。我们必须提供含有 Content-Type: application/manifest+json 或者 Content-Type: applicaiont/json 的HTTP请求头来时使用它。该文件可以随意起名，这里我们叫做 manifest.json：   </p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"name"</span>              : <span class="string">"PWA Website"</span>,</div><div class="line">  <span class="attr">"short_name"</span>        : <span class="string">"PWA"</span>,</div><div class="line">  <span class="attr">"description"</span>       : <span class="string">"An example PWA website"</span>,</div><div class="line">  <span class="attr">"start_url"</span>         : <span class="string">"/"</span>,</div><div class="line">  <span class="attr">"display"</span>           : <span class="string">"standalone"</span>,</div><div class="line">  <span class="attr">"orientation"</span>       : <span class="string">"any"</span>,</div><div class="line">  <span class="attr">"background_color"</span>  : <span class="string">"#ACE"</span>,</div><div class="line">  <span class="attr">"theme_color"</span>       : <span class="string">"#ACE"</span>,</div><div class="line">  <span class="attr">"icons"</span>: [</div><div class="line">    &#123;</div><div class="line">      <span class="attr">"src"</span>           : <span class="string">"/images/logo/logo072.png"</span>,</div><div class="line">      <span class="attr">"sizes"</span>         : <span class="string">"72x72"</span>,</div><div class="line">      <span class="attr">"type"</span>          : <span class="string">"image/png"</span></div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">      <span class="attr">"src"</span>           : <span class="string">"/images/logo/logo152.png"</span>,</div><div class="line">      <span class="attr">"sizes"</span>         : <span class="string">"152x152"</span>,</div><div class="line">      <span class="attr">"type"</span>          : <span class="string">"image/png"</span></div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">      <span class="attr">"src"</span>           : <span class="string">"/images/logo/logo192.png"</span>,</div><div class="line">      <span class="attr">"sizes"</span>         : <span class="string">"192x192"</span>,</div><div class="line">      <span class="attr">"type"</span>          : <span class="string">"image/png"</span></div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">      <span class="attr">"src"</span>           : <span class="string">"/images/logo/logo256.png"</span>,</div><div class="line">      <span class="attr">"sizes"</span>         : <span class="string">"256x256"</span>,</div><div class="line">      <span class="attr">"type"</span>          : <span class="string">"image/png"</span></div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">      <span class="attr">"src"</span>           : <span class="string">"/images/logo/logo512.png"</span>,</div><div class="line">      <span class="attr">"sizes"</span>         : <span class="string">"512x512"</span>,</div><div class="line">      <span class="attr">"type"</span>          : <span class="string">"image/png"</span></div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>&lt;head&gt;</code>标签中需要加入下面的内容：  </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"manifest"</span> <span class="attr">href</span>=<span class="string">"/manifest.json"</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这些字段的含义如下：  </p>
<ul>
<li>name – 应用名称</li>
<li>short_name – 应用的缩略名</li>
<li>description – 应用描述</li>
<li>start_url – 应用启动的相对路径 (通常为 /)</li>
<li>scope - 导航范围。例如：/app/会将应用限制在app文件夹下 </li>
<li>background-color - 启动界面的背景颜色  </li>
<li>display - 展示方式：fullscreen 全屏，standalong 类似native app，minimal-ui 一个简单的UI空间，browser 传统浏览器界面  </li>
<li>icons - 定义图片信息的数组，包括图片URL，大小和类型。应该定义一些列图标信息。  </li>
</ul>
<p>MDN 定义了完整的列表<a href="https://developer.mozilla.org/en-US/docs/Web/Manifest" target="_blank" rel="external">Web App Manifest properties</a><br>Chrome 浏览器会监听验证你的manifest文件，并且提供<code>add to homescreen</code> 链接：  </p>
<img src="/2017/08/23/译-将你的网站升级为PWA/4.png" alt="4.png" title="">  
<h3 id="步骤3：创建Service-Worker"><a href="#步骤3：创建Service-Worker" class="headerlink" title="步骤3：创建Service Worker"></a>步骤3：创建Service Worker</h3><p>Service Workers 是一个用来拦截网络请求的Javascript脚本，放在应用程序根目录下即可。<br>下面这段代码（/js/main.js）用来检测当网站支持 Service Worker 后注册service-worker.js脚本:  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator) &#123;</div><div class="line">    <span class="comment">// register service worker</span></div><div class="line">    navigator.serviceWorker.register(<span class="string">'/service-worker.js'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Service workers 可能会让感到迷惑，你可以根据自己的目的来调整demo代码。示例代码是标准的浏览器下载脚本，它单独运行在一个线程上。该脚本无权访问DOM或其他页面的API，但是它可以在网页发生变化的时候拦截网络请求，资源下载和Ajax请求。<br>Service workers也是网站需要采用HTTPS的根本原因。试想一下，如果第三方脚本可有轻易注入你的Service worker中。它就有可能窃取和篡改客户端和服务端之间的通讯信息。<br>Service workers 需要响应下面三个基本事件：install, activate 和 fetch。   </p>
<h4 id="Install-Event"><a href="#Install-Event" class="headerlink" title="Install Event"></a>Install Event</h4><p>这个事件发生在Service worker注册阶段。它通常用于使用Cache API来创建缓存，放置应用离线时所需要的资源。<br>首先，我们定义一些基础的配置：    </p>
<ol>
<li><code>缓存名称（CACHE）和版本号（version）</code> 你的应用可以有多个缓存，但我们只使用一个。因此应用版本号就很有用，当网站有重大的改变后，将使用心得缓存忽略掉之前的缓存。  </li>
<li><code>离线页面URL(offlineURL)</code> 当用户离线后视图访问之前没有访问过的页面，该页面将被显示。  </li>
<li><code>一系列提供离线功能的基本文件(installFilesEssential)</code> 这里应该提供一个包含CSS和Javascript的数组，我还向数组中加入了主页(/)和logo。你也应该加入其他的需要文件例如：/ 或者 /index.html。注意offlineURL也要加入这个数组。  </li>
<li><code>一些可选的文件(installFilesDesirable)</code> 如果有可能，这些内容将会被下载，但不会使安装中断    </li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// configuration</span></div><div class="line"><span class="keyword">const</span></div><div class="line">  version = <span class="string">'1.0.0'</span>,</div><div class="line">  CACHE = version + <span class="string">'::PWAsite'</span>,</div><div class="line">  offlineURL = <span class="string">'/offline/'</span>,</div><div class="line">  installFilesEssential = [</div><div class="line">    <span class="string">'/'</span>,</div><div class="line">    <span class="string">'/manifest.json'</span>,</div><div class="line">    <span class="string">'/css/styles.css'</span>,</div><div class="line">    <span class="string">'/js/main.js'</span>,</div><div class="line">    <span class="string">'/js/offlinepage.js'</span>,</div><div class="line">    <span class="string">'/images/logo/logo152.png'</span></div><div class="line">  ].concat(offlineURL),</div><div class="line">  installFilesDesirable = [</div><div class="line">    <span class="string">'/favicon.ico'</span>,</div><div class="line">    <span class="string">'/images/logo/logo016.png'</span>,</div><div class="line">    <span class="string">'/images/hero/power-pv.jpg'</span>,</div><div class="line">    <span class="string">'/images/hero/power-lo.jpg'</span>,</div><div class="line">    <span class="string">'/images/hero/power-hi.jpg'</span></div><div class="line">  ];</div></pre></td></tr></table></figure>
<p>installStaticFiles() 函数利用异步的Cache API 来将这些文件添加到缓存。当缓存生成后返回Promise对象：   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// install static assets</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">installStaticFiles</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> caches.open(CACHE)</div><div class="line">    .then(<span class="function"><span class="params">cache</span> =&gt;</span> &#123;</div><div class="line"></div><div class="line">      <span class="comment">// cache desirable files</span></div><div class="line">      cache.addAll(installFilesDesirable);</div><div class="line"></div><div class="line">      <span class="comment">// cache essential files</span></div><div class="line">      <span class="keyword">return</span> cache.addAll(installFilesEssential);</div><div class="line"></div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后，我们注册一个 install 监听器。我们必须提供一个waitUntil方法(参数为promise对象)，当oninstall或者onactivate触发时被调用，来执行我们的函数：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// application installation</span></div><div class="line">self.addEventListener(<span class="string">'install'</span>, event =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'service worker: install'</span>);</div><div class="line">  <span class="comment">// cache core files</span></div><div class="line">  event.waitUntil(</div><div class="line">    installStaticFiles()</div><div class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> self.skipWaiting())</div><div class="line">  );</div><div class="line">&#125;); </div><div class="line"><span class="string">``</span><span class="string">` </span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">#### Activate Event   </span></div><div class="line"><span class="string">当Service worker安装成功后会被立刻激活该事件。你可能并不总是需要这个处理程序。下面这段代码可以用来删除旧的缓存：  </span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">`</span><span class="string">``</span>javascript  </div><div class="line"><span class="comment">// clear old caches</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">clearOldCaches</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> caches.keys()</div><div class="line">    .then(<span class="function"><span class="params">keylist</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.all(</div><div class="line">        keylist</div><div class="line">          .filter(<span class="function"><span class="params">key</span> =&gt;</span> key !== CACHE)</div><div class="line">          .map(<span class="function"><span class="params">key</span> =&gt;</span> caches.delete(key))</div><div class="line">      );</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"><span class="comment">// application activated</span></div><div class="line">self.addEventListener(<span class="string">'activate'</span>, event =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'service worker: activate'</span>);</div><div class="line">    <span class="comment">// delete old caches</span></div><div class="line">  event.waitUntil(</div><div class="line">    clearOldCaches()</div><div class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> self.clients.claim())</div><div class="line">    );</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>注意，最后的 self.clients.claim() 将当前Service worker对象作为所有客户端的活动对象。  </p>
<h4 id="Fetch-Event"><a href="#Fetch-Event" class="headerlink" title="Fetch Event"></a>Fetch Event</h4><p>当网络产生请求后触发该事件，它通过调用respondWith() 方法来拦截GET请求并返回：  </p>
<ol>
<li>缓存中的内容。 </li>
<li>如果#1没有缓存，则使用Fetch API从网络加载资源(与Service worker的fetch event无关)，然后将资源添加到缓存中。  </li>
<li>如果#1，#2都失败了，则返回一个适当的结果。  </li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// application fetch network data</span></div><div class="line">self.addEventListener(<span class="string">'fetch'</span>, event =&gt; &#123;</div><div class="line">  <span class="comment">// abandon non-GET requests</span></div><div class="line">  <span class="keyword">if</span> (event.request.method !== <span class="string">'GET'</span>) <span class="keyword">return</span>;</div><div class="line">  <span class="keyword">let</span> url = event.request.url;</div><div class="line">  event.respondWith(</div><div class="line">    caches.open(CACHE)</div><div class="line">      .then(<span class="function"><span class="params">cache</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">return</span> cache.match(event.request)</div><div class="line">          .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</div><div class="line">            <span class="keyword">if</span> (response) &#123;</div><div class="line">              <span class="comment">// return cached file</span></div><div class="line">              <span class="built_in">console</span>.log(<span class="string">'cache fetch: '</span> + url);</div><div class="line">              <span class="keyword">return</span> response;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// make network request</span></div><div class="line">            <span class="keyword">return</span> fetch(event.request)</div><div class="line">              .then(<span class="function"><span class="params">newreq</span> =&gt;</span> &#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">'network fetch: '</span> + url);</div><div class="line">                <span class="keyword">if</span> (newreq.ok) cache.put(event.request, newreq.clone());</div><div class="line">                <span class="keyword">return</span> newreq;</div><div class="line">              &#125;)</div><div class="line">              <span class="comment">// app is offline</span></div><div class="line">              .catch(<span class="function"><span class="params">()</span> =&gt;</span> offlineAsset(url));</div><div class="line">          &#125;);</div><div class="line">      &#125;)</div><div class="line">  );</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>最后我们调用 offlineAsset(url) 方法返回一个适当的响应：    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// is image URL?</span></div><div class="line"><span class="keyword">let</span> iExt = [<span class="string">'png'</span>, <span class="string">'jpg'</span>, <span class="string">'jpeg'</span>, <span class="string">'gif'</span>, <span class="string">'webp'</span>, <span class="string">'bmp'</span>].map(<span class="function"><span class="params">f</span> =&gt;</span> <span class="string">'.'</span> + f);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isImage</span>(<span class="params">url</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> iExt.reduce(<span class="function">(<span class="params">ret, ext</span>) =&gt;</span> ret || url.endsWith(ext), <span class="literal">false</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// return offline asset</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">offlineAsset</span>(<span class="params">url</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (isImage(url)) &#123;</div><div class="line">    <span class="comment">// return image</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Response(</div><div class="line">      <span class="string">'&lt;svg role="img" viewBox="0 0 400 300" xmlns="http://www.w3.org/2000/svg"&gt;&lt;title&gt;offline&lt;/title&gt;&lt;path d="M0 0h400v300H0z" fill="#eee" /&gt;&lt;text x="200" y="150" text-anchor="middle" dominant-baseline="middle" font-family="sans-serif" font-size="50" fill="#ccc"&gt;offline&lt;/text&gt;&lt;/svg&gt;'</span>,</div><div class="line">      &#123; <span class="attr">headers</span>: &#123;</div><div class="line">        <span class="string">'Content-Type'</span>: <span class="string">'image/svg+xml'</span>,</div><div class="line">        <span class="string">'Cache-Control'</span>: <span class="string">'no-store'</span></div><div class="line">      &#125;&#125;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// return page</span></div><div class="line">    <span class="keyword">return</span> caches.match(offlineURL);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>例子中，offlineAsset()函数用来检测请求是否是一个图片并且返回一个包含”offline”字段的SVG。其他请求则返回离线页面。<br>Chrome开发工具提供了查看Service Worker信息的选项，包含了错误消息，重新加载工具和页面离线等内容：  </p>
<img src="/2017/08/23/译-将你的网站升级为PWA/5.png" alt="5.png" title="">
<p><code>Cache Storage</code> 列出了当前环境下所有的缓存内容，如果缓存有更新你需要点击刷新按钮来看到他们。  </p>
<img src="/2017/08/23/译-将你的网站升级为PWA/6.png" alt="6.png" title="">  
<p>同样Clear storage选项可以删除你的Service worker和缓存。  </p>
<h3 id="步骤4：创建一个实用的离线页面"><a href="#步骤4：创建一个实用的离线页面" class="headerlink" title="步骤4：创建一个实用的离线页面"></a>步骤4：创建一个实用的离线页面</h3><p>离线页面可以是一个静态页面来提醒用户他们访问的页面不能离线查看。同时，我们还需要提供一个可访问页面的URL列表供用户查看。<br>我们可以再main.js中来使用Cache API。但是，API的异步请求失败的时候会导致浏览器停止运行。为了防止这种情况发生，我们将检测离线元素和Caches API是否可用的代码放在其他的文件中 /js/offlinepage.js（必须放在 installFiledEssential数组前):    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// load script to populate offline page list</span></div><div class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.getElementById(<span class="string">'cachedpagelist'</span>) &amp;&amp; <span class="string">'caches'</span> <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</div><div class="line">  <span class="keyword">var</span> scr = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</div><div class="line">  scr.src = <span class="string">'/js/offlinepage.js'</span>;</div><div class="line">  scr.async = <span class="number">1</span>;</div><div class="line">  <span class="built_in">document</span>.head.appendChild(scr);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>/js/offlinepage 通过版本名称来查找最近的缓存，URL列表，删除没有页面的URLs，对列表进行排序并添加到id为cachedpagelist的DOM节点上：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// cache name</span></div><div class="line"><span class="keyword">const</span></div><div class="line">  CACHE = <span class="string">'::PWAsite'</span>,</div><div class="line">  offlineURL = <span class="string">'/offline/'</span>,</div><div class="line">  list = <span class="built_in">document</span>.getElementById(<span class="string">'cachedpagelist'</span>);</div><div class="line"><span class="comment">// fetch all caches</span></div><div class="line"><span class="built_in">window</span>.caches.keys()</div><div class="line">  .then(<span class="function"><span class="params">cacheList</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">// find caches by and order by most recent</span></div><div class="line">    cacheList = cacheList</div><div class="line">      .filter(<span class="function"><span class="params">cName</span> =&gt;</span> cName.includes(CACHE))</div><div class="line">      .sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</div><div class="line">    <span class="comment">// open first cache</span></div><div class="line">    caches.open(cacheList[<span class="number">0</span>])</div><div class="line">      .then(<span class="function"><span class="params">cache</span> =&gt;</span> &#123;</div><div class="line">        <span class="comment">// fetch cached pages</span></div><div class="line">        cache.keys()</div><div class="line">          .then(<span class="function"><span class="params">reqList</span> =&gt;</span> &#123;</div><div class="line">            <span class="keyword">let</span> frag = <span class="built_in">document</span>.createDocumentFragment();</div><div class="line">            reqList</div><div class="line">              .map(<span class="function"><span class="params">req</span> =&gt;</span> req.url)</div><div class="line">              .filter(<span class="function"><span class="params">req</span> =&gt;</span> (req.endsWith(<span class="string">'/'</span>) || req.endsWith(<span class="string">'.html'</span>)) &amp;&amp; !req.endsWith(offlineURL))</div><div class="line">              .sort()</div><div class="line">              .forEach(<span class="function"><span class="params">req</span> =&gt;</span> &#123;</div><div class="line">                <span class="keyword">let</span></div><div class="line">                  li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>),</div><div class="line">                  a = li.appendChild(<span class="built_in">document</span>.createElement(<span class="string">'a'</span>));</div><div class="line">                  a.setAttribute(<span class="string">'href'</span>, req);</div><div class="line">                  a.textContent = a.pathname;</div><div class="line">                  frag.appendChild(li);</div><div class="line">              &#125;);</div><div class="line">            <span class="keyword">if</span> (list) list.appendChild(frag);</div><div class="line">          &#125;);</div><div class="line">      &#125;)</div><div class="line">  &#125;);</div></pre></td></tr></table></figure>
<h2 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h2><p>如果你认为调试Serice Workers有困难，Chrome Development Tools中的 Application选项提供了一些列日志消息在控制台中。<br>你应该在隐身模式下开发你的应用程序，这样可以避免文件缓存带来的影响。<br>Firefox也提供了来自Service Workers的JavaScript调试信息，未来也会更加的完善。<br>最后Chrome 扩展程序 Lighthouse 可以提供更加丰富的PWA信息。  </p>
<h2 id="PWA-的问题"><a href="#PWA-的问题" class="headerlink" title="PWA 的问题"></a>PWA 的问题</h2><p>对于渐进增强web应用的支持需要谨慎，如果改造它花了很长时间那就得不偿失了。毕竟不支持 PWA 也不会造成很大的负面影响。<br>这里我们还有几个问题需要考虑：  </p>
<h3 id="URL-隐藏"><a href="#URL-隐藏" class="headerlink" title="URL 隐藏"></a>URL 隐藏</h3><p>如何隐藏地址栏我并没有演示，除非你开发了一个单页的游戏这才有必要。manifest的diplay：minimal-ui 或者 display: browser 才是适合大多数网站的。  </p>
<h3 id="缓存重载"><a href="#缓存重载" class="headerlink" title="缓存重载"></a>缓存重载</h3><p>你可以缓存站点的每一页。这对于小型网站是有好处的，但是对于那些拥有很多页面的网站就不那么可取了。没有人会对你所有的内容感兴趣并且设备缓存是有限度的。及时你只缓存访问过的页面，缓存依旧增长的很明显。<br>你也许该考虑以下建议：  </p>
<ul>
<li>只缓存重要的页面如主页，链接，最近的文章等</li>
<li>不缓存图片，视频和大的文件  </li>
<li>定期清除旧的缓存文件  </li>
<li>提供一个”缓存到本地”的按钮，以便用户可以自行选择  </li>
</ul>
<h3 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h3><p>缓存同样需要定期更新，不然用户只能看见旧的页面。<br>对于图片和视频这种不经常变化的内容，你可以设置一个持续一年的缓存时间：  </p>
<blockquote>
<p>Cache-Control: max-age=31536000    </p>
</blockquote>
<p>页面，css和脚本文件有可能频繁更新，你需要设置较短的更新时间例如24小时，确保在线状态服务器对版本的验证:  </p>
<blockquote>
<p>Cache-Control: must-revalidate, max-age=86400    </p>
</blockquote>
<p>你也可以考虑使用缓存清除技术来确定哪些不适用的旧文件，例如：命名你的CSS文件 styles-abc124.css，每个版本都修改哈希值。<br>缓存是很复杂的这里我建议你阅读 Jake Archibold 的文章 <a href="https://jakearchibald.com/2016/caching-best-practices/" target="_blank" rel="external">Caching best practices &amp; max-age gotchas</a>  </p>
<h2 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h2><p>如果你想了解更多，可以参考一下内容：  </p>
<ul>
<li><a href="https://pwa.rocks/" target="_blank" rel="external">PWA.rocks example applications</a></li>
<li><a href="https://developers.google.com/web/progressive-web-apps/" target="_blank" rel="external">Progressive Web Apps</a></li>
<li><a href="https://codelabs.developers.google.com/codelabs/your-first-pwapp/" target="_blank" rel="external">Your First PWA</a></li>
<li><a href="https://serviceworke.rs/" target="_blank" rel="external">Mozilla Service Worker Cookbook</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers" target="_blank" rel="external">MDN Using Service Workers</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文翻译自：&lt;a href=&quot;https://www.sitepoint.com/retrofit-your-website-as-a-progressive-web-app/?utm_source=mobilewebweekly&amp;amp;utm_medium=email&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Retrofit Your Website as a Progressive Web App&lt;/a&gt;&lt;br&gt;如果原文打不开请移步：&lt;a href=&quot;https://www.zybuluo.com/caelumtian/note/860343&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;     &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近大家都在讨论渐进增强web应用(Progressive Web Apps 简称PWA)，许多人质疑PWA是否能代表移动web的未来。这里我不会介入navtive app 和 PWA的争论之中，但是有件事是可以确定的-PWA在很大的长度上增强移动端提高了用户的体验。到2018年移动设备的web接入的数量注定要超过其他所有设备总量和，这种趋势是不可忽视的。&lt;br&gt;
    
    </summary>
    
      <category term="翻译文章" scheme="http://yoursite.com/categories/%E7%BF%BB%E8%AF%91%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="移动开发" scheme="http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
      <category term="PWA" scheme="http://yoursite.com/tags/PWA/"/>
    
  </entry>
  
  <entry>
    <title>[译] 如何利用 localStorage 来构建更快的应用程序</title>
    <link href="http://yoursite.com/2017/08/23/%E8%AF%91-%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8-localStorage-%E6%9D%A5%E6%9E%84%E5%BB%BA%E6%9B%B4%E5%BF%AB%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"/>
    <id>http://yoursite.com/2017/08/23/译-如何利用-localStorage-来构建更快的应用程序/</id>
    <published>2017-08-23T11:45:13.000Z</published>
    <updated>2017-08-25T09:03:48.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文翻译自：<a href="https://medium.freecodecamp.org/how-leverage-local-storage-to-build-lightning-fast-apps-4e8218134e0c" target="_blank" rel="external">How to leverage Local Storage to build lightning-fast apps</a><br>如果原文打不开请移步：<a href="https://www.zybuluo.com/caelumtian/note/857353" target="_blank" rel="external">这里</a>   </p>
</blockquote>
<p>用户偏爱快速响应的应用程序。他们并不关心API运行所需要的时间，而仅仅是想立即看到变化。所以我们怎么做才能尽力满足用户的需求？<br>解决方案：本地存储应用的更改，然后不定时的与你的服务器同步这些内容。但是当我们考虑到连接延迟问题的时候，这样做将会变得更加复杂。<br><a id="more"></a><br>让我们以一个媒体网站为例，用户可以通过点击 ❤️ 按钮来推荐一篇文章给他的朋友们。当用于再次点击该按钮后，则取消推荐。  </p>
<h2 id="上述案例虽然简单，但有一些极端的例子造成了很多问题"><a href="#上述案例虽然简单，但有一些极端的例子造成了很多问题" class="headerlink" title="上述案例虽然简单，但有一些极端的例子造成了很多问题"></a>上述案例虽然简单，但有一些极端的例子造成了很多问题</h2><p>我们并不知道网站内部发生了什么，为了简单起见，我们可以想象在第一次点击的时候，程序将一个项目添加到了推荐列表中，并且在第二次点击的时候移除这个项目。<br>下面让我们看看，如果我们开发这样一个简单的应用功能，会遇到哪儿些问题    </p>
<ol>
<li>我们需要考虑如果用户疯狂的点击 ❤️ 按钮，这些行为将会触发一系列响应 事件  </li>
<li>网速并不总是快的。在一个网速差的环境下，甚至连最简单的API调用都要花上几秒钟才可以完成。在这段时间用户就有可能离开了当前屏幕，然后才会返回  </li>
<li>有的时候，API调用可能失败，我们的程序应该能够有能力从在状况下正常运行  </li>
<li>用户有可能使用不同的设备来打开我们的网站，或者同时在移动设备和PC上面访问我们的网站。不管在哪儿种情况下我们都应该有一个策略来和后端同步数据并更新其状态  </li>
</ol>
<p>我们在实际中可能遇到更多的问题，但是本文着重来解决上面提到的问题。  </p>
<h2 id="明确问题"><a href="#明确问题" class="headerlink" title="明确问题"></a>明确问题</h2><img src="/2017/08/23/译-如何利用-localStorage-来构建更快的应用程序/1.jpeg" alt="1.jpeg" title="">  
<p>在讨论如何解决问题之前，我们来先定义要开发功能的实现标准。任务是开发一个可以在列表中添加和删除项目的功能，列表数据存储在后端。功能必须满足如下要求：  </p>
<ol>
<li>用户界面需要立刻响应用户的操作，让用户看到他们操作的结果。如果之后由于某些原因我们不能同步这些更改内容，我们应该通知用户操作失败。并且回滚到之前的状态。  </li>
<li>支持多个设备的交互。这并不意味着我们需要支持实时修改的功能，但是我们需要不断地获取整个数据。此外，后端为我们提供了添加和删除项目的API，我们必须使用它们来支持更好的同步效果。  </li>
<li>保证数据的完整性：无论什么时候一旦数据同步失败，我们的网站都应该从错误中恢复正常状态。  </li>
</ol>
<p>幸运的是，我们并不需要实现所有，而是开发一种可以实现它的数据存储机制。让我们来探究不同的实现方案。  </p>
<h2 id="最直接的方法"><a href="#最直接的方法" class="headerlink" title="最直接的方法"></a>最直接的方法</h2><img src="/2017/08/23/译-如何利用-localStorage-来构建更快的应用程序/2.jpeg" alt="2.jpeg" title="">   
<p>第一种解决办法是在 localStorage 中存储一份列表数据的副本，当用户进行操作时，我们也同时更新 localStorage 中的数据。这种解决问题的方案大多数与竞争条件或者API调用失败有关，例如：  </p>
<ol>
<li><code>获取并修改列表之间冲突</code> 让我们设想这样一个场景，网站从后端获取列表数据来更新我们的 localStorage。用户这个在更新没有完成之前，修改了数据。这将导致获取到的列表和本地列表之间产生合并冲突。为此我们需要区分那些还没有添加的项目和已经从web中或其他设备上删除的项目。  </li>
<li><code>API调用失败</code> 用户可能进行快速的大量的修改操作，也有可能是恢复操作。例如，用户可以添加项目到列表，然后删除它们，然后又添加回来。如果第一次操作失败，我们应该复原列表即从列表中删除该项。但是这样会破坏我们数据的完整性，因为该项目实际是应该在列表中的。我们最后一次调用时添加操作，而且它还没有完成。  </li>
</ol>
<p>因此，我认为应该保留更多的信息在 localStorage 中，而不仅仅只有最终的预期效果。这样我们才有能力从可能遇到的问题中恢复过来。  </p>
<h2 id="保留用户的操作历史记录"><a href="#保留用户的操作历史记录" class="headerlink" title="保留用户的操作历史记录"></a>保留用户的操作历史记录</h2><img src="/2017/08/23/译-如何利用-localStorage-来构建更快的应用程序/3.jpeg" alt="3.jpeg" title="">   
<p>这里有一个不同的方案：我们保留冲后端获取到的列表，并记录用户的所有操作。每个记录都会匹配一个后端API的调用(分别是’add’和’remove’)。<br>一旦API调用完成，我们更新本地副本数据并从历史记录中删去记录。当我们想和后端同步用户浏览器数据，我们仅仅获取列表的版本然后替换我们的副本。<br>我们不在有任何API调用失败的问题，因为我们明确知道API调用前列表的状态，并且我们可以从历史记录中删除该记录，从而保证数据的完整性。<br>这么做主要会带来性能问题。每次检查一个特性的项目是否在列表中，我们都需要通过所有记录来计算用户期望看到的内容。当然，这些性能都取决于在一定时间内用户进行的交互次数以及数据的存储方式。<br>我认为，这种方案非常利于用户在应用中创建内容的场景，因为它提供了许多解决同步问题的方案。但是我们的问题比这更简单，所以我们应该能够进行一些优化来提升性能。  </p>
<h2 id="中间地带"><a href="#中间地带" class="headerlink" title="中间地带"></a>中间地带</h2><img src="/2017/08/23/译-如何利用-localStorage-来构建更快的应用程序/4.jpeg" alt="4.jpeg" title="">   
<p>这种方案有足够的信息从负面情况中恢复。我们需要两个额外的列表，一个用于持续添加另一个用于删除。为了确保数据的完整性，你仅仅需要添加一些规则：  </p>
<ol>
<li><code>添加和删除列表优先于主列表</code> 例如：一个项目同时在删除列表中和主列表中时。如果浏览器检查项目是否在列表中，它应该返回 false。  </li>
<li><code>一个项目不能同时出现在两个列表中如果用户对一个项目进行了多次操作，则最后的修改应该具有优先级</code> 例如，如果用户添加了项目然后删除了它，作为结果它应该出现在删除列表中。项目在不在主列表中反而无关紧要。  </li>
<li><code>只有某个项目在最后一次调用API完成后，才可以从相应的列表中删除</code> 例如，用户添加了一个项目并删除了它，然后又在第一次调用完成之前添加了它。在这种情况下，该项目应该在添加列表中。但是只有在第二次添加完成后它才应该被删除。我们可以通过为每个条目分配一个ID来实现。在API调用完成后，删除使用这些ID的条目。  </li>
<li><code>每次API调用完成后，主列表应该被更新</code> 主列表应该反映后端的实际情况。所以在连续的添加和删除的情况下，即使在客户端看起来，项目并不在列表中，在第一次调用后我们应该把它添加到主列表中。  </li>
</ol>
<h2 id="关于API调用失败"><a href="#关于API调用失败" class="headerlink" title="关于API调用失败"></a>关于API调用失败</h2><p>调用API失败的原因是有所不同的。有些是临时的，有些不是。他们当中有些是致命的，有些事可以恢复的。无论解决方案是什么，失败的请求都应该返回一些关于失败原因的有用信息。<br>我认为HTTP状态吗是完美的。例如，如果状态吗是504网关超时，重新请求将是个不错的方案。但是如果是400请求错误，那么简单的重新请求将不会有任何效果。其中一些，比如401未经授权，可能需要用户额外的操作。在删除项目的时候，410状态码就可能意味着是用户从不同的设备删除了该项目。  </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>第一个解决方案是简单的列表，他是快速的，但处理负面情况是困难的  </li>
<li>第二种方案，我们创建了一个像列表的数据结构，但是保留了所有的更改记录。这有利于解决负面情况，但是速度很慢  </li>
<li>中间地带解决方案，从外表看依然想一个列表。但是他允许我们平衡性能并且简单快速的从错误中恢复  </li>
</ul>
<p>本文提到的问题只是一个方面。还有就是API调用的数量问题。如果用户执行了大量类似的交互，我们可以尝试最小化API调用的数量。此优化也会影响本地存储的结构。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文翻译自：&lt;a href=&quot;https://medium.freecodecamp.org/how-leverage-local-storage-to-build-lightning-fast-apps-4e8218134e0c&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;How to leverage Local Storage to build lightning-fast apps&lt;/a&gt;&lt;br&gt;如果原文打不开请移步：&lt;a href=&quot;https://www.zybuluo.com/caelumtian/note/857353&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;   &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用户偏爱快速响应的应用程序。他们并不关心API运行所需要的时间，而仅仅是想立即看到变化。所以我们怎么做才能尽力满足用户的需求？&lt;br&gt;解决方案：本地存储应用的更改，然后不定时的与你的服务器同步这些内容。但是当我们考虑到连接延迟问题的时候，这样做将会变得更加复杂。&lt;br&gt;
    
    </summary>
    
      <category term="翻译文章" scheme="http://yoursite.com/categories/%E7%BF%BB%E8%AF%91%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="数据交互" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92/"/>
    
      <category term="翻译文章" scheme="http://yoursite.com/tags/%E7%BF%BB%E8%AF%91%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>利用javascript搭建富文本编辑器</title>
    <link href="http://yoursite.com/2017/08/21/%E5%88%A9%E7%94%A8javascript%E6%90%AD%E5%BB%BA%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <id>http://yoursite.com/2017/08/21/利用javascript搭建富文本编辑器/</id>
    <published>2017-08-21T11:37:32.000Z</published>
    <updated>2017-10-30T12:34:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>近期项目中需要开发一个兼容PC和移动端的富文本编辑器，其中包含了一些特殊的定制功能。考察了下现有的js富文本编辑器，桌面端的很多，移动端的几乎没有。桌面端以UEditor为代表。但是我们并不打算考虑兼容性，所以没有必要采用UEditor这么重的插件。为此决定自研一个富文本编辑器。本文，主要介绍如何实现富文本编辑器，和解决一些不同浏览器和设备之间的bug。<br><a id="more"></a></p>
<h1 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h1><p>在现代浏览器中已经为我们准备好了许多API来让 html 支持富文本编辑功能，我们没有必要自己完成全部内容。  </p>
<h2 id="contenteditable-”true”"><a href="#contenteditable-”true”" class="headerlink" title="contenteditable=”true”"></a>contenteditable=”true”</h2><p>首先我们需要让一个 <code>div</code> 成为可编辑状态，加入<code>contenteditable=&quot;true&quot;</code> 属性即可。  </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">contenteditable</span>=<span class="string">"true"</span> <span class="attr">id</span>=<span class="string">"rich-editor"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在这样的 <code>&lt;div&gt;</code> 中插入任何节点都将默认是可编辑状态的。如果想插入不可编辑的节点，我们就需要指定插入节点的属性为 <code>contenteditable=&quot;false&quot;</code>。  </p>
<h2 id="光标操作"><a href="#光标操作" class="headerlink" title="光标操作"></a>光标操作</h2><p>作为富文本编辑器，开发者需要有能力控制光标的各种状态信息，位置信息等。浏览器提供了 <code>selection</code> 对象和 <code>range</code> 对象来操作光标。    </p>
<h3 id="selection-对象"><a href="#selection-对象" class="headerlink" title="selection 对象"></a>selection 对象</h3><p>Selection对象表示用户选择的文本范围或插入符号的当前位置。它代表页面中的文本选区，可能横跨多个元素。文本选区由用户拖拽鼠标经过文字而产生。<br>获得一个 selection 对象  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> selection = <span class="built_in">window</span>.getSelection();</div></pre></td></tr></table></figure>
<p>通常情况下我们不会直接操作 <code>selection</code> 对象，而是需要操作用 <code>seleciton</code> 对象所对应的用户选择的 <code>ranges</code> (区域)，俗称”拖蓝“。获取方式如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> range = selection.getRangeAt(<span class="number">0</span>);</div></pre></td></tr></table></figure>
<p>由于浏览器当前可能存在多个文本选取，所以 <code>getRangeAt</code> 函数接受一个索引值。在富文本编辑其中，我们不考虑多选取的可能性。  </p>
<p>selection 对象还有两个重要的方法， <code>addRange</code> 和 <code>removeAllRanges</code>。分别用于向当前选取添加一个 range 对象和 删除所有 range 对象。之后你会看到他们的用途。  </p>
<h3 id="range-对象"><a href="#range-对象" class="headerlink" title="range 对象"></a>range 对象</h3><p>通过 selection 对象获得的 range 对象才是我们操作光标的重点。Range表示包含节点和部分文本节点的文档片段。初见 range 对象你有可能会感到陌生又熟悉，在哪儿看见过呢？作为一个前端工程师，想必你一定拜读过《javascript 高级程序设计第三版》 这本书。在第12.4节，作者为我们介绍了 DOM2 级提供的 range 接口，用来更好的控制页面。反正我当时看的一脸？？？？这个有啥用，也没有这种需求啊。这里我们就大量的用到这个对象。对于下面节点：  </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">contenteditable</span>=<span class="string">"true"</span> <span class="attr">id</span>=<span class="string">"rich-editor"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>百度EUX团队<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>光标位置如图所示：<br><img src="/2017/08/21/利用javascript搭建富文本编辑器/a.png" alt="a.png" title=""><br>打印出此时的 range 对象：<br><img src="/2017/08/21/利用javascript搭建富文本编辑器/b.png" alt="b.png" title="">   </p>
<p>其中属性含义如下：  </p>
<ul>
<li>startContainer: range 范围的起始节点。</li>
<li>endContainer: range 范围的结束节点</li>
<li>startOffset: range 起点位置的偏移量。</li>
<li>endOffset: range 终点位置的偏移量。</li>
<li>commonAncestorContainer: 返回包含 startContainer 和 endContainer 的最深的节点。  </li>
<li>collapsed: 返回一个用于判断 Range 起始位置和终止位置是否相同的布尔值。  </li>
</ul>
<p>这里我们的 startContainer , endContainer, commonAncestorContainer都为 <code>#text</code> 文本节点 ‘百度EUX团队’。因为光标在‘度‘字后面，所以startOffset 和 endOffset 均为 2。且没有产生拖蓝，所以 collapsed 的值为 true。我们再看一个产生拖蓝的例子：  </p>
<p>光标位置如图所示：<br><img src="/2017/08/21/利用javascript搭建富文本编辑器/c.png" alt="c.png" title=""><br>打印出此时的 range 对象：<br><img src="/2017/08/21/利用javascript搭建富文本编辑器/d.png" alt="d.png" title="">   </p>
<p>由于产生了拖蓝 startContainer 和 endContainer 不再一致，collapsed 的值变为了 false。startOffset 和 endOffset 正好代表了拖蓝的起终位置。更多的效果大家自己尝试吧。  </p>
<p>操作一个 range 节点，主要有如下方法：  </p>
<ul>
<li>setStart(): 设置 Range 的起点</li>
<li>setEnd(): 设置 Range 的终点 </li>
<li>selectNode(): 设定一个包含节点和节点内容的 Range  </li>
<li>collapse(): 向指定端点折叠该 Range</li>
<li>insertNode(): 在 Range 的起点处插入节点。</li>
<li>cloneRange(): 返回拥有和原 Range 相同端点的克隆 Range 对象  </li>
</ul>
<p>富文本编辑里面常用的就这么多，还有很多方法就不列举了。  </p>
<h4 id="修改光标位置"><a href="#修改光标位置" class="headerlink" title="修改光标位置"></a>修改光标位置</h4><p>我们可以通过调用 <code>setStart()</code> 和 <code>setEnd()</code> 方法，来修改一个光标的位置或拖蓝范围。这两个方法接受的参数为各自的起终节点和偏移量。例如我想让光标位置到”百度EUX团队”最末尾，那么可以采用如下方法：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> range = <span class="built_in">window</span>.getSelection().getRangeAt(<span class="number">0</span>),</div><div class="line">    textEle = range.commonAncestorContainer;</div><div class="line">range.setStart(range.startContainer, textEle.length);</div><div class="line">range.setEnd(range.endContainer, textEle.length);</div></pre></td></tr></table></figure>
<p>我们加入一个定时器来查看效果： </p>
<img src="/2017/08/21/利用javascript搭建富文本编辑器/e.gif" alt="e.gif" title="">  
<p>然而这种方式有个局限性，就是当光标所在的节点如果发生了变动。比如被替换或者加入新的节点了，那么再用这种方式就不会有任何效果。为此我们有时候需要一种强制更改光标位置手段, 简要代码如下(实际中你有可能还需要考虑自闭和元素等内容)：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">resetRange</span>(<span class="params">startContainer, startOffset, endContainer, endOffset</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> selection = <span class="built_in">window</span>.getSelection();</div><div class="line">        selection.removeAllRanges();</div><div class="line">    <span class="keyword">let</span> range = <span class="built_in">document</span>.createRange();</div><div class="line">    range.setStart(startContainer, startOffset);</div><div class="line">    range.setEnd(endContainer, endOffset);</div><div class="line">    selection.addRange(range);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们通过重新创造一个 range 对象并且删除原有的 ranges 来保证光标一定会变动到我们想要的位置。 </p>
<h2 id="修改文本格式"><a href="#修改文本格式" class="headerlink" title="修改文本格式"></a>修改文本格式</h2><p>实现富文本编辑器，我们就要能够有修改文档格式的能力，比如加粗，斜体，文本颜色，列表等内容。DOM 为可编辑区提供了 <code>document.execCommand</code> 方法，该方法允许运行命令来操纵可编辑区域的内容。大多数命令影响文档的选择（粗体，斜体等），而其他命令插入新元素（添加链接）或影响整行（缩进）。当使用 contentEditable时，调用 execCommand() 将影响当前活动的可编辑元素。语法如下：  </p>
<blockquote>
<p>bool = document.execCommand(aCommandName, aShowDefaultUI, aValueArgument)  </p>
</blockquote>
<ul>
<li>aCommandName: 一个 DOMString ，命令的名称。可用命令列表请参阅 命令 。</li>
<li>aShowDefaultUI: 一个 Boolean， 是否展示用户界面，一般为 false。Mozilla 没有实现。</li>
<li>aValueArgument: 一些命令（例如insertImage）需要额外的参数（insertImage需要提供插入image的url），默认为null。  </li>
</ul>
<p>总之浏览器能把大部分我们想到的富文本编辑器需要的功能都实现了，这里我就不一一演示了。感兴趣的同学可以查看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/execCommand" target="_blank" rel="external">MDN - document.execCommand</a>。  </p>
<p>到这里，我相信你已经可以做出一个像模像样的富文本编辑器了。想想还挺激动的，但是呢，一切都没有结束，浏览器又一次坑了我们。  </p>
<h1 id="实战开始，填坑的旅途"><a href="#实战开始，填坑的旅途" class="headerlink" title="实战开始，填坑的旅途"></a>实战开始，填坑的旅途</h1><p>就在我们都以为开发如此简单的时候，实际上手却遇到了许多坑。   </p>
<h2 id="修正浏览器的默认效果"><a href="#修正浏览器的默认效果" class="headerlink" title="修正浏览器的默认效果"></a>修正浏览器的默认效果</h2><p>浏览器提供的富文本效果并不总是好用的，下面介绍几个遇到的问题。</p>
<h3 id="回车换行"><a href="#回车换行" class="headerlink" title="回车换行"></a>回车换行</h3><p>当我们在编辑其中输入内容并回车换行继续输入后，可编辑框内容生成的节点和我们预期是不符的。<br><img src="/2017/08/21/利用javascript搭建富文本编辑器/f.png" alt="f.png" title=""><br><img src="/2017/08/21/利用javascript搭建富文本编辑器/g.png" alt="g.png" title=""><br>可以看到最先输入的文字没有被包裹起来，而换行产生的内容，包裹元素是 <code>&lt;div&gt;</code> 标签。为了能够让文字被 <code>&lt;p&gt;</code> 元素包裹起来。<br>我们要在初始化的时候，向<code>&lt;div contenteditable=&quot;true&quot;&gt;</code>默认插入<code>&lt;p&gt;&lt;br&gt;&lt;/p&gt;</code> 元素(<code>&lt;br&gt;</code>标签用来占位，有内容输入后会自动删除)。这样以后每次回车产生的新内容都会被<code>&lt;p&gt;</code> 元素包裹起来(在可编辑状态下，回车换行产生的新结构会默认拷贝之前的内容，包裹节点，类名等各种内容)。<br>我们还需要监听 keyUp 事件下 <code>event.keyCode === 8</code> 删除键。当编辑器中内容全被清空后(delete键也会把<code>&lt;p&gt;</code>标签删除)，要重新加入<code>&lt;p&gt;&lt;br&gt;&lt;/p&gt;</code>标签，并把光标定位在里面。   </p>
<h3 id="插入-ul-和-ol-位置错误"><a href="#插入-ul-和-ol-位置错误" class="headerlink" title="插入 ul 和 ol 位置错误"></a>插入 ul 和 ol 位置错误</h3><p>当我们调用 <code>document.execCommand(&quot;insertUnorderedList&quot;, false, null)</code> 来插入一个列表的时候，新的列表会被插入<code>&lt;p&gt;</code>标签中。<br><img src="/2017/08/21/利用javascript搭建富文本编辑器/h.png" alt="h.png" title=""><br>为此我们需要每次调用该命令前做一次修正，参考代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">adjustList</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> lists = <span class="built_in">document</span>.querySelectorAll(<span class="string">"ol, ul"</span>);</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; lists.length; i++) &#123;</div><div class="line">        <span class="keyword">let</span> ele = lists[i]; <span class="comment">// ol</span></div><div class="line">        <span class="keyword">let</span> parentNode = ele.parentNode;</div><div class="line">        <span class="keyword">if</span> (parentNode.tagName === <span class="string">'P'</span> &amp;&amp; parentNode.lastChild === parentNode.firstChild) &#123;</div><div class="line">                parentNode.insertAdjacentElement(<span class="string">'beforebegin'</span>, ele);</div><div class="line">                parentNode.remove()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里有个附带的小问题，我试图在 <code>&lt;li&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;</code> 维护这样的编辑器结构(默认是没有<code>&lt;p&gt;</code>标签的)。效果在 chrome 下运行很好。但是在 safari 中，回车永远不会产生新的 <code>&lt;li&gt;</code> 标签，这样就是去了该有的列表效果。  </p>
<h3 id="插入分割线"><a href="#插入分割线" class="headerlink" title="插入分割线"></a>插入分割线</h3><p>调用 <code>document.execCommand(&#39;insertHorizontalRule&#39;, false, null);</code> 会插入一个<code>&lt;hr&gt;</code>标签。然而产生的效果却是这样的：<br><img src="/2017/08/21/利用javascript搭建富文本编辑器/i.gif" alt="i.gif" title=""><br>光标和<code>&lt;hr&gt;</code>的效果一致了。为此要判断当前光标是否在 <code>&lt;li&gt;</code> 里面，如果是则在 <code>&lt;hr&gt;</code> 后面追加一个空的文本节点 <code>#text</code> 不是的话追加 <code>&lt;p&gt;&lt;br&gt;&lt;/p&gt;</code>。然后将光标定位在里面，可用如下方式查找。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 查找父元素</span></div><div class="line"><span class="comment"> * @param &#123;String&#125; root </span></div><div class="line"><span class="comment"> * @param &#123;String | Array&#125; name </span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">findParentByTagName</span>(<span class="params">root, name</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> parent = root;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">"string"</span>) &#123;</div><div class="line">        name = [name];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (name.indexOf(parent.nodeName.toLowerCase()) === <span class="number">-1</span> &amp;&amp; parent.nodeName !== <span class="string">"BODY"</span> &amp;&amp; parent.nodeName !== <span class="string">"HTML"</span>) &#123;</div><div class="line">        parent = parent.parentNode;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> parent.nodeName === <span class="string">"BODY"</span> || parent.nodeName === <span class="string">"HTML"</span> ? <span class="literal">null</span> : parent;</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<h3 id="插入链接"><a href="#插入链接" class="headerlink" title="插入链接"></a>插入链接</h3><p>调用 <code>document.execCommand(&#39;createLink&#39;, false, url);</code> 方法我们可以插入一个 url 链接，但是该方法不支持插入指定文字的链接。同时对已经有链接的位置可以反复插入新的链接。为此我们需要重写此方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertLink</span>(<span class="params">url, title</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> selection = <span class="built_in">document</span>.getSelection(),</div><div class="line">        range = selection.getRangeAt(<span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span>(range.collapsed) &#123;</div><div class="line">        <span class="keyword">let</span> start = range.startContainer,</div><div class="line">            parent = Util.findParentByTagName(start, <span class="string">'a'</span>);</div><div class="line">        <span class="keyword">if</span>(parent) &#123;</div><div class="line">            parent.setAttribute(<span class="string">'src'</span>, url);</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">this</span>.insertHTML(<span class="string">`&lt;a href="<span class="subst">$&#123;url&#125;</span>"&gt;<span class="subst">$&#123;title&#125;</span>&lt;/a&gt;`</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">document</span>.execCommand(<span class="string">'createLink'</span>, <span class="literal">false</span>, url);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="设置-h1-h6-标题"><a href="#设置-h1-h6-标题" class="headerlink" title="设置 h1 ~ h6 标题"></a>设置 h1 ~ h6 标题</h3><p>浏览器没有现成的方法，但我们可以借助 <code>document.execCommand(&#39;formatBlock&#39;, false, tag)</code>, 来实现，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setHeading</span>(<span class="params">heading</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> formatTag = heading,</div><div class="line">        formatBlock = <span class="built_in">document</span>.queryCommandValue(<span class="string">"formatBlock"</span>);</div><div class="line">    <span class="keyword">if</span> (formatBlock.length &gt; <span class="number">0</span> &amp;&amp; formatBlock.toLowerCase() === formatTag) &#123;</div><div class="line">        <span class="built_in">document</span>.execCommand(<span class="string">'formatBlock'</span>, <span class="literal">false</span>, <span class="string">`&lt;<span class="subst">$&#123;<span class="keyword">this</span>.defaultParagraphSeparator&#125;</span>&gt;`</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">document</span>.execCommand(<span class="string">'formatBlock'</span>, <span class="literal">false</span>, <span class="string">`&lt;<span class="subst">$&#123;formatTag&#125;</span>&gt;`</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="插入定制内容"><a href="#插入定制内容" class="headerlink" title="插入定制内容"></a>插入定制内容</h3><p>当编辑器上传或加载附件的时候，要插入能够展示附件的 <code>&lt;div&gt;</code> 节点卡片到编辑中。这里我们借助 <code>document.execCommand(&#39;insertHTML&#39;, false, html);</code> 来插入内容。为了防止div被编辑，要设置 <code>contenteditable=&quot;false&quot;</code>哦。</p>
<h3 id="处理-paste-粘贴"><a href="#处理-paste-粘贴" class="headerlink" title="处理 paste 粘贴"></a>处理 paste 粘贴</h3><p>在富文本编辑器中，粘贴效果默认采用如下规则：   </p>
<ol>
<li>如果是带有格式的文本，则保留格式(格式会被转换成html标签的形式)</li>
<li>粘贴图文混排的内容，图片可以显示，src 为图片真实地址。</li>
<li>通过复制图片来进行粘贴的时候，不能粘入内容</li>
<li>粘贴其他格式内容，不能粘入内容  </li>
</ol>
<p>为了能够控制粘贴的内容，我们监听 <code>paste</code> 事件。该事件的 event 对象中会包含一个 clipboardData 剪切板对象。我们可以利用该对象的 getData 方法来获得带有格式和不带格式的内容，如下。   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> plainText = event.clipboardData.getData(<span class="string">'text/plain'</span>);  <span class="comment">// 无格式文本</span></div><div class="line"><span class="keyword">let</span> plainHTML = event.clipboardData.getData(<span class="string">'text/html'</span>);   <span class="comment">// 有格式文本</span></div></pre></td></tr></table></figure>
<p>之后调用 <code>document.execCommand(&#39;insertText&#39;, false, plainText);</code> 或 <code>document.execCommand(&#39;insertHTML&#39;, false, plainHTML;</code> 来重写编辑上的paste效果。</p>
<p>然而对于规则 3 ，上述方案就无法处理了。这里我们要引入 <code>event.clipboardData.items</code> 。这是一个数组包含了所有剪切板中的内容对象。比如你复制了一张图片来粘贴，那么 <code>event.clipboardData.items</code> 的长度就为2：<br><code>items[0]</code> 为图片的名称，items[0].kind 为 ‘string’, items[0].type 为 ‘text/plain’ 或 ‘text/html’。获取内容方式如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">items[<span class="number">0</span>].getAsString(<span class="function"><span class="params">str</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">// 处理 str 即可</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><code>items[1]</code> 为图片的二进制数据，items[1].kind 为’file’， items[1].type 为图片的格式。想要获取里面的内容，我们就需要创建 <code>FileReader</code> 对象了。示例代码如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> file = items[<span class="number">1</span>].getAsFile();</div><div class="line"><span class="comment">// file.size 为文件大小</span></div><div class="line"><span class="keyword">let</span> reader = <span class="keyword">new</span> FileReader();</div><div class="line">reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// reader.result 为文件内容，就可以做上传操作了</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>(<span class="regexp">/image/</span>.test(item.type)) &#123;</div><div class="line">    reader.readAsDataURL(file);   <span class="comment">// 读取为 base64 格式</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>处理完图片，那么对于复制粘贴其他格式内容会怎么样呢？在 mac 中，如果你复制一个磁盘文件，event.clipboardData.items 的长度为 2。 items[0] 依然为文件名，然而 items[1] 则为图片了，没错，是文件的缩略图。  </p>
<h3 id="输入法处理"><a href="#输入法处理" class="headerlink" title="输入法处理"></a>输入法处理</h3><p>当使用输入发的时候，有时候会发生一些意想不到的事情。 比如百度输入法可以输入一张本地图片，为此我们需要监听输入法产生的内容做处理。这里通过如下两个事件处理： </p>
<ul>
<li>compositionstart: 当浏览器有非直接的文字输入时, compositionstart事件会以同步模式触发</li>
<li>compositionend: 当浏览器是直接的文字输入时, compositionend会以同步模式触发</li>
</ul>
<h2 id="修复移动端的问题"><a href="#修复移动端的问题" class="headerlink" title="修复移动端的问题"></a>修复移动端的问题</h2><p>在移动端，富文本编辑器的问题主要集中在光标和键盘上面。我这里介绍几个比较大的坑。  </p>
<h3 id="自动获取焦点"><a href="#自动获取焦点" class="headerlink" title="自动获取焦点"></a>自动获取焦点</h3><p>如果想让我们的编辑器自动获得焦点，弹出软键盘，可以利用 <code>focus()</code> 方法。然而在 ios 下，死活没有结果。这主要是因为 ios safari 中，为了安全考虑不允许代码获得焦点。只能通过用户交互点击才可以。还好，这一限制可以去除： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self.appWebView setKeyboardDisplayRequiresUserAction:NO]</div></pre></td></tr></table></figure>
<h3 id="iOS-下回车换行，滚动条不会自动滚动"><a href="#iOS-下回车换行，滚动条不会自动滚动" class="headerlink" title="iOS 下回车换行，滚动条不会自动滚动"></a>iOS 下回车换行，滚动条不会自动滚动</h3><p>在 iOS 下，当我们回车换行的时候，滚动条并不会随着滚动下去。这样光标就可能被键盘挡住，体验不好。为了解决这一问题，我们就需要监听 <code>selectionchange</code> 事件，触发时，计算每次光标编辑器顶端距离，之后再调用 window.scroll() 即可解决。问题在于我们要如何计算当前光标的位置，如果仅是计算光标所在父元素的位置很有可能出现偏差(多行文本计算不准)。我们可以通过创建一个临时 <code>&lt;span&gt;</code> 元素查到光标位置，计算<code>&lt;span&gt;</code>元素的位置即可。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCaretYPosition</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> sel = <span class="built_in">window</span>.getSelection(),</div><div class="line">        range = sel.getRangeAt(<span class="number">0</span>);</div><div class="line">    <span class="keyword">let</span> span = <span class="built_in">document</span>.createElement(<span class="string">'span'</span>);</div><div class="line">    range.collapse(<span class="literal">false</span>);</div><div class="line">    range.insertNode(span);</div><div class="line">    <span class="keyword">var</span> topPosition = span.offsetTop;</div><div class="line">    span.parentNode.removeChild(span);</div><div class="line">    <span class="keyword">return</span> topPosition;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>正当我开心的时候，安卓端反应，编辑器越编辑越卡。什么鬼？我在 chrome 上线检查了一下，发现 <code>selectionchange</code> 函数一直在运行，不管有没有操作。<br>在逐一排查的时候发现了这么一个事实。<code>range.insertNode</code> 函数同样触发 <code>selectionchange</code> 事件。这样就形成了一个死循环。这个死循环在 safari 中就不会产生，只出现在 safari 中，为此我们就需要加上浏览器类型判断了。  </p>
<h3 id="键盘弹起遮挡输入部分"><a href="#键盘弹起遮挡输入部分" class="headerlink" title="键盘弹起遮挡输入部分"></a>键盘弹起遮挡输入部分</h3><p>网上对于这个问题主要的方案就是，设置定时器。局限与前端，确实只能这采用这样笨笨的解决。最后我们让 iOS 同学在键盘弹出的时候，将 webview 高度减去软键盘高度就解决了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CGFloat webviewY = 64.0 + self.noteSourceView.height;</div><div class="line">self.appWebView.frame = CGRectMake(0, webviewY, BDScreenWidth, BDScreenHeight - webviewY - height);</div></pre></td></tr></table></figure>
<h3 id="插入图片失败"><a href="#插入图片失败" class="headerlink" title="插入图片失败"></a>插入图片失败</h3><p>在移动端，通过调用 jsbridge 来唤起相册选择图片。之后调用 <code>insertImage</code> 函数来向编辑器插入图片。然而，插入图片一直失败。最后发现是因为早 safari 下，如果编辑器失去了焦点，那么 <code>selection</code> 和 <code>range</code> 对象将销毁。因此调用 <code>insertImage</code> 时，并不能获得光标所在位置，因此失败。为此需要增加，<code>backupRange()</code> 和 <code>restoreRange()</code> 函数。当页面失去焦点的时候记录 range 信息，插入图片前恢复 range 信息。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">backupRange() &#123;</div><div class="line">    <span class="keyword">let</span> selection = <span class="built_in">window</span>.getSelection();</div><div class="line">    <span class="keyword">let</span> range = selection.getRangeAt(<span class="number">0</span>);</div><div class="line">    <span class="keyword">this</span>.currentSelection = &#123;</div><div class="line">        <span class="string">"startContainer"</span>: range.startContainer,</div><div class="line">        <span class="string">"startOffset"</span>: range.startOffset,</div><div class="line">        <span class="string">"endContainer"</span>: range.endContainer,</div><div class="line">        <span class="string">"endOffset"</span>: range.endOffset</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">restoreRange() &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.currentSelection) &#123;</div><div class="line">        <span class="keyword">let</span> selection = <span class="built_in">window</span>.getSelection();</div><div class="line">            selection.removeAllRanges();</div><div class="line">        <span class="keyword">let</span> range = <span class="built_in">document</span>.createRange();</div><div class="line">        range.setStart(<span class="keyword">this</span>.currentSelection.startContainer, <span class="keyword">this</span>.currentSelection.startOffset);</div><div class="line">        range.setEnd(<span class="keyword">this</span>.currentSelection.endContainer, <span class="keyword">this</span>.currentSelection.endOffset);</div><div class="line">        <span class="comment">// 向选区中添加一个区域</span></div><div class="line">        selection.addRange(range);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 chrome 中，失去焦点并不会清除 <code>seleciton</code> 对象和 <code>range</code> 对象，这样我们轻轻松松一个 <code>focus()</code> 就搞定了。  </p>
<p>重要问题就这么多，限于篇幅限制其他的问题省略了。总体来说，填坑花了开发的大部分时间。  </p>
<h1 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h1><p>基础功能修修补补以后，实际项目中有可能遇到一些其他的需求，比如当前光标所在文字内容状态啊，图片拖拽放大啊，待办列表功能，附件卡片等功能啊，markdown切换等等。在了解了js 富文本的种种坑之后，range 对象的操作之后，相信这些问题你都可以轻松解决。这里最后提几个做扩展功能时候遇到的有去的问题。  </p>
<h2 id="回车换行带格式"><a href="#回车换行带格式" class="headerlink" title="回车换行带格式"></a>回车换行带格式</h2><p>前面已经说过了，富文本编辑器的机制就是这样，当你回车换行的时候新产生的内容和之前的格式一模一样。如果我们利用 <code>.card</code> 类来定义了一个卡片内容，那么换行产生的新的段落都将含有 <code>.card</code> 类且结构也是直接 copy 过来的。我们想要屏蔽这种机制，于是尝试在 keydown 的阶段做处理(如果在 keyup 阶段处理用户体验不好)。然而，并没有什么用，因为用户自定义的 keydown 事件要在 浏览器富文本的默认 keydown 事件之前触发，这样你就做不了任何处理。<br>为此我们为这类特殊的个体都添加一个 property 属性，添加在 property 上的内容是不会被copy下来的。这样以后就可以区分出来了，从而做对应的处理。  </p>
<h2 id="获取当前光标所在处样式"><a href="#获取当前光标所在处样式" class="headerlink" title="获取当前光标所在处样式"></a>获取当前光标所在处样式</h2><p>这里主要是考虑 下划线，删除线之类的样式，这些样式都是用标签类描述的，所以要遍历标签层级。直接上代码：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCaretStyle</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> selection = <span class="built_in">window</span>.getSelection(),</div><div class="line">        range = selection.getRangeAt(<span class="number">0</span>);</div><div class="line">        aimEle = range.commonAncestorContainer,</div><div class="line">        tempEle = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">let</span> tags = [<span class="string">"U"</span>, <span class="string">"I"</span>, <span class="string">"B"</span>, <span class="string">"STRIKE"</span>],</div><div class="line">        result = [];</div><div class="line">    <span class="keyword">if</span>(aimEle.nodeType === <span class="number">3</span>) &#123;</div><div class="line">        aimEle = aimEle.parentNode;</div><div class="line">    &#125;</div><div class="line">    tempEle = aimEle;</div><div class="line">    <span class="keyword">while</span>(block.indexOf(tempEle.nodeName.toLowerCase()) === <span class="number">-1</span>) &#123;</div><div class="line">        <span class="keyword">if</span>(tags.indexOf(tempEle.nodeName) !== <span class="number">-1</span>) &#123;</div><div class="line">            result.push(tempEle.nodeName);</div><div class="line">        &#125;</div><div class="line">        tempEle = tempEle.parentNode;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">let</span> viewStyle = &#123;</div><div class="line">        <span class="string">"italic"</span>: result.indexOf(<span class="string">"I"</span>) !== <span class="number">-1</span> ? <span class="literal">true</span> : <span class="literal">false</span>,</div><div class="line">        <span class="string">"underline"</span>: result.indexOf(<span class="string">"U"</span>) !== <span class="number">-1</span> ? <span class="literal">true</span> : <span class="literal">false</span>,</div><div class="line">        <span class="string">"bold"</span>: result.indexOf(<span class="string">"B"</span>) !== <span class="number">-1</span> ? <span class="literal">true</span> : <span class="literal">false</span>,</div><div class="line">        <span class="string">"strike"</span>: result.indexOf(<span class="string">"STRIKE"</span>) !== <span class="number">-1</span> ? <span class="literal">true</span> : <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">let</span> styles = <span class="built_in">window</span>.getComputedStyle(aimEle, <span class="literal">null</span>);</div><div class="line">    viewStyle.fontSize = styles[<span class="string">"fontSize"</span>],</div><div class="line">    viewStyle.color = styles[<span class="string">"color"</span>],</div><div class="line">    viewStyle.fontWeight = styles[<span class="string">"fontWeight"</span>],</div><div class="line">    viewStyle.fontStyle = styles[<span class="string">"fontStyle"</span>],</div><div class="line">    viewStyle.textDecoration = styles[<span class="string">"textDecoration"</span>];</div><div class="line">    viewStyle.isH1 = Util.findParentByTagName(aimEle, <span class="string">"h1"</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</div><div class="line">    viewStyle.isH2 = Util.findParentByTagName(aimEle, <span class="string">"h2"</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</div><div class="line">    viewStyle.isP = Util.findParentByTagName(aimEle, <span class="string">"p"</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</div><div class="line">    viewStyle.isUl = Util.findParentByTagName(aimEle, <span class="string">"ul"</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</div><div class="line">    viewStyle.isOl = Util.findParentByTagName(aimEle, <span class="string">"ol"</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</div><div class="line">    <span class="keyword">return</span> viewStyle;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="最后说一句"><a href="#最后说一句" class="headerlink" title="最后说一句"></a>最后说一句</h1><p>该项目目前提测中，所以呢，一但发现有意思的坑，我会及时补充的。  </p>
<h1 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h1><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/execCommand" target="_blank" rel="external">MDN - document.execCommand</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Selection" target="_blank" rel="external">MDN - selection</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Range" target="_blank" rel="external">MDN - range</a>  </li>
<li><a href="http://frontenddev.org/article/compatible-with-processing-and-chinese-input-method-to-optimize-the-input-events.html" target="_blank" rel="external">input 事件兼容处理以及中文输入法优化</a></li>
<li><a href="https://segmentfault.com/a/1190000004288686" target="_blank" rel="external">js获取剪切板内容，js控制图片粘贴</a></li>
<li><a href="http://blog.csdn.net/ll845876425/article/details/51884736" target="_blank" rel="external">iOS UIWebView 全属性详解</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期项目中需要开发一个兼容PC和移动端的富文本编辑器，其中包含了一些特殊的定制功能。考察了下现有的js富文本编辑器，桌面端的很多，移动端的几乎没有。桌面端以UEditor为代表。但是我们并不打算考虑兼容性，所以没有必要采用UEditor这么重的插件。为此决定自研一个富文本编辑器。本文，主要介绍如何实现富文本编辑器，和解决一些不同浏览器和设备之间的bug。&lt;br&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="富文本编辑器" scheme="http://yoursite.com/tags/%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据响应系统原理解析</title>
    <link href="http://yoursite.com/2017/08/21/%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2017/08/21/数据响应系统原理解析/</id>
    <published>2017-08-21T11:36:49.000Z</published>
    <updated>2017-08-21T11:36:49.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>移动端交互手势详解与实现</title>
    <link href="http://yoursite.com/2016/08/23/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%BA%A4%E4%BA%92%E6%89%8B%E5%8A%BF%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2016/08/23/移动端交互手势详解与实现/</id>
    <published>2016-08-23T11:09:51.000Z</published>
    <updated>2017-09-22T07:17:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一丶概述"><a href="#一丶概述" class="headerlink" title="一丶概述"></a>一丶概述</h2><p>如今移动端设备大行其道，前端也走进了移动的领域。在写移动端页面的交互效果的时候，我么难免要接触一些复杂的手势，而不仅仅像pc端那样简单的鼠标事件。手势实际上是一种输入模式。我们现在在直观意义上理解的人机交互是指人与机器之间的互动方式，这种互动方式经历了鼠标、物理硬件、屏幕触控、远距离的体感操作的逐步发展的过程。<br><a id="more"></a></p>
<h2 id="二丶移动端手势事件"><a href="#二丶移动端手势事件" class="headerlink" title="二丶移动端手势事件"></a>二丶移动端手势事件</h2><p>在浏览器中，为我们提供的手势并不算多，主要有：</p>
<ul>
<li>touchstart 当手指触摸屏幕时触发</li>
<li>touchmove 当手指在屏幕滑动时不断的触发</li>
<li>touchend 当手指从屏幕上移开时触发</li>
<li>touchcancel 当系统停止跟踪触摸时触发  </li>
</ul>
<p>是不是感觉很少，safari还为我们提供了三个独有的手势事件(用于复杂的手势)，然而也仅仅只能在safari中使用  </p>
<ul>
<li>gesturestart 当一个手指已经按在屏幕上，另一个手指也按上时触发</li>
<li>gesturechange 当触摸屏幕上任何一个手指发生变化时触发</li>
<li>gestureend 当任何一个手指从屏幕上移开时触发   2</li>
</ul>
<img src="/2016/08/23/移动端交互手势详解与实现/1.png" alt="1.png" title="">  
<p>最后呢，让我们看看移动设备上究竟有哪儿手势需要我们使用<br><img src="/2016/08/23/移动端交互手势详解与实现/2.png" alt="2.png" title=""></p>
<h2 id="三丶让JS支持这些手势"><a href="#三丶让JS支持这些手势" class="headerlink" title="三丶让JS支持这些手势"></a>三丶让JS支持这些手势</h2><p>目前看来，我们能用的也就只有touchstart，touchmove, touchend, touchcancel这四个手势，那么如何才能利用这四个手势支持众多的交互效果呢？首先我们从最简单的手势开始。简单的手势也就是说是单点触控，我们主要来实现如下几个手势：    </p>
<ul>
<li>tap 轻触</li>
<li>doubletap 连续两次轻触</li>
<li>press 长按</li>
<li>pan 平移</li>
<li>flick 轻拂  </li>
</ul>
<p>首先我们要解决如何触发自定义事件(已经了解自定事件的可以跳过)：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//自定义一个事件</span></div><div class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">"tap"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"tap事件触发"</span>)</div><div class="line">&#125;, <span class="literal">false</span>)  </div><div class="line"><span class="comment">//触发自定义事件  </span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fireEvent</span>(<span class="params">element, type, extra</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> event = doc.createEvent(<span class="string">'HTMLEvents'</span>);</div><div class="line">    event.initEvent(type, <span class="literal">true</span>, <span class="literal">true</span>);</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> extra === <span class="string">'object'</span>) &#123;</div><div class="line">        Util.extends(event, extra);     <span class="comment">//浅拷贝</span></div><div class="line">    &#125;</div><div class="line">    element.dispatchEvent(event);</div><div class="line">&#125;</div><div class="line">fireEvent(<span class="built_in">document</span>.body, <span class="string">"tap"</span>, &#123;&#125;);   <span class="comment">//触发tap事件</span></div></pre></td></tr></table></figure>
<p>我们在整个事件模拟中定义一个中间状态 <code>evet.status</code> 来表示当前的触摸状态，接下来我们就利用 touchstart，touchmove，touchend 来可以实现自己的触摸事件了:  </p>
<ul>
<li>tap事件：当touchstart触发时，我们将event.status状态改为 tapping。在touchend触发时，如果event.status依然为tapping则，触发tap事件。  </li>
<li>doubletap事件：在触发tap事件的时候，我们用一个变量lastTime记录当前时间。下一次触发tap时，用当前时间和lastTime做对比，如果小于300ms则触发doubletap事件  </li>
<li>pess事件：当touchstart触发时，我们定义一个setTimeout的函数(500ms)，如果500ms后仍然没有touchend触发，则定时函数将event.staus状态改为pressing。当touchend触发时，检测到状态为pressing则触发press事件。  </li>
<li>pan事件：我们在touchmove中检测当前状态是tapping和pressing时，并且手指移动距离大于10px则，触发pan平移事件。这个移动距离用event.touches[0].clientX - lastTouch.clientY 来检测就好(利用lastTouch记录，起始手指的event对象)。  </li>
<li>flick事件：这个事件就是”刷~刷”的划过屏幕的交互效果，在touchend时通过pan事件的移动距离和移动事件算出速度(注意是X和Y轴的合速度)，如果速度大于0.5，并且整个触摸过程时间小于100ms，则触发flick事件。  </li>
</ul>
<p>是不是很简单的用最原始的浏览器事件就能实现这些内容。接下来让我们看看两个手指的事件如果实现。  </p>
<h2 id="四丶实现多指触控"><a href="#四丶实现多指触控" class="headerlink" title="四丶实现多指触控"></a>四丶实现多指触控</h2><p>在实现多指触控的时候，我们需要了解一下触摸过程中event用来保存多个手指信息的三个属性：  </p>
<ul>
<li>touches当前屏幕上所有触摸点的集合列表</li>
<li>targetTouches绑定事件的那个结点上的触摸点的集合列表</li>
<li>changedTouches触发事件时改变的触摸点的集合    </li>
</ul>
<p>这三个有什么区别？举例来说，比如div1, div2只有div2绑定了touchstart事件，第一次放下一个手指在div2上，触发了touchstart事件，这个时候，三个集合的内容是一样的，都包含这个手指的touch，然后，再放下两个手指一个在div1上，一个在div2上，这个时候又会触发事件，但changedTouches里面只包含第二个第三个手指的信息，因为第一个没有发生变化，而targetTouches包含的是在第一个手指和第三个在div2上的手指集合，touches包含屏幕上所有手指的信息，也就是三个手指。这样是不是就很很清楚了。下面我们要根据上面的内容，继续解决一个问题：当两个手指作用在不同的节点上应该触发哪个节点的事件呢？<br>这里我们规定，如果触发在了两个不同节点上，我们去两个节点公有的最近父节点，作为触发的目标。寻找共有最小父节点代码如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//判断节点ele1是否包含ele2</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">contains</span>(<span class="params">ele1, ele2</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> ele1.contains ? ele1 != ele2 &amp;&amp; ele1.contains(ele2) : !!(ele1.compareDocumentPosition(ele2) &amp; <span class="number">16</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//获得共有最近的父节点</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCommonRootNode</span>(<span class="params">ele1, ele2</span>) </span>&#123;</div><div class="line">    <span class="keyword">while</span> (ele1) &#123;</div><div class="line">        <span class="keyword">if</span> (contains(ele1, ele2) || ele1 === ele2) &#123;</div><div class="line">            <span class="keyword">return</span> ele1;</div><div class="line">        &#125;</div><div class="line">        ele1 = ele1.parentNode;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 这样我们解决了，如何找到多个手指信息和触发哪个节点的问题。最后一个问题，当给了我们这些信息我们怎么能用？比如计算旋转手势，缩放手势啊什么的。<br> 这里我们仅考虑两个手指的多点触控。我们设touchstart阶段的两个手指坐标为 A(x1, y1)   B(x2, y2)。touchmove过程中的两个手指的坐标为 C(x3, y3) D(x4, y4)。  </p>
<ul>
<li>rotate旋转：计算AB，CD线段与坐标轴的夹角，对角度相减即得到旋转角度。  </li>
<li>scale 缩放：计算AB线段长度和CD线段长度(勾股定理)，两条线段做比值就好。  </li>
<li>translate平移： 平移的话我们只计算A点到C点的x坐标变化量。   </li>
</ul>
<p>具体代码如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">calcAction</span>(<span class="params">x1, y1, x2, y2, x3, y3, x4, y4</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> rotate = <span class="built_in">Math</span>.atan2(y4 - y3, x4 - x3) - <span class="built_in">Math</span>.atan2(y2 - y1, x2 - x1),</div><div class="line">        scale = <span class="built_in">Math</span>.sqrt((<span class="built_in">Math</span>.pow(y4 - y3, <span class="number">2</span>) + <span class="built_in">Math</span>.pow(x4 - x3, <span class="number">2</span>)) / (<span class="built_in">Math</span>.pow(y2 - y1, <span class="number">2</span>) + <span class="built_in">Math</span>.pow(x2 - x1, <span class="number">2</span>))),</div><div class="line">            translate = [x3 - scale * x1 * <span class="built_in">Math</span>.cos(rotate) + scale * y1 * <span class="built_in">Math</span>.sin(rotate), y3 - scale * y1 * <span class="built_in">Math</span>.cos(rotate) - scale * x1 * <span class="built_in">Math</span>.sin(rotate)];</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        rotate: rotate,</div><div class="line">        scale: scale,</div><div class="line">        translate: translate,</div><div class="line">            <span class="comment">/**</span></div><div class="line"><span class="comment">             * |ax + cy + e|</span></div><div class="line"><span class="comment">             * |bx + dy + f|</span></div><div class="line"><span class="comment">             * | 0 +  0 + 1|</span></div><div class="line"><span class="comment">             */</span></div><div class="line">        martrix: [</div><div class="line">            [scale * <span class="built_in">Math</span>.cos(rotate), -scale * <span class="built_in">Math</span>.sin(rotate), translate[<span class="number">0</span>]],</div><div class="line">            [scale * <span class="built_in">Math</span>.sin(rotate), scale * <span class="built_in">Math</span>.cos(rotate), translate[<span class="number">1</span>]],</div><div class="line">            [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</div><div class="line">        ]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 了解这些内容，你就可以在touchmove过程中完成对两个手指的旋转缩放平移等交互效果进行封装了。是不是很简单呢！<br> 当然完整的事件过程要分start，move，end这三种情况，在实现的时候要分别给予对应的实现就可以了。都逃不开对touchstart，touchmove，touchend的利用。  </p>
<h1 id="五丶实现案例"><a href="#五丶实现案例" class="headerlink" title="五丶实现案例"></a>五丶实现案例</h1><p>基于上面的方案，我实现了一个对移动端手势的封装库，包含以上所有的手势。犹豫这里代码运行不能模拟手机环境，我就不贴代码了。 感兴趣的同学可以访问：<a href="https://github.com/T-phantom/si-gesture" target="_blank" rel="external">https://github.com/T-phantom/si-gesture</a> 上面有具体的使用方法和带有详细注释的源码哦，欢迎start。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一丶概述&quot;&gt;&lt;a href=&quot;#一丶概述&quot; class=&quot;headerlink&quot; title=&quot;一丶概述&quot;&gt;&lt;/a&gt;一丶概述&lt;/h2&gt;&lt;p&gt;如今移动端设备大行其道，前端也走进了移动的领域。在写移动端页面的交互效果的时候，我么难免要接触一些复杂的手势，而不仅仅像pc端那样简单的鼠标事件。手势实际上是一种输入模式。我们现在在直观意义上理解的人机交互是指人与机器之间的互动方式，这种互动方式经历了鼠标、物理硬件、屏幕触控、远距离的体感操作的逐步发展的过程。&lt;br&gt;
    
    </summary>
    
      <category term="移动开发" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="移动开发" scheme="http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>

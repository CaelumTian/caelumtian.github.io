<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CaelumTian的博客</title>
  <subtitle>你若盛开，清风自来，心若沉浮 浅笑安然</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-21T11:29:20.119Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>CaelumTian</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>react-redux 深入探究</title>
    <link href="http://yoursite.com/2019/02/01/redux%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A32/"/>
    <id>http://yoursite.com/2019/02/01/redux源码理解2/</id>
    <published>2019-02-01T06:25:43.000Z</published>
    <updated>2019-04-21T11:29:20.119Z</updated>
    
    <content type="html"><![CDATA[<p>之前的文章我们讲解了数据流的作用，还有 redux 的源码。现在思考，如何将 redux 应用到 react 上面呢？<br>首先我们想到 store 可能被多个组件依赖和影响，为此我们应当借助 <code>context</code> 来存储 store 数据。将 store 存储在根元素上，通过 context 进行数据的传递。为了实现这一步，react-redux 提供了 <code>&lt;Provider&gt;</code>：</p>
<a id="more"></a>
<h2 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h2><p>Provider 简单代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Provider</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(props) &#123;</div><div class="line">        <span class="keyword">super</span>(props)</div><div class="line"></div><div class="line">        <span class="comment">// 获取store</span></div><div class="line">        <span class="keyword">const</span> &#123; store &#125; = props</div><div class="line"></div><div class="line">        <span class="comment">// 初始化state, storeState为初始的redux state</span></div><div class="line">        <span class="keyword">this</span>.state = &#123;</div><div class="line">            storeState: store.getState(),</div><div class="line">            <span class="comment">// 保存init store</span></div><div class="line">            store</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    componentDidMount() &#123;</div><div class="line">        <span class="comment">// 订阅 store 变更</span></div><div class="line">        <span class="keyword">this</span>.subscribe()</div><div class="line">    &#125;</div><div class="line">    componentWillUnmount() &#123;</div><div class="line">        <span class="comment">// 取消订阅</span></div><div class="line">        <span class="keyword">this</span>.unsubscribe();</div><div class="line">    &#125;</div><div class="line">    componentDidUpdate() &#123;</div><div class="line">        <span class="comment">// 如果更新的过程中store改变引用</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.props.store !== prevProps.store) &#123;</div><div class="line">            <span class="comment">// 如果存在监听则取消</span></div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.unsubscribe) <span class="keyword">this</span>.unsubscribe()</div><div class="line">            <span class="comment">// 更新storeState</span></div><div class="line">            <span class="keyword">this</span>.subscribe()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    subscribe() &#123;</div><div class="line">        <span class="keyword">const</span> &#123; store &#125; = <span class="keyword">this</span>.props</div><div class="line">        <span class="comment">// 监听subscribe</span></div><div class="line">        <span class="keyword">this</span>.unsubscribe = store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">            <span class="comment">// 获取最新的state赋值给newStoreState</span></div><div class="line">            <span class="keyword">const</span> newStoreState = store.getState()</div><div class="line">            <span class="comment">// 不在本次生命周期中return</span></div><div class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>._isMounted) &#123;</div><div class="line">                <span class="keyword">return</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">this</span>.setState(<span class="function"><span class="params">providerState</span> =&gt;</span> &#123;</div><div class="line">                <span class="comment">// If the value is the same, skip the unnecessary state update.</span></div><div class="line">                <span class="comment">// 如果state是相同的引用， 直接跳过state的更新</span></div><div class="line">                <span class="keyword">if</span> (providerState.storeState === newStoreState) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="literal">null</span></div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 更新当前storeState</span></div><div class="line">                <span class="keyword">return</span> &#123; <span class="attr">storeState</span>: newStoreState &#125;</div><div class="line">            &#125;)</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">    render() &#123;</div><div class="line">        <span class="comment">// ReactReduxContext = React.createContext(null);</span></div><div class="line">        <span class="keyword">const</span> Context = <span class="keyword">this</span>.props.context || ReactReduxContext</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;Context.Provider value=&#123;<span class="keyword">this</span>.state&#125;&gt;</div><div class="line">                &#123;<span class="keyword">this</span>.props.children&#125;</div><div class="line">            &lt;<span class="regexp">/Context.Provider&gt;</span></div><div class="line"><span class="regexp">        )</span></div><div class="line"><span class="regexp">    &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure>
<p>我们可以看到，在 Provider 准备完毕后，将 <code>state.store</code> 作为 context 的值。并且监听 store 的变化，如果有变化则调用 <code>setState</code> 来更新 context。这里用到的 context 是 <code>React 16+</code> 之后的新版本写法。之后会对其进行介绍。<br>现在我们子组件想要使用 <code>store</code> 数据的就可以包装在 <code>&lt;Context.Customer&gt;</code> 里面即可。当然这中间少不了一些优化和功能的增强，这些方法都被封撞在了 <code>connect</code> 中。</p>
<h2 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h2><p>首先看下 connect 的用法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">connect([mapStateToProps],[mapDispatchToProps],[mergeProps],[options])(&lt;Component / &gt;)</div></pre></td></tr></table></figure>
<p>connect 简化版代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createConnect</span>(<span class="params">&#123;</span></span></div><div class="line"><span class="function"><span class="params">    connectHOC = connectAdvanced,</span></span></div><div class="line"><span class="function"><span class="params">    mapStateToPropsFactories = defaultMapStateToPropsFactories,</span></span></div><div class="line"><span class="function"><span class="params">    mapDispatchToPropsFactories = defaultMapDispatchToPropsFactories,</span></span></div><div class="line"><span class="function"><span class="params">    mergePropsFactories = defaultMergePropsFactories,</span></span></div><div class="line"><span class="function"><span class="params">    selectorFactory = defaultSelectorFactory</span></span></div><div class="line"><span class="function"><span class="params">&#125; = &#123;&#125;</span>) </span>&#123;</div><div class="line">    <span class="comment">// connect方法</span></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">        mapStateToProps,</span></span></div><div class="line"><span class="function"><span class="params">        mapDispatchToProps,</span></span></div><div class="line"><span class="function"><span class="params">        mergeProps,</span></span></div><div class="line"><span class="function"><span class="params">        &#123;</span></span></div><div class="line"><span class="function"><span class="params">            pure = true,  <span class="regexp">//</span> 是否就行浅比较的配置</span></span></div><div class="line"><span class="function"><span class="params">            strictEqual,  <span class="regexp">//</span> 判断object引用, strictEqual(a, b</span>)=&gt; <span class="title">a</span> === <span class="title">b</span></span></div><div class="line"><span class="function">            <span class="title">shallowEqual</span>, // 浅比较</span></div><div class="line"><span class="function">            ...<span class="title">extraOptions</span>  // 其他配置项</span></div><div class="line"><span class="function">        &#125; = </span>&#123;&#125;</div><div class="line">    ) &#123;</div><div class="line">        <span class="comment">// 下面，分别初始化了各自的参数 mapStateToProps,mapDispatchToProps,mergeProps，并且包装了一些内默认参数和方法 </span></div><div class="line">        <span class="keyword">const</span> initMapStateToProps = match(...args)</div><div class="line">        <span class="keyword">const</span> initMapDispatchToProps = match(...args)</div><div class="line">        <span class="keyword">const</span> initMergeProps = match(...args)</div><div class="line">        <span class="comment">// 核心部分，根据传入参数，返回包装好的高阶组件</span></div><div class="line">        <span class="keyword">return</span> connectAdvanced(selectorFactory, &#123;</div><div class="line">            initMapStateToProps,</div><div class="line">            initMapDispatchToProps,</div><div class="line">            initMergeProps,</div><div class="line">            pure,</div><div class="line">            ...extraOptions</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> <span class="comment">// 直接执行createConnect方法返回connect</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> createConnect()</div></pre></td></tr></table></figure>
<p>先说明一下该函数的参数：</p>
<ul>
<li>connectHOC: 一个重要组件，用于执行已确定的逻辑，渲染最终组件，后面会详细说。</li>
<li>mapStateToPropsFactories: 对 mapStateToProps 这个传入的参数的类型选择一个合适的方法。</li>
<li>mapDispatchToPropsFactories: 对 mapDispatchToProps 这个传入的参数的类型选择一个合适的方法。</li>
<li>mergePropsFactories: 对 mergeProps 这个传入的参数的类型选择一个合适的方法。 </li>
<li>selectorFactory: 以上3个只是简单的返回另一个合适的处理方法，它则执行这些处理方法，并且对结果定义了如何比较的逻辑。</li>
</ul>
<p>三个 mapxxx 参数，用来对 <code>mapStateToProps</code> 和 <code>mapDispatchToProps</code> 进行参数校验，并且通过 match 返回如下形式函数，作为 connectAdvanced 参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> initProxySelector = <span class="function">(<span class="params">mapToProps, methodName</span>) =&gt;</span> (dispatch, &#123;displayName&#125;) =&gt; &#123;</div><div class="line">    <span class="keyword">const</span> proxy = <span class="function"><span class="keyword">function</span> <span class="title">mapToPropsProxy</span>(<span class="params">...</span>) </span>&#123;...&#125;</div><div class="line">    <span class="comment">// proxy 各种包装</span></div><div class="line">    <span class="keyword">return</span> proxy;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>后面解释为什么这么包装。 <code>connect</code> 核心部分就是高阶函数的封装：</p>
<h3 id="connectAdvanced-高阶函数"><a href="#connectAdvanced-高阶函数" class="headerlink" title="connectAdvanced 高阶函数"></a>connectAdvanced 高阶函数</h3><p>简要代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">connectAdvanced</span> (<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">    selectorFactory,</span></span></div><div class="line"><span class="function"><span class="params">    &#123;</span></span></div><div class="line"><span class="function"><span class="params">        <span class="regexp">//</span>... 各种参数配置</span></span></div><div class="line"><span class="function"><span class="params">    &#125; = &#123;&#125;</span></span></div><div class="line"><span class="function"><span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> Context = context;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">wrapWithConnect</span>(<span class="params">WrappedComponent</span>) </span>&#123;</div><div class="line">        <span class="comment">// pure 决定 shouldComponentUpdate 是否进行 shallowEqual 浅比较，默认 true</span></div><div class="line">        <span class="keyword">const</span> &#123;pure&#125; = connectOptions;</div><div class="line">        <span class="comment">// 即 React.Component</span></div><div class="line">        <span class="keyword">let</span> OuterBaseComponent = Component</div><div class="line">        <span class="keyword">let</span> FinalWrappedComponent = WrappedComponent</div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Connect</span> <span class="keyword">extends</span> <span class="title">OuterBaseComponent</span> </span>&#123;</div><div class="line">            <span class="keyword">constructor</span>(props) &#123;</div><div class="line">                <span class="comment">// 这两个定义的方法，后面介绍</span></div><div class="line">                <span class="keyword">this</span>.selectDerivedProps = makeDerivedPropsSelector()</div><div class="line">                <span class="keyword">this</span>.selectChildElement = makeChildElementSelector()</div><div class="line">                <span class="comment">// bind this</span></div><div class="line">                <span class="keyword">this</span>.renderWrappedComponent = <span class="keyword">this</span>.renderWrappedComponent.bind(<span class="keyword">this</span>)</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// value 为 context, 既 provider中的 &#123;storeState: store.getState(),store&#125;</span></div><div class="line">            renderWrappedComponent(value) &#123;</div><div class="line">                <span class="keyword">const</span> &#123;</div><div class="line">                    storeState,</div><div class="line">                    store</div><div class="line">                &#125; = value</div><div class="line"></div><div class="line">                <span class="comment">// 定义wrapperProps为this.props</span></div><div class="line">                <span class="keyword">let</span> wrapperProps = <span class="keyword">this</span>.props</div><div class="line">                <span class="keyword">let</span> forwardedRef</div><div class="line">                <span class="comment">// forwardRef为真时, Connect组件提供了forwardedRef = &#123;ref&#125;</span></div><div class="line">                <span class="keyword">if</span> (forwardRef) &#123;</div><div class="line">                    <span class="comment">// wrapperProps为props中的wrapperProps</span></div><div class="line">                    wrapperProps = <span class="keyword">this</span>.props.wrapperProps</div><div class="line">                    forwardedRef = <span class="keyword">this</span>.props.forwardedRef</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//@1 导出 props</span></div><div class="line">                <span class="keyword">let</span> derivedProps = <span class="keyword">this</span>.selectDerivedProps(</div><div class="line">                    storeState,</div><div class="line">                    wrapperProps,</div><div class="line">                    store</div><div class="line">                )</div><div class="line">                <span class="comment">//@2 返回最终的组件, 传入最终的 props 和 ref -&gt; 看selectChildElement发放</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.selectChildElement(derivedProps, forwardedRef)</div><div class="line">            &#125;</div><div class="line">            render() &#123;</div><div class="line">                <span class="comment">// 默认情况下公用的 ReactReduxContext</span></div><div class="line">                <span class="keyword">const</span> ContextToUse = <span class="keyword">this</span>.props.context || Context</div><div class="line">                <span class="keyword">return</span> (</div><div class="line">                    &lt;ContextToUse.Consumer&gt; &#123;</div><div class="line">                        <span class="keyword">this</span>.renderWrappedComponent</div><div class="line">                    &#125; &lt;<span class="regexp">/ContextToUse.Consumer&gt;</span></div><div class="line"><span class="regexp">                )</span></div><div class="line"><span class="regexp">            &#125;</span></div><div class="line"><span class="regexp">        &#125;</span></div><div class="line"><span class="regexp">        Connect.WrappedComponent = WrappedComponent</span></div><div class="line"><span class="regexp">        Connect.displayName = displayName</span></div><div class="line"><span class="regexp">        if (forwardRef) &#123;</span></div><div class="line"><span class="regexp">            /</span><span class="regexp">/ 转发 Ref (React 16 ref 转发语法)</span></div><div class="line"><span class="regexp">            const forwarded = React.forwardRef(function forwardConnectRef(props,ref) &#123;</span></div><div class="line"><span class="regexp">                return </span></div><div class="line"><span class="regexp">                    &lt;Connect </span></div><div class="line"><span class="regexp">                        wrapperProps = &#123;props&#125; </span></div><div class="line"><span class="regexp">                        forwardedRef = &#123;ref&#125;/</span>&gt;</div><div class="line">            &#125;)</div><div class="line">            forwarded.displayName = displayName</div><div class="line">            forwarded.WrappedComponent = WrappedComponent</div><div class="line">            <span class="keyword">return</span> hoistStatics(forwarded, WrappedComponent)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 静态方法补充</span></div><div class="line">        <span class="keyword">return</span> hoistStatics(Connect, WrappedComponent)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>connectAdvanced</code>，本身上返回了一个包装了 <code>&lt;Context.Consumer&gt;</code> 的高阶组件，并且其内部已经用 <code>React.forwardRef</code> 解决了高阶组件的 ref 转发问题，利用 <code>hoist-non-react-statics</code> 工具解决了高阶组件静态方法复制的问题 <code>hoistStatics(Connect, WrappedComponent)</code>。</p>
<h3 id="如何优化？"><a href="#如何优化？" class="headerlink" title="如何优化？"></a>如何优化？</h3><p>到这里，react-redux 的机制大体就完整了。store 的每次更新都会触发 <code>context</code> 的变动，从而引起订阅了 <code>context</code> 的组件重新渲染。那么我们来思考两个问题：</p>
<ol>
<li>每次 <code>store</code> 变动，都会触发根组件 <code>setState</code> 从而导致 <code>re-render</code>。我们知道当父组件 <code>re-render</code> 后一定会导致子组件 <code>re-render</code> 然而，引入 react-redux 并没有这个副作用，这是如何处理的？</li>
<li>不同的子组件，需要的只是 <code>store</code> 上的一部分数据，如何在 <code>context</code> 发生变化后，仅仅影响那些用到变化部分 <code>context</code> 的组件？</li>
</ol>
<h4 id="this-props-children"><a href="#this-props-children" class="headerlink" title="this.props.children"></a>this.props.children</h4><p>针对第一个问题，其实解决很简单。源码中，<code>Provider</code> 返回的是 <code>&lt;Context.Provider&gt;this.props.children&lt;/Context&gt;</code> 这样当 Provider 调用 <code>setState</code> 的时候，由于 this.props.children 本质上是没有变化的，所以 Provider 下的所有组件都不会触发 <code>re-render</code>。简单来说如下： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">    componentDidMount() &#123;</div><div class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'re-render'</span>)</div><div class="line">            <span class="keyword">this</span>.setState(&#123;&#125;);</div><div class="line">        &#125;, <span class="number">1000</span>)</div><div class="line">    &#125;</div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.props.children;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">    render() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'A2 '</span>)</div><div class="line">        <span class="keyword">return</span> &lt;span&gt;A2&lt;/span&gt;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 渲染节点 &lt;A1&gt;&lt;A2 /&gt;&lt;A1/&gt;</span></div></pre></td></tr></table></figure>
<p>运行结果如下，可以看到 <code>this.props.children</code> 下的内容都不会 <code>re-render</code><br><img src="/2019/02/01/redux源码理解2/a1.png" alt="a1.png" title="">  </p>
<p>（如果没有使用 this.props.children 的写法，直接嵌套的话，那么当 Context 变动后，所有子组件都会 re-render 没有达到很好地预期效果）</p>
<p>（旧版本是通过对 connect 的组件都加入了 store.subscribe 达到的局部相应更新）</p>
<h4 id="makeDerivedPropsSelector-amp-amp-makeChildElementSelector"><a href="#makeDerivedPropsSelector-amp-amp-makeChildElementSelector" class="headerlink" title="makeDerivedPropsSelector &amp;&amp; makeChildElementSelector"></a>makeDerivedPropsSelector &amp;&amp; makeChildElementSelector</h4><p>针对第二个问题，我们可以在 <code>renderWrappedComponent</code> 中的这两个方法找到答案。</p>
<h4 id="makeChildElementSelector"><a href="#makeChildElementSelector" class="headerlink" title="makeChildElementSelector"></a>makeChildElementSelector</h4><p>从上面的源码中，我们看出最终返回的组件就是调用了这个函数，带函数接受了最终需要渲染的 <code>props</code> 和 <code>ref</code> 值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeChildElementSelector</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 定义props, ref, element变量</span></div><div class="line">    <span class="keyword">let</span> lastChildProps, lastForwardRef, lastChildElement</div><div class="line">    <span class="comment">// 返回function</span></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">selectChildElement</span>(<span class="params">childProps, forwardRef</span>) </span>&#123;</div><div class="line">        <span class="comment">// 判断新旧 props， hre， elelment是否相同</span></div><div class="line">        <span class="keyword">if</span> (childProps !== lastChildProps || forwardRef !== lastForwardRef) &#123;</div><div class="line">            <span class="comment">// 如果不同重新赋值</span></div><div class="line">            lastChildProps = childProps</div><div class="line">            lastForwardRef = forwardRef</div><div class="line">            lastChildElement = (</div><div class="line">                <span class="comment">// return FinalWrappedComponent, 改变props和ref</span></div><div class="line">                &lt;FinalWrappedComponent </div><div class="line">                    &#123;...childProps&#125;</div><div class="line">                    ref = &#123;forwardRef&#125;</div><div class="line">                    /&gt;</div><div class="line">            )</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// react组件</span></div><div class="line">        <span class="keyword">return</span> lastChildElement</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>作用很简单，就是判断 props ref 是否有变化，有变化就返回一个新的组件，没有则返回之前的。这个函数接受的最终版本的 <code>derivedProps</code> 就是由 <code>makeDerivedPropsSelector</code> 确定的。</p>
<h4 id="makeDerivedPropsSelector"><a href="#makeDerivedPropsSelector" class="headerlink" title="makeDerivedPropsSelector"></a>makeDerivedPropsSelector</h4><p>makeDerivedPropsSelector 代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeDerivedPropsSelector</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 闭包储存上一次的执行结果</span></div><div class="line">  <span class="keyword">let</span> lastProps</div><div class="line">  <span class="keyword">let</span> lastState</div><div class="line">  <span class="keyword">let</span> lastDerivedProps</div><div class="line">  <span class="keyword">let</span> lastStore</div><div class="line">  <span class="keyword">let</span> sourceSelector</div><div class="line">  <span class="comment">// storeState props store</span></div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">selectDerivedProps</span>(<span class="params">state, props, store</span>) </span>&#123;</div><div class="line">    <span class="comment">// props和state都和之前相等 直接返回上一次的结果</span></div><div class="line">    <span class="keyword">if</span> (pure &amp;&amp; lastProps === props &amp;&amp; lastState === state) &#123;</div><div class="line">      <span class="keyword">return</span> lastDerivedProps</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 当前store和lastStore不等，更新lastStore</span></div><div class="line">    <span class="keyword">if</span> (store !== lastStore) &#123;</div><div class="line">      lastStore = store</div><div class="line">      </div><div class="line">      <span class="comment">// 终于调用 selectorFactory 了</span></div><div class="line">      sourceSelector = selectorFactory(</div><div class="line">        store.dispatch,</div><div class="line">        selectorFactoryOptions</div><div class="line">      )</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 更新数据</span></div><div class="line">    lastProps = props</div><div class="line">    lastState = state</div><div class="line"></div><div class="line">    <span class="comment">// 返回的就是最终的包含所有相应的 state 和 props 的结果</span></div><div class="line">    <span class="keyword">const</span> nextProps = sourceSelector(state, props)</div><div class="line"></div><div class="line">    <span class="comment">// 最终的比较</span></div><div class="line">    <span class="keyword">if</span> (lastDerivedProps === nextProps) &#123;</div><div class="line">      <span class="keyword">return</span> lastDerivedProps</div><div class="line">    &#125;</div><div class="line">    lastDerivedProps = nextProps</div><div class="line">    <span class="keyword">return</span> lastDerivedProps</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先判断了当前传入的props (组件的props) 和 state (redux store 的state) 跟以前的是否全等，如果全等就不需要更新了；<br>如果不等，则调用高阶函数 <code>selectFactory</code> 得到 <code>sourceSelector</code> 函数，<code>sourceSelector</code> 会将当前 storeState 和 props 合并成一个 props。之后再次判断这个最终 props 和上一次的是否全等。<br>看下 <code>selectFactory</code> 源码：</p>
<h5 id="selectFactory"><a href="#selectFactory" class="headerlink" title="selectFactory"></a>selectFactory</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">finalPropsSelectorFactory</span>(<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">  <span class="regexp">//</span> redux store的store.dispatch</span></span></div><div class="line"><span class="function"><span class="params">  dispatch,</span></span></div><div class="line"><span class="function"><span class="params">  <span class="regexp">//</span> <span class="number">3</span>种已经确定了的处理方法</span></span></div><div class="line"><span class="function"><span class="params">  &#123; initMapStateToProps, initMapDispatchToProps, initMergeProps, ...options &#125;</span></span></div><div class="line"><span class="function"><span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 调用initProxySelector得到proxy function, proxy包含mapToProps, dependsOnOwnProps属性</span></div><div class="line">  <span class="keyword">const</span> mapStateToProps = initMapStateToProps(dispatch, options)</div><div class="line">  <span class="keyword">const</span> mapDispatchToProps = initMapDispatchToProps(dispatch, options)</div><div class="line">  <span class="comment">// mergePropsProxy为function</span></div><div class="line">  <span class="comment">// 返回值为 connect(mapstate,mapdispatch,function mergeProps()&#123;&#125;)()中mergeProps的返回值</span></div><div class="line">  <span class="keyword">const</span> mergeProps = initMergeProps(dispatch, options)</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">    verifySubselectors(</div><div class="line">      mapStateToProps,</div><div class="line">      mapDispatchToProps,</div><div class="line">      mergeProps,</div><div class="line">      options.displayName</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> selectorFactory = options.pure</div><div class="line">    ? pureFinalPropsSelectorFactory</div><div class="line">    : impureFinalPropsSelectorFactory</div><div class="line"></div><div class="line">  <span class="comment">// 默认pure问题true，因此执行 pureFinalPropsSelectorFactory(...)</span></div><div class="line">  <span class="keyword">return</span> selectorFactory(</div><div class="line">    mapStateToProps,</div><div class="line">    mapDispatchToProps,</div><div class="line">    mergeProps,</div><div class="line">    dispatch,</div><div class="line">    options</div><div class="line">  )</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先这里执行了之前封装好的 <code>initProxySelector</code> 函数，返回一个 proxy 函数。</p>
<p>接下来执行 <code>selectorFactory</code> 函数，也就是 <code>pureFinalPropsSelectorFactory</code> 函数 (pure 默认值为 true)。关键代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">pureFinalPropsSelectorFactory</span>(<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">  <span class="regexp">//</span> 接受<span class="number">3</span>个proxy方法</span></span></div><div class="line"><span class="function"><span class="params">  mapStateToProps,</span></span></div><div class="line"><span class="function"><span class="params">  mapDispatchToProps,</span></span></div><div class="line"><span class="function"><span class="params">  mergeProps,</span></span></div><div class="line"><span class="function"><span class="params">  dispatch,</span></span></div><div class="line"><span class="function"><span class="params">  <span class="regexp">//</span> 接受<span class="number">3</span>个比较方法</span></span></div><div class="line"><span class="function"><span class="params">  &#123; areStatesEqual, areOwnPropsEqual, areStatePropsEqual &#125;</span></span></div><div class="line"><span class="function"><span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">/* ...定义变量保存之前的数据(闭包)... */</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleFirstCall</span>(<span class="params">firstState, firstOwnProps</span>) </span>&#123;</div><div class="line">    <span class="comment">/* ...定义第一次执行数据比较的方法，也就是简单的赋值给上面定义的闭包变量... */</span></div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleNewPropsAndNewState</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">/* 当state和props都有变动时的处理方法 */</span></div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleNewProps</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">/* 当state无变动，props有变动时的处理方法 */</span></div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleNewState</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">/* 当state有变动，props无变动时的处理方法 */</span></div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 后续数据比较的方法</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleSubsequentCalls</span>(<span class="params">nextState, nextOwnProps</span>) </span>&#123;</div><div class="line">    <span class="comment">// 浅比较</span></div><div class="line">    <span class="keyword">const</span> propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps)</div><div class="line">    <span class="comment">// 全等比较</span></div><div class="line">    <span class="keyword">const</span> stateChanged = !areStatesEqual(nextState, state)</div><div class="line">    <span class="comment">// 更新数据</span></div><div class="line">    state = nextState</div><div class="line">    ownProps = nextOwnProps</div><div class="line">    <span class="comment">// 当发生不相等的3种情况(关键)</span></div><div class="line">    <span class="keyword">if</span> (propsChanged &amp;&amp; stateChanged) <span class="keyword">return</span> handleNewPropsAndNewState()</div><div class="line">    <span class="keyword">if</span> (propsChanged) <span class="keyword">return</span> handleNewProps()</div><div class="line">    <span class="keyword">if</span> (stateChanged) <span class="keyword">return</span> handleNewState()</div><div class="line">    <span class="comment">// 比较都相等，直接返回旧值</span></div><div class="line">    <span class="keyword">return</span> mergedProps</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">pureFinalPropsSelector</span>(<span class="params">nextState, nextOwnProps</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> hasRunAtLeastOnce</div><div class="line">      ? handleSubsequentCalls(nextState, nextOwnProps)</div><div class="line">      : handleFirstCall(nextState, nextOwnProps)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>pureFinalPropsSelectorFactory</code> 函数返回的就是最外层 <code>sourceSelector</code> 函数。</p>
<p>函数主要是对比 storeState 和组件 props 的数据，并返回合并结果。（在函数 <code>handleSubsequentCalls</code>，其中 <code>areStatesEqual</code> 为严格相等(===)比较。其余比较均为 <code>shallowEqual</code> 浅比较）<br>新老对比分为如下几种情况：</p>
<ol>
<li>storeState 和 props 都相等，直接返回第一次 <code>handleFirstCall</code> 函数执行结果的 mergedProps</li>
</ol>
<p><code>handleFirstCall</code>:<br>必定执行 mapStateToProps(state, ownProps)<br>必定执行 mapDispatchToProps(dispatch, ownProps)<br>合并结果 mergedProps</p>
<ol>
<li>storeState 不等 props 不等</li>
</ol>
<p><code>handleNewPropsAndNewState</code>：<br>必定执行 mapStateToProps(state, ownProps)，因为 state 有变动<br>只有订阅了ownProps，才会执行 <code>mapDispatchToProps</code>，因为 state 变动与 mapDispatchToProps 无影响<br>合并结果 mergedProps</p>
<ol>
<li>storeState 相等 props 不等，执行 <code>handleNewProps</code>：</li>
</ol>
<p><code>handleNewProps</code>：<br>只有订阅了ownProps，才会执行 <code>mapStateToProps</code>， 因为 state 无变动。<br>只有订阅了ownProps，才会执行 <code>mapDispatchToProps</code>，因为 state 变动与 mapDispatchToProps 无影响。<br>合并结果 mergedProps</p>
<ol>
<li>storeState 不等，props 相等</li>
</ol>
<p><code>handleNewState</code>：<br>必定执行 mapStateToProps(state, ownProps)<br>对新的 stateProps 与上一次结果做浅比较判断，浅比较失败才重新计算 mergedProps，否则返回旧的结果。（就相当月 PureComponent 优化了）。</p>
<p>(第 4 种和第 1 种差别就在于 props 和 state 一旦同时变化就注定要更新组件)。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>react-redux 核心就这么多。其本质就是利用 context 连接 store 和 react。通过 connect 来决定哪儿些组件需要响应 redux 的数据流变化，并做了通用的方案做优化。<br>这里借鉴一张导图：</p>
<img src="/2019/02/01/redux源码理解2/a2.png" alt="a2.png" title=""> 
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.jianshu.com/p/d80ab5e105a9" target="_blank" rel="external">[源码阅读] 高性能和可扩展的React-Redux</a></li>
<li><a href="https://github.com/hufeng/iThink/issues/4" target="_blank" rel="external">为什么我的this.props.children不能re-render</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前的文章我们讲解了数据流的作用，还有 redux 的源码。现在思考，如何将 redux 应用到 react 上面呢？&lt;br&gt;首先我们想到 store 可能被多个组件依赖和影响，为此我们应当借助 &lt;code&gt;context&lt;/code&gt; 来存储 store 数据。将 store 存储在根元素上，通过 context 进行数据的传递。为了实现这一步，react-redux 提供了 &lt;code&gt;&amp;lt;Provider&amp;gt;&lt;/code&gt;：&lt;/p&gt;
    
    </summary>
    
      <category term="前端源码解析" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="redux" scheme="http://yoursite.com/tags/redux/"/>
    
      <category term="前端源码解析" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>redux 深入探究</title>
    <link href="http://yoursite.com/2019/01/26/redux%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2019/01/26/redux源码解析/</id>
    <published>2019-01-26T08:27:05.000Z</published>
    <updated>2019-04-16T06:14:28.683Z</updated>
    
    <content type="html"><![CDATA[<p>redux 的思想前面已经介绍过了。本文主要简单的看下，redux 的具体实现。redux 主要提供了如下几个功能： </p>
<ul>
<li>创建 store，即：createStore()。</li>
<li>创建出来的 store 提供subscribe，dispatch，getState这些方法。</li>
<li>将多个reducer合并为一个reducer，即：combineReducers()。</li>
<li>应用中间件，即applyMiddleware()。</li>
</ul>
<a id="more"></a>
<h2 id="createStore-实现"><a href="#createStore-实现" class="headerlink" title="createStore 实现"></a>createStore 实现</h2><p>简化版代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer, preloadedState, enhancer</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> currentReducer = reducer <span class="comment">// reducer</span></div><div class="line">    <span class="keyword">let</span> currentState = preloadedState <span class="comment">// 默认 state</span></div><div class="line">    <span class="keyword">let</span> currentListeners = [] <span class="comment">// 发布订阅模式队列</span></div><div class="line">    <span class="keyword">let</span> nextListeners = currentListeners <span class="comment">// 浅拷贝下这个队列</span></div><div class="line">    <span class="keyword">let</span> isDispatching = <span class="literal">false</span> <span class="comment">// isDispatching 标志是否正在执行dispatch</span></div><div class="line"></div><div class="line">    <span class="comment">// @enhancer</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'undefined'</span>) &#123;</div><div class="line">        <span class="comment">// 如果enhancer存在，那他必须是个function, 否则throw Error哈</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'function'</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the enhancer to be a function.'</span>)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> enhancer(createStore)(reducer, preloadedState)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// @1</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getState</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// 为了确保state的正确性(获取最新的state)，判断是否正在 dispatch</span></div><div class="line">        <span class="keyword">if</span> (isDispatching) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(.../);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 确定currentState是当前的state 看 -&gt; subscribe</span></div><div class="line">        <span class="keyword">return</span> currentState</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// @2</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">listener</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (isDispatching) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(.../);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">let</span> isSubscribed = <span class="literal">true</span>;</div><div class="line">        <span class="comment">// 如果，nextListeners 和 currentListeners 是一个引用，就拷贝 currentListeners 给 nextListeners</span></div><div class="line">        ensureCanMutateNextListeners()</div><div class="line">        <span class="comment">// 添加一个订阅函数</span></div><div class="line">        nextListeners.push(listener)</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unsubscribe</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span> (!isSubscribed) &#123;</div><div class="line">                <span class="comment">// 没有直接订阅 则 return</span></div><div class="line">                <span class="keyword">return</span></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 同理</span></div><div class="line">            <span class="keyword">if</span> (isDispatching) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">''</span>)</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 取消订阅</span></div><div class="line">            isSubscribed = <span class="literal">false</span></div><div class="line">            <span class="comment">// 保存订阅快照</span></div><div class="line">            ensureCanMutateNextListeners()</div><div class="line">            <span class="comment">// 找到并删除当前的listener</span></div><div class="line">            <span class="keyword">const</span> index = nextListeners.indexOf(listener)</div><div class="line">            nextListeners.splice(index, <span class="number">1</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// @3</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</div><div class="line">        <span class="comment">// 各种常规判断</span></div><div class="line">        ...</div><div class="line">        <span class="comment">// dispatch中不可以有进行的dispatch</span></div><div class="line">        <span class="keyword">if</span> (isDispatching) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Reducers may not dispatch actions.'</span>)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 执行时标记为true</span></div><div class="line">            isDispatching = <span class="literal">true</span></div><div class="line">            <span class="comment">// 执行reducer</span></div><div class="line">            currentState = currentReducer(currentState, action)</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="comment">// 最终执行， isDispatching标记为false， 即完成状态</span></div><div class="line">            isDispatching = <span class="literal">false</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 执行所有监听队列</span></div><div class="line">        <span class="keyword">const</span> listeners = (currentListeners = nextListeners)</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; listeners.length; i++) &#123;</div><div class="line">            <span class="keyword">const</span> listener = listeners[i]</div><div class="line">            <span class="comment">// 执行每一个监听函数</span></div><div class="line">            listener()</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 返回传入的action</span></div><div class="line">        <span class="keyword">return</span> action</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 初始化数据</span></div><div class="line">    dispatch(&#123;</div><div class="line">        type: ActionTypes.INIT</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        dispatch,</div><div class="line">        subscribe,</div><div class="line">        getState,</div><div class="line">        replaceReducer,</div><div class="line">        [$$observable]: observable</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="getState"><a href="#getState" class="headerlink" title="getState"></a>getState</h3><p>可以看出，createStore 将 state 通过闭包保存在了 currentState 中，通过调用 getState 返回。为了能够初始化数据，在 createStore 的最后，dispath 了一个 <code>ActionTypes.INIT</code> 请求。在这里 <code>ActionTypes.INIT</code> 实际上为一个随机字符串 <code>@@redux/INIT${randomString()}</code>，这就保证了其不会命中任何 <code>action</code>，而是走默认 <code>return state</code> 完成数据初始化过程。</p>
<h3 id="subscribe"><a href="#subscribe" class="headerlink" title="subscribe"></a>subscribe</h3><p>一个简单的发布订阅模式，所有注册函数保存在 newListeners (执行的时候，会用 currentListeners) 队列中。返回一个 unsubscribe 来清除注册函数。</p>
<h3 id="dispatch"><a href="#dispatch" class="headerlink" title="dispatch"></a>dispatch</h3><p>直接调用 reducer 函数来进行处理，并且执行所有的 listeners。可以看见整个过程都是同步的，这也是 redux 不能在 reducer 中书写异步的原因之一(最主要的还是因为纯函数，不能涉及IO)。<br>这里 dispatch 对参数 action 做了检查：action 必须是一个纯对象，且必须有 type 属性。</p>
<h2 id="combinReducers"><a href="#combinReducers" class="headerlink" title="combinReducers"></a>combinReducers</h2><p>combinReducers 可以将多个 reducers 合并在成为一个 reducers，从而给 createStore 使用。简单的用法如下。简单来说就是讲，各个 reducer 上的 state 统一管理在一个 key 值上，action 判断都统一放在一起。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">combineReducers(&#123;</div><div class="line">    key1: reducer1,</div><div class="line">    key2: reducer2</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">combineReducers</span>(<span class="params">reducers</span>) </span>&#123;</div><div class="line">    <span class="comment">// 先获取传入reducers对象的所有key</span></div><div class="line">    <span class="keyword">const</span> reducerKeys = <span class="built_in">Object</span>.keys(reducers)</div><div class="line">    <span class="comment">// 最后真正有效的reducer存在这里</span></div><div class="line">    <span class="keyword">const</span> finalReducers = &#123;&#125; </div><div class="line">    </div><div class="line">    <span class="comment">// 下面从reducers中筛选出有效的reducer</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; reducerKeys.length; i++)&#123;</div><div class="line">        <span class="keyword">const</span> key  = reducerKeys[i]</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> reducers[key] === <span class="string">'function'</span>) &#123;</div><div class="line">            finalReducers[key] = reducers[key] </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 有效的 key</span></div><div class="line">    <span class="keyword">const</span> finalReducerKeys = <span class="built_in">Object</span>.keys(finalReducers);</div><div class="line">    </div><div class="line">    <span class="keyword">let</span> shapeAssertionError</div><div class="line">  	<span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 检查finalReducer中的reducer接受一个初始action或一个未知的action时，是否依旧能够返回有效的值。</span></div><div class="line">    	assertReducerShape(finalReducers)</div><div class="line">  	&#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">    	shapeAssertionError = e</div><div class="line">  	&#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 返回合并后的reducer</span></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">combination</span>(<span class="params">state= &#123;&#125;, action</span>)</span>&#123;</div><div class="line">    	<span class="comment">// 取得每个子reducer对应的state，与action一起作为参数给每个子reducer执行。</span></div><div class="line">    	<span class="keyword">let</span> hasChanged = <span class="literal">false</span> <span class="comment">//标志state是否有变化</span></div><div class="line">        <span class="keyword">let</span> nextState = &#123;&#125;</div><div class="line">        <span class="comment">// 执行所有的子 reducer </span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; finalReducerKeys.length; i++) &#123;</div><div class="line">            <span class="keyword">const</span> key = finalReducerKeys[i]</div><div class="line">            <span class="keyword">const</span> reducer = finalReducers[key]</div><div class="line">            <span class="comment">// 当前key的state值</span></div><div class="line">            <span class="keyword">const</span> previousStateForKey = state[key]</div><div class="line">            <span class="comment">// 执行reducer， 返回当前state</span></div><div class="line">            <span class="keyword">const</span> nextStateForKey = reducer(previousStateForKey, action)</div><div class="line">            <span class="comment">//存到nextState中（总的状态）</span></div><div class="line">            nextState[key] = nextStateForKey</div><div class="line">            <span class="comment">// 如果子reducer不能处理该action，那么会返回previousStateForKey</span></div><div class="line">            hasChanged = hasChanged || previousStateForKey !== nextStateForKey</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 当所有状态都没改变时，我们直接返回之前的state就可以了。</span></div><div class="line">        <span class="keyword">return</span> hasChanged ? nextState : state</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们可以看见，融合后的 reducer 当一个 action 触发时，不仅仅是该 action 对应的 reducer 执行了，其他所有的 reducer 也同时被执行了，只是 action type 不匹配，state 的值不变而已。这种空操作，可能会存在性能的浪费。(理论上大部分都不会有问题，只有节点数量多了才会有，最重要的优化是：没问题之前不做优化)<br>我们可以借助 redux-ignore 来指定黑白名单的方式，返回优化后的 reducer。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; ignoreActions, filterActions &#125; <span class="keyword">from</span> <span class="string">'redux-ignore'</span>;</div><div class="line"> </div><div class="line"><span class="comment">// 黑名单写法</span></div><div class="line">ignoreActions(reducer, [ARRAY_OF_ACTIONS])</div><div class="line">ignoreActions(reducer, (action) =&gt; !action.valid)</div><div class="line"></div><div class="line"><span class="comment">// 白名单写法</span></div><div class="line">filterActions(reducer, [ARRAY_OF_ACTIONS])</div><div class="line">filterActions(reducer, (action) =&gt; action.valid)</div></pre></td></tr></table></figure>
<p>原理也很简单，就是利用  actions.indexOf(action.type) &gt;= 0 来决定 reducer 是否触发而已。</p>
<h2 id="applyMiddleware-中间件"><a href="#applyMiddleware-中间件" class="headerlink" title="applyMiddleware 中间件"></a>applyMiddleware 中间件</h2><p>我们知道 reducer 本身是一个纯函数，纯函数要求自身不能和 IO 产生关联。这也就注定 reducer 本身是一个同步函数。同样，我们在 <code>store.dispath</code> 源码中看见，当一个 dispath 发出后，所有的监听回调也就同步发生了。<br>在实际业务中，我们的请求一般都是异步的，那么做异步请求处理就只能放在 dispatch 前来做。所以我们希望有一种通用的方案，来扩展 dispath 的功能。这就是中间件的功能。下面我们思考因该如何来做一个中间件：</p>
<h3 id="封装-dispath"><a href="#封装-dispath" class="headerlink" title="封装 dispath"></a>封装 dispath</h3><p>加入我们想要加入一个 dispath 前后记录日志的功能。我们可能会这么写 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">'action 触发前'</span>);</div><div class="line">store.dispath(action);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'action 触发完毕'</span>);</div></pre></td></tr></table></figure>
<p>为了方便复用，我们扩展其为一个函数： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchAndLog</span>(<span class="params">store, action</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'action 触发: '</span>, action.type);</div><div class="line">    store.dispatch(action);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'action 触发完毕'</span>, store.getState());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="重写-dispatch"><a href="#重写-dispatch" class="headerlink" title="重写 dispatch"></a>重写 dispatch</h3><p>现在我们可以通过调用 <code>dispatchAndLog</code> 来完成带有日志的 dispath。日志记录功能可以直接反映到 dispath 上面，不改变原有的用法，更直接些。通过复写 dispath 来实现扩展：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 保存 dispath 副本</span></div><div class="line"><span class="keyword">let</span> next = store.dispatch;</div><div class="line">store.diapatch = <span class="function"><span class="keyword">function</span> (<span class="params">store, action</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'action 触发: '</span>, action.type);</div><div class="line">    <span class="keyword">let</span> result = next(action);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'action 触发完毕'</span>, store.getState());</div><div class="line">    <span class="comment">// 返回 action</span></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们随便使用 dispath 就可以实现日志的打印，而不用费事的去使用 <code>dispatchAndLog</code> 函数。</p>
<h3 id="新的扩展"><a href="#新的扩展" class="headerlink" title="新的扩展"></a>新的扩展</h3><p>实际开发中，我们可能不仅需要日志功能，还有可能需要其他的扩展功能。比如异常上报。为此我们需要将上述操作写成两个函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extendsLogFunc</span>(<span class="params">store, action</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> next = store.dispatch;</div><div class="line">    store.diapatch = <span class="function"><span class="keyword">function</span> (<span class="params">store, action</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'action 触发: '</span>, action.type);</div><div class="line">        <span class="keyword">let</span> result = next(action);</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'action 触发完毕'</span>, store.getState());</div><div class="line">        <span class="comment">// 返回 action</span></div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extendsErrorPublish</span>(<span class="params">store, action</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> next = store.dispatch;</div><div class="line">    store.diapatch = <span class="function"><span class="keyword">function</span> (<span class="params">store, action</span>) </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">return</span> next(action)</div><div class="line">        &#125; <span class="keyword">catch</span>(e) &#123;</div><div class="line">            <span class="comment">// 错误处理</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用两个扩展：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">extendsLogFunc(store, aciton);</div><div class="line">extendsErrorPublish(store, action);</div></pre></td></tr></table></figure>
<h3 id="middleware-方法"><a href="#middleware-方法" class="headerlink" title="middleware 方法"></a>middleware 方法</h3><p>从上面，我们可以看出，其实扩展多个中间件，就是复写多次 <code>store.dispatch</code> 方法。每次 next 缓存的都是上一个中间件替换好的 dispatch 方法。即如下链式调用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">next(next(next(...args)))</div></pre></td></tr></table></figure>
<p>即洋葱模型。我们提供这样一个封装函数，来实现这一模型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params">store, middleswares</span>) </span>&#123;</div><div class="line">    middlewares = middlewares.slice();</div><div class="line">    <span class="comment">// 翻转是为了实现从内向外逐步执行</span></div><div class="line">    middlewares.reverse();</div><div class="line">    middlewares.forEach(<span class="function"><span class="params">middleware</span> =&gt;</span></div><div class="line">        store.dispatch = middleware(store);</div><div class="line">    )</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对 <code>extendsLogFunc</code> 稍作改动(extendsErrorPublish， 同理) </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extendsLogFunc</span>(<span class="params">store</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> next = store.dispatch;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">action</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'action 触发: '</span>, action.type);</div><div class="line">        <span class="keyword">let</span> result = next(action);</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'action 触发完毕'</span>, store.getState());</div><div class="line">        <span class="comment">// 返回 action</span></div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就可以使用了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">applyMiddleware(store, [extendsLogFunc, extendsErrorPublish])</div></pre></td></tr></table></figure>
<h3 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h3><p>我们观察改动后的 extendsLogFunc。无非就是层层准备参数，最后一起使用，这样我们很容易想到函数柯里化：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> extendsLogFunc = <span class="function"><span class="params">store</span> =&gt;</span> next =&gt; <span class="function"><span class="params">action</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'action 触发: '</span>, action.type);</div><div class="line">    <span class="keyword">let</span> result = next(action);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'action 触发完毕'</span>, store.getState());</div><div class="line">    <span class="comment">// 返回 action</span></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了能顺利运行，我们也需要晒微修改下 applyMiddleware，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params">store, middlewares</span>) </span>&#123;</div><div class="line">    middlewares = middlewares.slice();</div><div class="line">    middlewares.reverse();</div><div class="line">    <span class="keyword">let</span> dispatch = store.dispath;</div><div class="line">    middlewares.forEach(<span class="function"><span class="params">middleware</span> =&gt;</span></div><div class="line">        dispatch = middleware(store)(dispatch);</div><div class="line">    )</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们再看，createStore 的源码，如果我们传入了第三个参数 enhancer 作为中间件，那么调用的是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> enhancer(createStore)(reducer, preloadedState)</div></pre></td></tr></table></figure>
<p>典型的柯里化调用，为此，我们最后修改下 <code>applyMiddleware</code> 函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params">middlewares</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">createStore</span>) =&gt;</span> (reducer, preloadedState) =&gt; &#123;</div><div class="line">        <span class="keyword">const</span> stores = createStore(reducer, preloadedState);</div><div class="line">        <span class="keyword">let</span> dispatch = store.dispath;</div><div class="line">        middlewares = middlewares.slice();</div><div class="line">        middlewares.reverse();</div><div class="line">        middlewares.forEach(<span class="function"><span class="params">middleware</span> =&gt;</span></div><div class="line">            dispatch = middleware(store)(dispatch);</div><div class="line">        )</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.assing(&#123;&#125;, store, &#123;dispath&#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="string">``</span><span class="string">` </span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">这样，我们就完成了，使用如下：</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">`</span><span class="string">``</span>javascript</div><div class="line"><span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">'redux'</span></div><div class="line"><span class="keyword">let</span> store = createStore(reducers, applyMiddleware([extendsLogFunc, extendsErrorPublish]));</div></pre></td></tr></table></figure>
<h3 id="看下源码"><a href="#看下源码" class="headerlink" title="看下源码"></a>看下源码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params">...middlewares</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="params">createStore</span> =&gt;</span> (...args) =&gt; &#123;</div><div class="line">    <span class="keyword">const</span> store = createStore(...args)</div><div class="line">    <span class="keyword">let</span> dispatch = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</div><div class="line">        <span class="string">`Dispatching while constructing your middleware is not allowed. `</span> +</div><div class="line">          <span class="string">`Other middleware would not be applied to this dispatch.`</span></div><div class="line">      )</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">const</span> middlewareAPI = &#123;</div><div class="line">      getState: store.getState,</div><div class="line">      dispatch: <span class="function">(<span class="params">...args</span>) =&gt;</span> dispatch(...args)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">const</span> chain = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(middlewareAPI))</div><div class="line">    <span class="comment">// 实现洋葱模型</span></div><div class="line">    dispatch = compose(...chain)(store.dispatch) </div><div class="line">    <span class="comment">// 返回增强的store</span></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      ...store,</div><div class="line">      dispatch</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和我们的书写思路差不多吧，在源码里，通过 compose 方法，来实现的洋葱模型；compose 函数式编程中用来复合代码的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funcs</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (funcs.length === <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (funcs.length === <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> funcs[<span class="number">0</span>]</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> funcs.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> (...args) =&gt; a(b(...args)))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在搭配 react 的时候，我们通常不会直接使用 <code>redux</code> 因为这样需要关注的优化点就有点多。通常情况下，我们会选择 <code>react-redux</code> 来完成和 react 的结合。下篇文章着重介绍下，<code>react-redux</code> 源码，并针对 redux 可能带来的性能问题进行说明。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;redux 的思想前面已经介绍过了。本文主要简单的看下，redux 的具体实现。redux 主要提供了如下几个功能： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建 store，即：createStore()。&lt;/li&gt;
&lt;li&gt;创建出来的 store 提供subscribe，dispatch，getState这些方法。&lt;/li&gt;
&lt;li&gt;将多个reducer合并为一个reducer，即：combineReducers()。&lt;/li&gt;
&lt;li&gt;应用中间件，即applyMiddleware()。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="前端源码解析" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="redux" scheme="http://yoursite.com/tags/redux/"/>
    
      <category term="前端源码解析" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>前端数据流管理</title>
    <link href="http://yoursite.com/2019/01/02/react%E6%95%B0%E6%8D%AE%E6%B5%81%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2019/01/02/react数据流管理/</id>
    <published>2019-01-02T06:19:28.000Z</published>
    <updated>2019-03-26T08:26:17.930Z</updated>
    
    <content type="html"><![CDATA[<p>react 的范式为 <code>UI = render(state)</code>，用户的界面完全取决于数据层。react 中通过管理状态（state）来实现对组件的管理，当 state 发生变更后，react 就会重新渲染界面，组件与组件之间也经常需要共享状态。如果缺乏一个好的状态管理方案，那么共享数据将变得麻烦，同时状态不受控的话会让我们很难跟踪调试程序。</p>
<a id="more"></a>
<p>react 本身采用的时自上而下的单向组件数据流，我们通常将代码抽成 Smart Component 组件和 Dumb Component 组件。通过 proprs 来连接，来完成功能。针对小的项目，这就足够了，但是项目大了以后会出现如下几个问题：</p>
<ol>
<li>如何跨组件实现状态同步<br>react 16 提供新的的 context 可以解决这一问题，但是 context 一般会放顶级组件上，一旦有改变将触发所有组件的re-render，这将带来损耗。</li>
<li>如何让状态变得可预知，甚至可回溯</li>
<li>如何避免组件臃肿，Model 和 View 都混在了一起</li>
</ol>
<p>为此前端提出了一个通用解决思路：把组件之间需要共享的状态抽取出来，遵循特定的约定，统一来管理，让状态的变化可以预测。针对这个思路，我们来看下都有哪些实现。 (隔离变化，约定大于配置，其实不管是 Vue，还是 React 都对其状态管理有着同样的要求)</p>
<h2 id="单向数据流体系"><a href="#单向数据流体系" class="headerlink" title="单向数据流体系"></a>单向数据流体系</h2><h3 id="Store-模式"><a href="#Store-模式" class="headerlink" title="Store 模式"></a>Store 模式</h3><p>我们将状态存在一个全局变量 <code>store</code> 里面，store 里面设置一些方法来控制 state 的改变。<br><code>约定</code>：组件只能通过调用 store 上的方法来改变数据，而不能直接操作 store 里面的 state。这样就保证了数据的可追溯。 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> store = &#123;</div><div class="line">    state: &#123;</div><div class="line">        data: &#123;&#125;</div><div class="line">    &#125;,</div><div class="line">    setDataAction(newValue) &#123;</div><div class="line">        <span class="keyword">this</span>.state.data = newValue;</div><div class="line">    &#125;,</div><div class="line">    clearDataAction() &#123;</div><div class="line">        <span class="keyword">this</span>.state.data = &#123;&#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>进一步，为了方便管理 view 层调用相应的 store 方法，我们包装一个 <code>dispatcher</code> 来映射 view 层的一个动作 action 到 store 上。这样一个 flux 架构就诞生了。</p>
<h3 id="Flux"><a href="#Flux" class="headerlink" title="Flux"></a>Flux</h3><p>Flux 本身是一种思想，一种约定。Flux 把一个应用分成 4 个部分：View, Action, Dispatcher, Store</p>
<img src="/2019/01/02/react数据流管理/a3.png" alt="a3.png" title="">   
<p>View 层用来展示数据，当用户操作UI上的某个操作，就会触发 Dispatcher。<br>Dispatcher 就像一个请求中转站一样会 dispatch 一个 action 给 Store。Store 根据这个 action 来改变数据。当然 Action 也可以由其他地方触发。<br>一旦 Store 发生了变化，就会往外面发送一个事件，比如 change，来通知所有的订阅者。View 会监听这个事件，从而触发自身的 re-render。（实现：发布订阅模式）<br>Dispatcher 的作用是接收所有的 Action，然后发给所有的 Store。 Store 的改变只能通过 Action，不能通过其他方式。</p>
<p>改写上面的例子：</p>
<p>store 部分加入发布订阅</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> store = assign((), EventEmitter.prototype, store, &#123;</div><div class="line">    emitChange: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.emit(<span class="string">'change'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>Dispatcher 部分</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'../store'</span>;</div><div class="line"></div><div class="line">AppDispatcher.regiseter(<span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">switch</span>(action.type) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">'setData'</span>:</div><div class="line">            store.setData(action.data);</div><div class="line">            <span class="comment">// 触发变更</span></div><div class="line">            store.emitChange();</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="string">'clear'</span>:</div><div class="line">            store.clearData();</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>View 层</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'../store'</span>;</div><div class="line"><span class="keyword">import</span> AppDispatcher <span class="keyword">from</span> <span class="string">'...'</span>;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">    componentDidMount: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        store.addChangeListener(<span class="keyword">this</span>._onChange);</div><div class="line">    &#125;</div><div class="line">    componentWillUnmount: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        store.removeChangeListener(<span class="keyword">this</span>._onChange);</div><div class="line">    &#125;</div><div class="line">    _onChange: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">this</span>.setState(&#123;</div><div class="line">            items: ListStore.getAll()</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    handleClick: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        AppDispatcher(&#123;</div><div class="line">            type: <span class="string">'setData'</span>,</div><div class="line">            data: data</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    render() &#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，Flux 核心思想就是数据都是单向流动的。<br>Flux 本身会有很多个 store 来存储引用数据，并在各自的 store 里面执行更新逻辑。那么当多个store之间有依赖关系的时候，就不太好处理。同时 store 里面不仅封装了数据，还有处理数据的逻辑。</p>
<h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h3><p>在 Flux 的基础上，Redux 对其进行了一些改进增强。  </p>
<img src="/2019/01/02/react数据流管理/a4.png" alt="a4.png" title=""> 
<p>在 Redux 中没有 Dispatcher 的概念，它使用 reducer 来进行事件处理。<br>reducer 是一个纯函数，每个 reducer 负责维护应用整体 state 树中的某一部分，多个 reducer 可以通过 combineReducers 方法合成一个根reducer，这个根reducer负责维护完整的 state。<br><code>约定</code>: reducer 必须为纯函数（此函数在相同的输入值时，需产生相同的输出。函数的输出和输入值以外的其他隐藏信息或状态无关，也和由I/O 设备产生的外部输出无关，例如 Ajax）。<br>由于有这样的规定，redux 成功副作用隔离。我们很容易判断出数据的变化的原因，数据流清晰可回朔。同时 Redux 引入的 immutable 进一步隔离了对象引用的问题。</p>
<h4 id="对比-Flux"><a href="#对比-Flux" class="headerlink" title="对比 Flux"></a>对比 Flux</h4><p>Redux 和 Flux 之间最大的区别就是对 store/reducer 的抽象，Flux 中 store 是各自为战的，每个 store 只对对应的 controller-view 负责，每次更新都只通知对应的 controller-view；而 Redux 中各子 reducer 都是由根reducer统一管理的，每个子reducer的变化都要经过根reducer的整合。</p>
<img src="/2019/01/02/react数据流管理/a5.png" alt="a5.png" title=""> 
<p>综上：Redux有三大原则：</p>
<ol>
<li>单一数据源：Flux 的数据源可以是多个。 </li>
<li>State 是只读的：Flux 的 State 可以随便改。</li>
<li>使用纯函数来执行修改：Flux 执行修改的不一定是纯函数。</li>
</ol>
<h4 id="Redux-异步"><a href="#Redux-异步" class="headerlink" title="Redux 异步"></a>Redux 异步</h4><p>在 Redux 中，每当我们发出一个 Action，Reducer 就会立即算出 State。那么我们想支持异步呢？在哪儿加入异步操作呢？<br>Reducer ？ 纯函数，不能引入IO，不适合。Action ? 一个纯对象，没有位置。所以只能通过包装 dispatch 加上中间件的动能。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> next = store.dispatch;</div><div class="line">store.dispatch = <span class="function"><span class="keyword">function</span> <span class="title">dispatchAndLog</span>(<span class="params">action</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'dispatching'</span>, action);</div><div class="line">    next(action);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'next state'</span>, store.getState());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Redux 提供了一个 applyMiddleware 方法来应用中间件：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = createStore(</div><div class="line">    reducer,</div><div class="line">    applyMiddleware(thunk, promise, logger)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>这个方法主要就是把所有的中间件组成一个数组，依次执行。也就是说，任何被发送到 store 的 action 现在都会经过thunk，promise，logger 这几个中间件了。</p>
<p>关于 Redux 的异步处理，之后会有单独解析 redux-sage 的内容。</p>
<h2 id="Mobx"><a href="#Mobx" class="headerlink" title="Mobx"></a>Mobx</h2><p>之前说的都是单项数据流方案，思想主要就是函数是编程（FP）的思想。Mobx 则是一个 TFRP 的框架，FRP 的一个分支。</p>
<img src="/2019/01/02/react数据流管理/flow.png" alt="flow.png" title="">   
<p>mobx的流程图如上，通常是：触发action，在action中修改state，通过computed拿到state的计算值，自动触发对应的reactions，这里包含autorun，渲染视图等。有一点需要注意：相对于react来说，mobx没有一个全局的状态树，状态分散在各个独立的 store 中。这种自动订阅，自动发布的模式，使得开发十分方便。<br>但是相对的，mobx 中并没有解决副作用问题，同时，对 props 的直接修改，也会导致与 react 对 props 的不可变定义冲突。因此 mobx 后来给出了 action 解决方案，解决了与 react props 的冲突，但是没有解决副作用未强制分离的问题。  </p>
<p>对比一下：</p>
<ol>
<li>redux 采用全局单一 store，mobx 则由多个独立 store 组成</li>
<li>redux 通过 action 将副作用隔离在 reducer 之外。而 mobx 比较自由，没有对副作用进行处理。</li>
<li>redux 函数式、不可变、模式化；mobx 响应式、依赖追踪</li>
<li>redux 开发需要些很多样板代码，但是调试数据的时候确很方便。mobx 书写简单，但是没有强约束换来的是调试困难。</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651231366&amp;idx=1&amp;sn=0e322d1fb0b59710aae98fe9df7d00ae&amp;chksm=bd494d028a3ec414ccda32e03f8a794372cdb1ab614c06f60526571623dd462653813d5bc230&amp;xtrack=1&amp;scene=0&amp;subscene=131&amp;clicktime=1552304245&amp;ascene=7&amp;devicetype=android-28&amp;version=2700033b&amp;nettype=3gnet&amp;abtest_cookie=BAABAAoACwASABMABQAjlx4AVpkeAMyZHgDamR4A3JkeAAAA&amp;lang=zh_CN&amp;pass_ticket=YbTwrdgEkkcGf%252BH838CvWRFJH9PYUZn90NpiCUOidTcTbXee%252B5bgEwAXKl6tBRd7&amp;wx_header=1" target="_blank" rel="external">Vuex、Flux、Redux、Redux-saga、Dva、MobX</a></li>
<li><a href="https://github.com/dt-fe/weekly/blob/master/42.%E7%B2%BE%E8%AF%BB%E3%80%8A%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E6%B5%81%E5%93%B2%E5%AD%A6%E3%80%8B.md" target="_blank" rel="external">精读《前端数据流哲学》</a></li>
<li><a href="https://imweb.io/topic/57711e37f0a5487b05f325b5" target="_blank" rel="external">浅谈 React、Flux 与 Redux</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;react 的范式为 &lt;code&gt;UI = render(state)&lt;/code&gt;，用户的界面完全取决于数据层。react 中通过管理状态（state）来实现对组件的管理，当 state 发生变更后，react 就会重新渲染界面，组件与组件之间也经常需要共享状态。如果缺乏一个好的状态管理方案，那么共享数据将变得麻烦，同时状态不受控的话会让我们很难跟踪调试程序。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
      <category term="redux" scheme="http://yoursite.com/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>React 组件复用和组合 (二)</title>
    <link href="http://yoursite.com/2018/12/05/React%E7%BB%84%E4%BB%B6%E5%A4%8D%E7%94%A8%E5%92%8C%E7%BB%84%E5%90%882/"/>
    <id>http://yoursite.com/2018/12/05/React组件复用和组合2/</id>
    <published>2018-12-05T09:27:12.000Z</published>
    <updated>2019-04-02T03:17:49.099Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章，我们介绍了高阶组件(HOC)，最后也提出了几个关于高阶组件的问题。这里我们接上另一种组件复用模式 <code>render props</code> 亦或是 <code>funtion as child</code>。</p>
<h2 id="render-props"><a href="#render-props" class="headerlink" title="render props"></a>render props</h2><p>本质上，render props 就是在原有的组件上增加一个 prop 来实现不同的渲染情况，从而达到代码复用的目的(即将组件组件做为参数)。举例如下：</p>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareStateComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">    state = &#123;...&#125;;</div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;div&gt;&#123;<span class="keyword">this</span>.props.render(<span class="keyword">this</span>.state)&#125;&lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">        );</span></div><div class="line"><span class="regexp">    &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ 使用</span></div><div class="line"><span class="regexp">class App extends React.Component &#123;</span></div><div class="line"><span class="regexp">    render() &#123;</span></div><div class="line"><span class="regexp">        &lt;ShareStateComponent </span></div><div class="line"><span class="regexp">            render = &#123;</span></div><div class="line"><span class="regexp">                (state) =&gt; &#123;</span></div><div class="line"><span class="regexp">                    &lt;span&gt;数据：&#123;...state&#125;&lt;/</span>span&gt;</div><div class="line">                &#125;</div><div class="line">            &#125;/&gt;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>StareStateComponent 内部维护了一些可复用的功能，在实例化时，通过调用名为 render 的 prop 属性函数实现了不同组件的渲染。换个更直观的方案，我们可以直接利用 <code>this.props.children</code> ，通过执行 this.props.children 方法，来传递必要的参数，从而实现基于共享数据的不同渲染逻辑，达到复用的目的。这种用法在 <code>React Motion</code>, <code>React Router</code> 里都有采用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">render (</div><div class="line">    &lt;RenderProps1&gt;</div><div class="line">        &#123;(data1) =&gt; (</div><div class="line">            &lt;div&gt;</div><div class="line">                &#123;data1&#125;  </div><div class="line">                &lt;RenderProps2&gt;</div><div class="line">                    &#123;(data2) =&gt; &#123;</div><div class="line">                        &lt;RenderProps3&gt;</div><div class="line">                            (&#123;data3&#125; =&gt; &#123;</div><div class="line">                                &lt;div&gt;&#123;data2&#125;, &#123;data3&#125;&lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">                            &#125;)</span></div><div class="line"><span class="regexp">                        &lt;/</span>RenderProps3&gt;</div><div class="line">                    &#125;&#125;</div><div class="line">                &lt;<span class="regexp">/RenderProps2&gt;       </span></div><div class="line"><span class="regexp">            &lt;/</span>div&gt;</div><div class="line">        )&#125;</div><div class="line">    &lt;<span class="regexp">/RenderProps1&gt;</span></div><div class="line"><span class="regexp">)</span></div></pre></td></tr></table></figure>
<p>通过上面的代码，我们可以看到相比高阶组件，render props 的方案，我们更能直观的观察到数据的流动，从而解决了高阶组件的嵌套问题。与高阶组件相比，render props 的开放性得到提升，原本 HOC 所做的功能抽象可以通过 render props 获取，render 方式还可以直接访问父级的一切内容：  </p>
<img src="/2018/12/05/React组件复用和组合2/a2.png" alt="a2.png" title="">
<h3 id="render-props-存在的问题"><a href="#render-props-存在的问题" class="headerlink" title="render props 存在的问题"></a>render props 存在的问题</h3><p>render props 带来的优点：</p>
<ol>
<li>不用担心props命名问题，在render函数中只取需要的state，数据流动更加直观</li>
<li>不会产生无用的组件加深层级</li>
<li>render props模式的构建都是动态的，所有的改变都在render中触发，可以更好的利用组件内的生命周期。</li>
<li>能够直接访问父组件的内容，开发性更高</li>
</ol>
<p>但 render props 也有一些不能忽视的问题：</p>
<ol>
<li>this.props.children 被重新定义为函数是否合适</li>
<li>渲染粒度变大，如果在属性中定义函数，浅比较下 prop 的值永远是新的，每次都将重新生成新的 prop，这将导致 React.PureComponent 不起作用</li>
<li>renderProps 渲染的并不是 React 组件，无法为其单独使用 redux，mobx</li>
<li>容易产生嵌套地狱问题</li>
</ol>
<p>当然，对于项目使用 HOC 还是 render props 应该根据不同的场景来进行渲染。<br>个人觉得，HOC 更倾向于封装一些复杂的操作，需要复用通用的业务状态和功能的时候使用。而 render props 比较适合抽离与业务无关但是和UI保存的状态有关的功能 (renderProps 内部管理的状态不方便从外部获取，因此只适合保存业务无关的数据，比如 Modal 显隐)。</p>
<h2 id="RenderProps-工具库-react-powerplug"><a href="#RenderProps-工具库-react-powerplug" class="headerlink" title="RenderProps 工具库 react-powerplug"></a>RenderProps 工具库 react-powerplug</h2><p>React PowerPlug 是利用 render props 进行更好状态管理的工具库。<br>在我们日常开发中，一个 Component 类中，可能有很多的 state 但是并不是每个状态都和有业务有关，比如：UI 的展示状态，受控组件的临时 value 等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">    state = &#123;</div><div class="line">        nameIsEdit: <span class="literal">false</span>,</div><div class="line">        briefIsEdit: <span class="literal">false</span>,</div><div class="line">        isLoding: <span class="literal">false</span>,</div><div class="line">        value: <span class="string">''</span>,</div><div class="line">        data: &#123;&#125;</div><div class="line">    &#125;;</div><div class="line">    render() &#123;</div><div class="line">        <span class="comment">//....</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这时候我们就一些常用的状态管理封装成 render props 的形式。react-powerplug 就是提供这样工具的一个类库。这里简单看下几个功能，来帮助我们更好理解 render props 的应用。</p>
<h3 id="Value"><a href="#Value" class="headerlink" title="Value"></a>Value</h3><p>该方法是用来管理值操作的工具。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;Value initial=<span class="string">"React"</span>&gt;</div><div class="line">    &#123;(&#123; value, set, reset &#125;) =&gt; (</div><div class="line">        &lt;&gt;</div><div class="line">        &lt;Select</div><div class="line">            label=<span class="string">"Choose one"</span></div><div class="line">            options=&#123;[<span class="string">"React"</span>, <span class="string">"Preact"</span>, <span class="string">"Vue"</span>]&#125;</div><div class="line">            value=&#123;value&#125;</div><div class="line">            onChange=&#123;set&#125;</div><div class="line">        /&gt;</div><div class="line">        &lt;Button onClick=&#123;reset&#125;&gt;Reset to initial&lt;<span class="regexp">/Button&gt;</span></div><div class="line"><span class="regexp">        &lt;/</span>&gt;</div><div class="line">    )&#125;</div><div class="line">&lt;<span class="regexp">/Value&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li><a href="https://github.com/renatorib/react-powerplug/blob/master/src/components/Value.js" target="_blank" rel="external">源码地址</a>  </li>
</ul>
<p>Value 中，只存储一个属性 value，并赋初始值为 initial。</p>
<p>方法：set reset。</p>
<ul>
<li>set 回调函数触发后调用 setState 更新 value。</li>
<li>reset 就是调用 set 并传入 this.props.initial 即可。</li>
</ul>
<h3 id="Active"><a href="#Active" class="headerlink" title="Active"></a>Active</h3><p>这是一个内置鼠标交互监听的容器，监听了 onMouseUp 与 onMouseDown，并依此判断 active 状态。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;Active&gt;</div><div class="line">    &#123;(&#123; active, bind &#125;) =&gt; (</div><div class="line">        &lt;div &#123;...bind&#125;&gt;</div><div class="line">            You are &#123;active ? <span class="string">"clicking"</span> : <span class="string">"not clicking"</span>&#125; <span class="keyword">this</span> div.</div><div class="line">        &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">    )&#125;</span></div><div class="line"><span class="regexp">&lt;/</span>Active&gt;</div></pre></td></tr></table></figure>
<p>借助 Value 实现，巧妙的利用了 value，value 重命名为 active 且初始值为 false。增加了 bind 方法，借助 set 来更新状态。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span></div><div class="line"><span class="keyword">import</span> Value <span class="keyword">from</span> <span class="string">'./Value'</span></div><div class="line"><span class="keyword">import</span> renderProps <span class="keyword">from</span> <span class="string">'../utils/renderProps'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> Active = <span class="function">(<span class="params">&#123; onChange, ...props &#125;</span>) =&gt;</span> (</div><div class="line">    &lt;Value initial=&#123;<span class="literal">false</span>&#125; onChange=&#123;onChange&#125;&gt;</div><div class="line">        &#123;(&#123; value, set &#125;) =&gt;</div><div class="line">            renderProps(props, &#123;</div><div class="line">                active: value,</div><div class="line">                bind: &#123;</div><div class="line">                    onMouseDown: <span class="function"><span class="params">()</span> =&gt;</span> set(<span class="literal">true</span>),</div><div class="line">                    onMouseUp: <span class="function"><span class="params">()</span> =&gt;</span> set(<span class="literal">false</span>)</div><div class="line">                &#125;,</div><div class="line">            &#125;)</div><div class="line">        &#125;</div><div class="line">    &lt;<span class="regexp">/Value&gt;</span></div><div class="line"><span class="regexp">)</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">export default Active</span></div></pre></td></tr></table></figure>
<p>其他功能就不一一展示了。</p>
<h2 id="render-props-嵌套问题"><a href="#render-props-嵌套问题" class="headerlink" title="render props 嵌套问题"></a>render props 嵌套问题</h2><p>上面过，render props 有一个缺点当我们想要组合使用的时候，可能会遇到嵌套地狱问题。在 react-powerplug 中提供了 compose 函数，来解决这一问题。 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; compose &#125; <span class="keyword">from</span> <span class="string">'react-powerplug'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> AandB = compose(</div><div class="line">    &lt;A .../&gt;,</div><div class="line">    &lt;B .../&gt;</div><div class="line">)</div><div class="line">&lt;AandB&gt;</div><div class="line">    &#123;(a, b) =&gt; &#123;</div><div class="line">        <span class="comment">//....</span></div><div class="line">    &#125;&#125;</div><div class="line">&lt;<span class="regexp">/AandB&gt;</span></div></pre></td></tr></table></figure>
<p>社区也提供了 <a href="https://github.com/Astrocoders/epitath" target="_blank" rel="external">Epitath</a> 工具来专门解决 render props 嵌套问题。细节就不看了。</p>
<h2 id="React-Hooks"><a href="#React-Hooks" class="headerlink" title="React Hooks"></a>React Hooks</h2><p>React Hooks 是 React 16.7.0-alpha 版本推出的新特性。React Hooks 要解决的问题是状态共享，是继 render-props 和 higher-order components 之后的第三种状态共享方案，不会产生 JSX 嵌套地狱问题。之后介绍吧，现在还没空仔细体会呢。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.jianshu.com/p/ff6b3008820a?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="external">React组件Render Props VS HOC 设计模式</a></li>
<li><a href="https://medium.com/tandemly/im-breaking-up-with-higher-order-components-44b0df2db052" target="_blank" rel="external">I’m Breaking up with Higher Order Components.</a></li>
<li><a href="https://github.com/dt-fe/weekly/blob/master/75.%E7%B2%BE%E8%AF%BB%E3%80%8AEpitath%20%E6%BA%90%E7%A0%81%20-%20renderProps%20%E6%96%B0%E7%94%A8%E6%B3%95%E3%80%8B.md" target="_blank" rel="external">精读《Epitath 源码 - renderProps 新用法》</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章，我们介绍了高阶组件(HOC)，最后也提出了几个关于高阶组件的问题。这里我们接上另一种组件复用模式 &lt;code&gt;render props&lt;/code&gt; 亦或是 &lt;code&gt;funtion as child&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;render-props&quot;&gt;&lt;a href=&quot;#render-props&quot; class=&quot;headerlink&quot; title=&quot;render props&quot;&gt;&lt;/a&gt;render props&lt;/h2&gt;&lt;p&gt;本质上，render props 就是在原有的组件上增加一个 prop 来实现不同的渲染情况，从而达到代码复用的目的(即将组件组件做为参数)。举例如下：&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="http://yoursite.com/categories/React/"/>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React 组件复用和组合 (一)</title>
    <link href="http://yoursite.com/2018/12/01/React%E7%BB%84%E5%90%88%E4%B8%8E%E5%A4%8D%E7%94%A8/"/>
    <id>http://yoursite.com/2018/12/01/React组合与复用/</id>
    <published>2018-12-01T02:57:08.000Z</published>
    <updated>2019-04-02T03:17:45.073Z</updated>
    
    <content type="html"><![CDATA[<p>组件的复用和组合，可以帮助我们在现有的轮子上扩展新的功能，提高工作效率，避免重复造轮子。React 组件化的开发方式可以很好地实现复用和组合的功能，本章主要围绕高阶组件来讨论下这一问题。</p>
<h2 id="高阶组件（HOC）"><a href="#高阶组件（HOC）" class="headerlink" title="高阶组件（HOC）"></a>高阶组件（HOC）</h2><blockquote>
<p>高阶组件（HOC）是 React 中用于重用组件逻辑的高级技术。 HOC 本身不是 React API 的一部分。 它们是从 React 构思本质中浮现出来的一种模式。  </p>
</blockquote>
<a id="more"></a>
<p>通俗点高阶组件就是一个函数，其接受一个组件并返回对着个组件功能上的扩展复用的新的组件。</p>
<blockquote>
<p>const EnhancedComponent = higherOrderComponent(WrappedComponent);</p>
</blockquote>
<p>高阶组件常见有两种实现方式，一种是 Props Proxy(属性代理)，一种是 Inheritance Inversion(继承反转)</p>
<h3 id="Props-Proxy"><a href="#Props-Proxy" class="headerlink" title="Props Proxy"></a>Props Proxy</h3><p>Props Proxy 模式可以对 WrappedComponent 的 props 进行操作扩展，抽离 state，并可以使用其他元素来包裹 WrappedComponend 来实现扩展组件的功能。</p>
<h4 id="操作-props"><a href="#操作-props" class="headerlink" title="操作 props"></a>操作 props</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">propsHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">        render() &#123;</div><div class="line">            <span class="keyword">let</span> newProps = &#123;/.../&#125;;</div><div class="line">            <span class="keyword">return</span> &lt;WrappedComponent &#123;...props&#125; &#123;...newProps&#125;/&gt;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，传递给 WrappedComponent 的属性首先传递给了高阶组件返回的组件，这样我们就获得了props的控制权。</p>
<h4 id="抽离-state"><a href="#抽离-state" class="headerlink" title="抽离 state"></a>抽离 state</h4><p>我们可以将 WrappedComponent 中的状态提到包裹组件中，一种很常见的操作就是将不受控组件转换成受控组件。通常，我们在设计 UI 组件的时候，组件应该简单只负责展示 (不受控组件)。对组件的修改逻辑不应该放在组件中，而是由调用者来提供。这样，我们就可以用HOC来将无状态组件变成受控组件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">stateHoc</span>(<span class="params">WrappedComponent</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">        <span class="keyword">constructor</span>(props) &#123;</div><div class="line">            <span class="keyword">super</span>(props);</div><div class="line">            <span class="keyword">this</span>.state = &#123;</div><div class="line">                value: <span class="string">''</span></div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line">        onChange(event) &#123;</div><div class="line">            <span class="keyword">this</span>.setState(&#123;</div><div class="line">                value: event.target.value</div><div class="line">            &#125;)</div><div class="line">        &#125;</div><div class="line">        render() &#123;</div><div class="line">            <span class="keyword">const</span> props = &#123;</div><div class="line">                ...this.props,</div><div class="line">                value: <span class="keyword">this</span>.state.value,</div><div class="line">                onChange: <span class="keyword">this</span>.onChange</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> &lt;WrappedComponent &#123;...props&#125;/&gt;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@stateHoc</div><div class="line">class InputStateLess extends Component &#123;</div><div class="line">    render() &#123;</div><div class="line">        return &lt;input name="name" value=&#123;this.props.value&#125; /&gt;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Inheritance-Inversion"><a href="#Inheritance-Inversion" class="headerlink" title="Inheritance Inversion"></a>Inheritance Inversion</h3><p>反向继承，我们采用直接继承 WrappedComponent 的方案，而不是采用包裹 WrappedComonent 的代理方案。这意味着，我们可以调用 WrappedComponent 的属性，声明周期等任何内容。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">iiOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</div><div class="line">        render() &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.render();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过我们可以完全操作 WrappedComponent 上的内容，我们可以实现<code>渲染劫持</code>等操作，改变 WrappedComponent 的任何行为。<br>Inheritance Inversion 是继承的思想，对于 WrappedComponent 也有较强的侵入性，因此并不常见。</p>
<h3 id="高阶组件的应用"><a href="#高阶组件的应用" class="headerlink" title="高阶组件的应用"></a>高阶组件的应用</h3><p>高阶组件的本质是统一抽象功能，强调逻辑和UI的分离</p>
<h4 id="view-层分离"><a href="#view-层分离" class="headerlink" title="view 层分离"></a>view 层分离</h4><p>在设计组件的时候，我们会尽可能考虑组件的复用性，对于组件的 view 层，我们期望是组件与组件之间没有重叠的部分，重叠的部分应该被抽出来形成更细粒度的组件，这样方便我们各种各样的组件组合。每个最小的基础组件我们都期望他是一个<code>木偶组件(Dumb Component)</code>。<br>木偶组件，指只会接受 props 并且渲染结果完全依赖 props 的组件。Dumb 组件不应该依赖除了 React.js 和 Dumb 组合以外的内容(比如不应该依赖 redux，mobx 等)。这样的组件可复用性是最好的，其他人可以放心使用。<br>当然仅有 Dumb 组件，是不能工作的，因为他们没有逻辑。为此还应该有这么一类组件，他们只负责应用逻辑，和各种数据打交道，然后把数据以 props 的形式传递给 Dumb 组件。<br>注意，Dumb 绝对不能依赖 Smart 组件，这相当增加了 Dumb 输出的不确定性。如果一个组件是 Dumb 的，那么它的子组件们都应该是 Dumb 的才对。</p>
<img src="/2018/12/01/React组合与复用/a.png" alt="a.png" title="">
<h4 id="逻辑层的分离"><a href="#逻辑层的分离" class="headerlink" title="逻辑层的分离"></a>逻辑层的分离</h4><p>组件中的交互逻辑和业务逻辑有很大部分也是重复的，我们可以将这写公共部分进行抽象封装起来，来为其他组件增加新的能力，这也就是高阶组建的思想。每个独立可重用的逻辑都是一个 <code>Decorator</code> 装饰器。<br>适用于高阶组件的逻辑层应该时那些完全不与 DOM 相关的内容。比如数据校验，权限控制，或者通过数据变化间接控制 DOM 的。</p>
<h4 id="举例-Form-表单的抽离"><a href="#举例-Form-表单的抽离" class="headerlink" title="举例 Form 表单的抽离"></a>举例 Form 表单的抽离</h4><p>Form 中，会包含不同的组件，input, selector, checkbox 等等，也可能会是多种常见组件的组合。</p>
<img src="/2018/12/01/React组合与复用/b.png" alt="b.png" title="">
<p>如图，一个下拉搜索框，由 input，select, list 三个纯粹的细粒度的 Dumb 组件组成。对于每个 UI 都有自己的数据 validator 验证规则，和数据变化回调规则。我们可以将这部分逻辑的对应关系和UI的绑定做成一个 HOC 组件。 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 函数柯里化，为 HOC 提供参数</span></div><div class="line"><span class="comment">// validator 用户定义的变淡验证规则</span></div><div class="line"><span class="comment">// changeFunc 相应数据变化的函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">formFactory</span>(<span class="params">validator, changeFunc = <span class="string">'onChange'</span></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">WrappedComponent</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">            getBind(changeFunc, validtor) &#123;</div><div class="line">                <span class="comment">//...</span></div><div class="line">            &#125;</div><div class="line">            render() &#123;</div><div class="line">                <span class="keyword">const</span> props = &#123;</div><div class="line">                    ...this.props,</div><div class="line">                    [trigger]: <span class="keyword">this</span>.getBind(trigger, validtor)</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> &lt;WrappedComponent &#123;...props&#125; /&gt;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 为 Input 组件绑定验证规则</div><div class="line">formFactory((value) =&gt; &#123;</div><div class="line">    return value &gt; 0</div><div class="line">&#125;)(&lt;Input name="age" placeholder="请输入年龄"/&gt;)</div></pre></td></tr></table></figure>
<h3 id="高阶组件的问题"><a href="#高阶组件的问题" class="headerlink" title="高阶组件的问题"></a>高阶组件的问题</h3><h4 id="不确定性-amp-命名冲突"><a href="#不确定性-amp-命名冲突" class="headerlink" title="不确定性 &amp; 命名冲突"></a>不确定性 &amp; 命名冲突</h4><p>高阶组件的变更是由 props 引起的，且高阶组件之间是互相独立的。因此当组件的 props 发生变化后，我们很难确定是哪个高级组件引起的 props 变动或者是组件本身引起的。同样多个高阶组件的引入的 props 也有可能因为同名原因导致互相覆盖，产生许多无用的组件嵌套加深组件层级，这些问题高阶组件都无法解决。<br>官方文档上推荐我们使用高阶组件的时候提出了如下约定：</p>
<blockquote>
<p>约定: 给包裹组件传递不相关的属性(Props)</p>
</blockquote>
<p>这个问题只能靠约定而没有办法约束，因此可维护性变低。</p>
<h4 id="静态方法必须复制-amp-Refs-不会被传递"><a href="#静态方法必须复制-amp-Refs-不会被传递" class="headerlink" title="静态方法必须复制 &amp; Refs 不会被传递"></a>静态方法必须复制 &amp; Refs 不会被传递</h4><p>由于高阶组件包裹的特性，原有组件上的静态方法并不会得到传递。同样的道理 ref 在容器组件上应用 ref 也不会直接传递给原有组件。我们都需要在容器组件上做静态方法的复制和 ref 的传递。</p>
<p>高阶组件的带来的副作用有没有解决办法呢？render-props 可以在一定程度上来解决，这个之后我们再谈吧。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/22054582" target="_blank" rel="external">基于 Decorator 的组件扩展实践</a></li>
<li><a href="http://react.html.cn/docs/higher-order-components.html" target="_blank" rel="external">高阶组件(Higher-Order Components)</a></li>
<li><a href="https://medium.com/@franleplant/react-higher-order-components-in-depth-cf9032ee6c3e" target="_blank" rel="external">React Higher Order Components in depth</a></li>
<li><a href="http://huziketang.mangojuice.top/books/react/lesson43" target="_blank" rel="external">Smart 组件 vs Dumb 组件</a></li>
<li><a href="https://juejin.im/post/5914fb4a0ce4630069d1f3f6" target="_blank" rel="external">React 高阶组件(HOC)入门指南</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;组件的复用和组合，可以帮助我们在现有的轮子上扩展新的功能，提高工作效率，避免重复造轮子。React 组件化的开发方式可以很好地实现复用和组合的功能，本章主要围绕高阶组件来讨论下这一问题。&lt;/p&gt;
&lt;h2 id=&quot;高阶组件（HOC）&quot;&gt;&lt;a href=&quot;#高阶组件（HOC）&quot; class=&quot;headerlink&quot; title=&quot;高阶组件（HOC）&quot;&gt;&lt;/a&gt;高阶组件（HOC）&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;高阶组件（HOC）是 React 中用于重用组件逻辑的高级技术。 HOC 本身不是 React API 的一部分。 它们是从 React 构思本质中浮现出来的一种模式。  &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="React" scheme="http://yoursite.com/categories/React/"/>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>单页应用代码分割</title>
    <link href="http://yoursite.com/2018/11/19/%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2/"/>
    <id>http://yoursite.com/2018/11/19/单页应用代码分割/</id>
    <published>2018-11-19T13:52:17.000Z</published>
    <updated>2018-11-22T09:46:48.252Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单页面代码分割"><a href="#单页面代码分割" class="headerlink" title="单页面代码分割"></a>单页面代码分割</h2><p>目前单页应用的 bundle.js 一般都会很大，这样的话会对启动时间造成影响。为此我们需要合理拆分 js 文件，然后在需要使用的时候才动态记在。<br>拆分 js 文件，我们通常会采用手段： </p>
<ul>
<li>基于业务逻辑和依赖库分割</li>
<li>基于路由分割  </li>
<li>基于组件分割  </li>
</ul>
<a id="more"></a>

<p>左图所示是基于路由进行分割，有图为基于组件进行分割。基于路由分割的力度比较大，一个路由里会嵌套很多组件。每个路由 react 组件还是有很多，但并不是每个组件都会被立刻使用。同时，多个路由之间还有可能会产生很多重复的组件代码。这显然不如基于组件进行分割效果较好。  </p>
<h2 id="代码分割案例"><a href="#代码分割案例" class="headerlink" title="代码分割案例"></a>代码分割案例</h2><p>假如，我们有个页面，页面的额外信息 extra 组件是不需要的，只有点击查看额外信息按钮后才会出现。我们对 extra 进行惰性加载。代码如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(prop) &#123;</div><div class="line">        <span class="keyword">super</span>(prop);</div><div class="line">        <span class="keyword">this</span>.state = &#123;</div><div class="line">            showExtra: <span class="literal">false</span>,</div><div class="line">            CExtra: &#123;&#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    handleOpenExtra() &#123;</div><div class="line">        <span class="keyword">import</span>(<span class="string">'./components/extra'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</div><div class="line">            <span class="keyword">this</span>.setState(&#123;</div><div class="line">                showExtra: <span class="literal">true</span>,</div><div class="line">                CExtra: res.default</div><div class="line">            &#125;)</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;React.Fragment&gt;</div><div class="line">                &#123;<span class="keyword">this</span>.state.showExtra ? <span class="xml"><span class="tag">&lt;<span class="name">this.state.CExtra</span> /&gt;</span> : null&#125;</span></div><div class="line"><span class="xml">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line"><span class="xml">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleOpenExtra.bind(this)&#125;</span>&gt;</span>点击查看额外信息<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></div><div class="line"><span class="xml">        );</span></div><div class="line"><span class="xml">    &#125;</span></div><div class="line"><span class="xml">&#125;;</span></div><div class="line"><span class="xml">export default App;</span></div></pre></td></tr></table></figure>
<p>demo 中我们利用了 webpack 分包加载功能，当点击按钮时利用 import 来加载 extra 组件，而不是在开头直接引入。  </p>
<h3 id="动态导入-dynamic-imports"><a href="#动态导入-dynamic-imports" class="headerlink" title="动态导入(dynamic imports)"></a>动态导入(dynamic imports)</h3><p>上述案例，我们借助 import 函数来引入 extra 包。webpack 在打包的时候会自动检测这样的 import 引入的文件，为其单独生成一个打包 js 文件。如图所示：  </p>
  
<p>当我们点击加载按钮后，红线处的 js 包会被异步载入   </p>
 
<p>webpack 实现动态导如的代码如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">__webpack_require__.e = <span class="function"><span class="keyword">function</span> <span class="title">requireEnsure</span>(<span class="params">chunkId</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> promises = [];</div><div class="line">	<span class="comment">// JSONP chunk loading for javascript</span></div><div class="line">	<span class="keyword">var</span> installedChunkData = installedChunks[chunkId];</div><div class="line">	<span class="keyword">if</span>(installedChunkData !== <span class="number">0</span>) &#123; <span class="comment">// 0 means "already installed".</span></div><div class="line">		<span class="comment">// a Promise means "currently loading".</span></div><div class="line">		<span class="keyword">if</span>(installedChunkData) &#123;</div><div class="line">			promises.push(installedChunkData[<span class="number">2</span>]);</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="comment">// 每次需要进行异步加载chunk时，会将这个chunk的加载状态进行初始化为一个数组,并以key/value的形式保存在installedChunks里</span></div><div class="line">			<span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">				installedChunkData = installedChunks[chunkId] = [resolve, reject];</div><div class="line">			&#125;);</div><div class="line">			promises.push(installedChunkData[<span class="number">2</span>] = promise);</div><div class="line">			<span class="comment">// 开始异步 chunk 加载</span></div><div class="line">			<span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>];</div><div class="line">			<span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</div><div class="line">			<span class="keyword">var</span> onScriptComplete;</div><div class="line">			script.charset = <span class="string">'utf-8'</span>;</div><div class="line">			script.timeout = <span class="number">120</span>;</div><div class="line">			<span class="keyword">if</span> (__webpack_require__.nc) &#123;</div><div class="line">				script.setAttribute(<span class="string">"nonce"</span>, __webpack_require__.nc);</div><div class="line">			&#125;</div><div class="line">			script.src = jsonpScriptSrc(chunkId);   <span class="comment">// js 文件名</span></div><div class="line">			onScriptComplete = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;   <span class="comment">// 加载完毕回调</span></div><div class="line">				<span class="comment">// avoid mem leaks in IE.</span></div><div class="line">				script.onerror = script.onload = <span class="literal">null</span>;</div><div class="line">				clearTimeout(timeout);</div><div class="line">				<span class="keyword">var</span> chunk = installedChunks[chunkId];</div><div class="line">				<span class="keyword">if</span>(chunk !== <span class="number">0</span>) &#123;</div><div class="line">					<span class="keyword">if</span>(chunk) &#123;</div><div class="line">						<span class="keyword">var</span> errorType = event &amp;&amp; (event.type === <span class="string">'load'</span> ? <span class="string">'missing'</span> : event.type);</div><div class="line">						<span class="keyword">var</span> realSrc = event &amp;&amp; event.target &amp;&amp; event.target.src;</div><div class="line">						<span class="keyword">var</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Loading chunk '</span> + chunkId + <span class="string">' failed.\n('</span> + errorType + <span class="string">': '</span> + realSrc + <span class="string">')'</span>);</div><div class="line">						error.type = errorType;</div><div class="line">						error.request = realSrc;</div><div class="line">						chunk[<span class="number">1</span>](error);</div><div class="line">					&#125;</div><div class="line">					installedChunks[chunkId] = <span class="literal">undefined</span>;</div><div class="line">				&#125;</div><div class="line">			&#125;;</div><div class="line">			<span class="keyword">var</span> timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">				onScriptComplete(&#123; <span class="attr">type</span>: <span class="string">'timeout'</span>, <span class="attr">target</span>: script &#125;);</div><div class="line">			&#125;, <span class="number">120000</span>);</div><div class="line">			script.onerror = script.onload = onScriptComplete;</div><div class="line">			head.appendChild(script);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="built_in">Promise</span>.all(promises);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>注意，使用 import 导入这种形式的话，我们需要使用 dynamic-import 包：  </p>
<blockquote>
<p>npm install –save-dev @babel/plugin-syntax-dynamic-import  </p>
</blockquote>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"plugins"</span>: [<span class="string">"@babel/plugin-syntax-dynamic-import"</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或者你也可以使用 webpack 提供的 require.ensure 来代替。</p>
<h2 id="react-loadable"><a href="#react-loadable" class="headerlink" title="react-loadable"></a>react-loadable</h2><p>上述代码，我们粗略的实现了一个分包加载的demo，业务上我们还要有很多问题来处理。比如：import 失败怎么办？加载前需要 loading 占位怎么做？服务端渲染怎么做？<br>这里介绍一个库 react-loadable。他会把我们要异步加载的组件封装成一个高阶组件供我们使用<br>例如，我们异步加载 extra 组件，并且引入一个 loading 作为加载占位，代码如下： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> LoadableComponent = Loadable(&#123;</div><div class="line">     loader: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./components/extra'</span>),</div><div class="line">     loading: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;div&gt;组件加载中&lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">        );</span></div><div class="line"><span class="regexp">     &#125;</span></div><div class="line"><span class="regexp">&#125;);</span></div></pre></td></tr></table></figure>
<p>使用的时候我们直接在恰当的时机渲染 LoadableComponent 组件即可。<br>除此之外，react-loadable 还提供了预加载，服务端渲染等功能。这里就不详细介绍使用了，主要我们看一下源码实现的过程。</p>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><h4 id="函数入口"><a href="#函数入口" class="headerlink" title="函数入口"></a>函数入口</h4><p><code>react-loadable</code> 本质上就是一个高阶组件封装的过程。代码入口如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Loadable</span>(<span class="params">opts</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> createLoadableComponent(load, opts);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Loadable 接受我们传入的参数 opts, 再调用了createLoadableComponent函数，传入了 <code>load</code> 函数和 opts。 </p>
<h4 id="load-函数"><a href="#load-函数" class="headerlink" title="load 函数"></a>load 函数</h4><p>这里我们先来看一下 <code>load</code> 函数：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params">loader</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> promise = loader();</div><div class="line">    <span class="keyword">let</span> state = &#123;</div><div class="line">        loading: <span class="literal">true</span>,</div><div class="line">        loaded: <span class="literal">null</span>,    <span class="comment">// 组件实例</span></div><div class="line">        error: <span class="literal">null</span></div><div class="line">    &#125;;</div><div class="line">    state.promise = promise</div><div class="line">        .then(<span class="function"><span class="params">loaded</span> =&gt;</span> &#123;</div><div class="line">            state.loading = <span class="literal">false</span>;</div><div class="line">            state.loaded = loaded;</div><div class="line">            <span class="keyword">return</span> loaded;</div><div class="line">        &#125;)</div><div class="line">        .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</div><div class="line">            state.loading = <span class="literal">false</span>;</div><div class="line">            state.error = err;</div><div class="line">            <span class="keyword">throw</span> err;</div><div class="line">        &#125;);</div><div class="line">    <span class="keyword">return</span> state;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>load</code> 函数里初始化了一个state对象，执行 loader 方法(即我们传入的 loader 参数 (import(…))) 来加载异步组件。之后将返回结果保存在 state 的 loaded 属性中，加载状态保存在其他属性上。返回这个 state 供后续使用。 </p>
<h4 id="createLoadableComponent"><a href="#createLoadableComponent" class="headerlink" title="createLoadableComponent"></a>createLoadableComponent</h4><p>接下来，开始分析整个代码的主体部分 <code>createLoadableComponent</code> 函数。其作用就是包装加载后的异步组件，返回一个高阶组件供我们使用。代码如下：</p>

<p>首先检测必须含有 loading 组件，给参数添加默认值等。然后初始化一个 init 方法，用于执行上文的 <code>load</code> 函数以加载异步组件，并记录状态给 res 变量。之后就是返回 LoadableComponent 组件的过程。<br>在 LoadableComponent 中，发生如下情况：</p>
<ol>
<li><code>constructor</code> 阶段：调用 init 方法，保存状态到 state 上</li>
<li><code>componentWillMount</code> 阶段：<ul>
<li>设置 this._mounted 状态默认为 ture 表示加载完成</li>
<li>进行一些判断，如果 res.loading 为 false，说明之前的 init 执行出错，直接return</li>
<li>如果opts.delay 和 opts.timeout有值，且为number属性的话，就加个定时器用来延迟显示 loading 组件（避免闪烁）</li>
<li>声明 update 函数，用来根据异步组件加载的结果更新 state 值</li>
<li>如果 this.state.loading 或者 this.state.error 为 true，就是整体状态是正在加载或者出错了，就用 React.createElement 生成出loading的过渡组件</li>
<li>如果 this.state.loaded 有值了，说明传入的loader的promise异步操作执行完成，就开始渲染真正的组件，调用opts.render方法</li>
</ul>
</li>
</ol>
<p>大致过程就是这样，不贴代码了。还有一些细节，对 webpack 等处理，preload 静态方法等，也就一两句话，看看就知道了。  </p>
<h2 id="React-lazy"><a href="#React-lazy" class="headerlink" title="React.lazy"></a>React.lazy</h2><p>在 React 16.0.0 中，加入了 React.lazy 方法渲染动态导入为常规组件(尚不能用在服务端)。</p>
<img src="/2018/11/19/单页应用代码分割/a5.png" alt="a5.png" title=""> 
<p>主要用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> OtherComponent = React.lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./OtherComponent'</span>));</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">        &lt;div&gt;</div><div class="line">            &lt;OtherComponent /&gt;</div><div class="line">        &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">    );</span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure>
<p>当渲染此组件时，这将自动加载包含 OtherComponent 包。如果我们需要加载时的 Loading 组件做为<br>过度使用。我们需要调用 Suspense 组件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> OtherComponent = React.lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./OtherComponent'</span>));</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">        &lt;div&gt;</div><div class="line">            &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;<span class="regexp">/div&gt;&#125;&gt;</span></div><div class="line"><span class="regexp">                &lt;OtherComponent /</span>&gt;</div><div class="line">            &lt;<span class="regexp">/Suspense&gt;</span></div><div class="line"><span class="regexp">        &lt;/</span>div&gt;</div><div class="line">    );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>fallback prop（属性） 接受在等待加载组件时要渲染的任何 React 元素。</p>
<h2 id="异步加载时机"><a href="#异步加载时机" class="headerlink" title="异步加载时机"></a>异步加载时机</h2><p>想这么一个问题，如果 extra 包很大，我们点击打开 open 按钮后，要花很长一段时间才能看到组件内容。这样同样也不是什么好的体验。甚至，如果我们加载的包里面逻辑复杂，js 运行时间过长会阻塞掉用户的交互。这样要如何处理呢？</p>
<h3 id="Idle-Until-Urgent-（空闲等待-amp-紧急优先）"><a href="#Idle-Until-Urgent-（空闲等待-amp-紧急优先）" class="headerlink" title="Idle Until Urgent （空闲等待 &amp; 紧急优先）"></a>Idle Until Urgent （空闲等待 &amp; 紧急优先）</h3><p>点击 extra 肯定是延后操作，我们希望在主要任务都完成后，如果浏览器有空闲时间就来预加载组件(空闲等待)。如果我们点击打开按钮，这时候组件还没有加载完毕，那么我们就立刻加载组件(紧急优先)。<br>实现该操作，我们可以借助 requestIdleCallback 函数。改造代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"></div><div class="line"><span class="keyword">let</span> rIc = <span class="built_in">window</span>.requestIdleCallback;</div><div class="line"><span class="keyword">let</span> cIc = <span class="built_in">window</span>.cancelIdleCallback;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(prop) &#123;</div><div class="line">        <span class="keyword">super</span>(prop);</div><div class="line">        <span class="keyword">this</span>.state = &#123;</div><div class="line">            showExtra: <span class="literal">false</span></div><div class="line">        &#125;;</div><div class="line">        <span class="comment">// 开始空闲加载</span></div><div class="line">        <span class="keyword">this</span>.idleHandle = rIC(<span class="keyword">this</span>.loadComponent.bind(<span class="keyword">this</span>));</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 打开 extra 列表</span></div><div class="line">    <span class="keyword">async</span> handleOpenExtra() &#123;</div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.CExtra) &#123;</div><div class="line">            <span class="comment">// 如果没有加载好，则取消空闲加载，直接进入加载阶段</span></div><div class="line">            cIC(<span class="keyword">this</span>.idleHandle);</div><div class="line">            <span class="keyword">await</span> <span class="keyword">this</span>.loadComponent();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.setState(&#123;</div><div class="line">            showExtra: <span class="literal">true</span>;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 异步加载内容</span></div><div class="line">    <span class="keyword">async</span> loadComponent() &#123;</div><div class="line">        <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">'./components/extra'</span>).then();</div><div class="line">        <span class="keyword">this</span>.CExtra = result;</div><div class="line">    &#125;</div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;React.Fragment&gt;</div><div class="line">                &#123;<span class="keyword">this</span>.state.showExtra ? <span class="xml"><span class="tag">&lt;<span class="name">this.CExtra.default</span> /&gt;</span> : null&#125;</span></div><div class="line"><span class="xml">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line"><span class="xml">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleOpenExtra.bind(this)&#125;</span>&gt;</span>点击查看额外信息<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></div><div class="line"><span class="xml">        );</span></div><div class="line"><span class="xml">    &#125;</span></div><div class="line"><span class="xml">&#125;;</span></div><div class="line"><span class="xml">export default App;</span></div></pre></td></tr></table></figure>
<p>当然，你也可以用 react-loadable 来实现该例子，简要改动如下： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> LoadableMyComponent = Loadable(&#123;</div><div class="line">    loader: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./components/extra'</span>),</div><div class="line">    ...</div><div class="line">&#125;)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="comment">//...</span></div><div class="line">        <span class="keyword">this</span>.idleHandle = rIC(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">            LoadableMyComponent.preload()</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种空闲执行的方案，同样使用于执行那些不是很紧急但是耗时很长的函数。例如处理大量数据集，localStorage 中获取数据等等。合理利用 requestIdleCallback 可以减少网页的阻塞，提高效果。</p>
<h4 id="空闲任务队列"><a href="#空闲任务队列" class="headerlink" title="空闲任务队列"></a>空闲任务队列</h4><p>上面技术适用于可以通过单个函数计算出来的属性，但在某些情况下，逻辑可能无法写到单个函数里，或者，即使技术上可行，您仍然希望将其拆分为更小的一些函数，以免其长时间阻塞主线程。 这里提供一个 <a href="https://github.com/GoogleChromeLabs/idlize" target="_blank" rel="external">IdleQueue</a> 你可以在里面找到利用 requestIdleCallback 的姿势。</p>
<h2 id="mobx-是否需要拆分"><a href="#mobx-是否需要拆分" class="headerlink" title="mobx 是否需要拆分"></a>mobx 是否需要拆分</h2><p>通常我们在写业务的时候，会把 store 写在 <code>&lt;Provider&gt;</code> 上直直接注入。那我们需要对 mobx 的 store 也异步加载呢？理论上没有这个必要，因为 store 里面的内容确实一般不会很大并不是造成包体积过大的原因。优化效果不太明显。<br>当然如果非要异步加载的话，我这里有个想法，我们将 store 和 action 拆分出来。store 里面只包含数据：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexStore</span> </span>&#123;</div><div class="line">    @observable list = [];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtraStore</span> </span>&#123;</div><div class="line">    @observable extra = [];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>store 依然在全局在 Provider 注入，每个业务的 action 单独抽离成一个文件： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexAction</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(store) &#123;</div><div class="line">        <span class="keyword">this</span>.store = store;</div><div class="line">    &#125;</div><div class="line">    @action getList() &#123;</div><div class="line">        <span class="keyword">this</span>.store.list = [</div><div class="line">            <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span></div><div class="line">        ];</div><div class="line">    &#125;</div><div class="line">    @action addItem() &#123;</div><div class="line">        <span class="keyword">this</span>.store.list.push(<span class="keyword">this</span>.list.length + <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>action 们单独在一个全局变量中维护，需要异步加载的时候如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// actions 为一个全局变量</span></div><div class="line"><span class="keyword">import</span>(<span class="string">'../../actions/extra'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> ExtraAction = res &amp;&amp; res.__esModule ? res.default : res;</div><div class="line">    actions.extra = <span class="keyword">new</span> ExtraAction(self.props.rootStore.extraStore);</div><div class="line">    <span class="comment">// ....</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://webpack.docschina.org/guides/code-splitting/#%E5%8A%A8%E6%80%81%E5%AF%BC%E5%85%A5-dynamic-imports-" target="_blank" rel="external">webpack 动态导入</a></li>
<li><a href="https://juejin.im/post/5bdec712e51d4505525b0fba" target="_blank" rel="external">[译] Google 工程师提升网页性能的新策略：空闲执行，紧急优先</a></li>
<li><a href="https://book.douban.com/subject/30290509/" target="_blank" rel="external">React状态管理与同构实战</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;单页面代码分割&quot;&gt;&lt;a href=&quot;#单页面代码分割&quot; class=&quot;headerlink&quot; title=&quot;单页面代码分割&quot;&gt;&lt;/a&gt;单页面代码分割&lt;/h2&gt;&lt;p&gt;目前单页应用的 bundle.js 一般都会很大，这样的话会对启动时间造成影响。为此我们需要合理拆分 js 文件，然后在需要使用的时候才动态记在。&lt;br&gt;拆分 js 文件，我们通常会采用手段： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于业务逻辑和依赖库分割&lt;/li&gt;
&lt;li&gt;基于路由分割  &lt;/li&gt;
&lt;li&gt;基于组件分割  &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>ReactNative 详解(四) 源码之RN启动过程</title>
    <link href="http://yoursite.com/2018/11/03/ReactNative%E5%9F%BA%E7%A1%804/"/>
    <id>http://yoursite.com/2018/11/03/ReactNative基础4/</id>
    <published>2018-11-03T08:14:59.000Z</published>
    <updated>2019-04-21T11:28:21.271Z</updated>
    
    <content type="html"><![CDATA[<p>本章主要来探讨一下，RN 的启动过程都做了什么？同时简单的介绍下在 Android 中是如何实现 ReactNative 的。进而引出解决一个重要的问题，ReactNative 的预加载。</p>
<a id="more"></a>
<h2 id="ReactNative-系统框架概述"><a href="#ReactNative-系统框架概述" class="headerlink" title="ReactNative 系统框架概述"></a>ReactNative 系统框架概述</h2><p>ReactNative 源码结构图如下：</p>
<img src="/2018/11/03/ReactNative基础4/a.png" alt="a.png" title=""> 
<p>其中几个主要内容：</p>
<ul>
<li>Libraries：JS层的实现，实现了JS组件的封装与JS队列的封装</li>
<li>ReactAndroid：Android 源码实现</li>
<li>ReactCommon：C++ 层实现，实现了对脚本引擎JSC的封装与通信桥ReactBridge，Android与iOS调用</li>
<li>React：ReactNative源码的主要内容</li>
</ul>
<p>ReactNative 主要工作就两部分：<br>第一部分实现：ReactNative 应用启动流程；ReactNative应用UI的绘制与渲染；ReactNative应用通信机制；ReactNative应用线程模型<br>第二部分：ReactNative运行时的异常以及异常的捕获与处理；SOLoader加载动态链接库；ReactNative触摸事件处理机制。</p>
<p>我们先从一个 Demo 工程来看 ReactNative 启动流程</p>
<h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><h3 id="应用初始化"><a href="#应用初始化" class="headerlink" title="应用初始化"></a>应用初始化</h3><p>首先，我们打开这个普通工程的 <code>android</code> 目录，这里就是一个完整的 android 项目。</p>
<ol>
<li>首先我们看 <code>MainApplication.java</code> 里面的 RN 的初始化操作</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> <span class="keyword">implements</span> <span class="title">ReactApplication</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReactNativeHost mReactNativeHost = <span class="keyword">new</span> ReactNativeHost(<span class="keyword">this</span>) &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getUseDeveloperSupport</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> BuildConfig.DEBUG;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> List&lt;ReactPackage&gt; <span class="title">getPackages</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> Arrays.&lt;ReactPackage&gt;asList(</div><div class="line">          <span class="keyword">new</span> MainReactPackage()</div><div class="line">      );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getJSMainModuleName</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="string">"index"</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> ReactNativeHost <span class="title">getReactNativeHost</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> mReactNativeHost;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate();</div><div class="line">    <span class="comment">// SoLoader 加载</span></div><div class="line">    SoLoader.init(<span class="keyword">this</span>, <span class="comment">/* native exopackage */</span> <span class="keyword">false</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>ReactApplication</code> 可以看到我们在Application里实现了 ReactApplication接口，该接口要求创建一个ReactNativeHost对象。ReactNativeHost 对象，本身持有 <code>ReactInstanceManager</code> 对象。其对外暴露两个需要实现的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//是否开启dev模式，dev模式下会有一些调试工具</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">getUseDeveloperSupport</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// 返回app需要的ReactPackage，这些ReactPackage里包含了运行时需要用到的NativeModule</span></div><div class="line"><span class="comment">// JavaScriptModule以及ViewManager</span></div><div class="line"><span class="comment">// 我们的自定义 Module 也是在这里添加的</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> List&lt;ReactPackage&gt; <span class="title">getPackages</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
<p>ReactNativeHost主要的工作就是创建 ReactInstanceManager，创建部分代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ReactNativeHost</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">protected</span> ReactInstanceManager <span class="title">createReactInstanceManager</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// Builder 模式，创建 ReactInstanceManager 实例</span></div><div class="line">    ReactInstanceManagerBuilder builder = ReactInstanceManager.builder()</div><div class="line">      <span class="comment">// 设置应用上下文</span></div><div class="line">      .setApplication(mApplication)</div><div class="line">      <span class="comment">// 设置应用的 jsBundle，可以传给 url 来使其从服务器拉去 jsBundle</span></div><div class="line">      <span class="comment">// 仅在 dev 下生效</span></div><div class="line">      .setJSMainModulePath(getJSMainModuleName())</div><div class="line">      <span class="comment">// 是否开启 dev 模式</span></div><div class="line">      .setUseDeveloperSupport(getUseDeveloperSupport())</div><div class="line">      <span class="comment">// 红盒回调</span></div><div class="line">      .setRedBoxHandler(getRedBoxHandler())</div><div class="line">      .setJavaScriptExecutorFactory(getJavaScriptExecutorFactory())</div><div class="line">      <span class="comment">// 自定义UI实现机制，不会使用</span></div><div class="line">      .setUIImplementationProvider(getUIImplementationProvider())</div><div class="line">      .setJSIModulesPackage(getJSIModulePackage())</div><div class="line">      .setInitialLifecycleState(LifecycleState.BEFORE_CREATE);</div><div class="line"></div><div class="line">    <span class="comment">// 添加ReactPackage (就是我们复写的抽象方法)</span></div><div class="line">    <span class="keyword">for</span> (ReactPackage reactPackage : getPackages()) &#123;</div><div class="line">      builder.addPackage(reactPackage);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//获取js Bundle的加载路径</span></div><div class="line">    String jsBundleFile = getJSBundleFile();</div><div class="line">    <span class="keyword">if</span> (jsBundleFile != <span class="keyword">null</span>) &#123;</div><div class="line">      builder.setJSBundleFile(jsBundleFile);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      builder.setBundleAssetName(Assertions.assertNotNull(getBundleAssetName()));</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 创建</span></div><div class="line">    ReactInstanceManager reactInstanceManager = builder.build();</div><div class="line">    ReactMarker.logMarker(ReactMarkerConstants.BUILD_REACT_INSTANCE_MANAGER_END);</div><div class="line">    <span class="keyword">return</span> reactInstanceManager;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>接下来看 MainActivity.java </li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">ReactActivity</span> </span>&#123;</div><div class="line">    @Override</div><div class="line">    protected <span class="built_in">String</span> getMainComponentName() &#123;</div><div class="line">        <span class="comment">// 返回组件名</span></div><div class="line">        <span class="keyword">return</span> <span class="string">"TestDemo"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们的 MainActivity 继承自 <code>ReactActivity</code>，ReactActivity作为JS页面的容器。最后我们的前端界面的内容，就是渲染到了这个容器上面。（ReactActivity 后面介绍）</p>
<h3 id="应用启动流程"><a href="#应用启动流程" class="headerlink" title="应用启动流程"></a>应用启动流程</h3><p>我们开始分析 <code>ReactActivity</code>。<code>ReactAcivity</code> 本身继承自 Activity，并实现了其生命周期。本质上其什么也没有做，都是委托给了 <code>ReactActivityDelegate</code>。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ReactActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span></div><div class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">DefaultHardwareBackBtnHandler</span>, <span class="title">PermissionAwareActivity</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ReactActivityDelegate mDelegate;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ReactActivity</span><span class="params">()</span> </span>&#123;</div><div class="line">        mDelegate = createReactActivityDelegate();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 获取渲染的 RN 组件名称</span></div><div class="line">    <span class="keyword">protected</span> <span class="meta">@Nullable</span> <span class="function">String <span class="title">getMainComponentName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">protected</span> ReactActivityDelegate <span class="title">createReactActivityDelegate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReactActivityDelegate(<span class="keyword">this</span>, getMainComponentName());</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        <span class="comment">// 委托给 ReactActivityDelegate 来实现</span></div><div class="line">        mDelegate.onCreate(savedInstanceState);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其本身所有行为都交给了 <code>ReactActivityDelegate</code> 来处理，我们只需要关心 <code>ReactActivityDelegate</code> 即可。 </p>
<h4 id="ReactActivityDelegate"><a href="#ReactActivityDelegate" class="headerlink" title="ReactActivityDelegate"></a>ReactActivityDelegate</h4><p>我们先来看，ReactActivity 的 <code>onCreate</code> 方法，本质上映射到了 <code>ReactActivityDelegate</code> 的 onCreate。</p>
<h5 id="ReactActivityDelegate-onCreate-Bundle-savedInstanceState"><a href="#ReactActivityDelegate-onCreate-Bundle-savedInstanceState" class="headerlink" title="ReactActivityDelegate.onCreate(Bundle savedInstanceState)"></a>ReactActivityDelegate.onCreate(Bundle savedInstanceState)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReactActivityDelegate</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReactActivityDelegate</span><span class="params">(Activity activity, @Nullable String mainComponentName)</span> </span>&#123;</div><div class="line">        mActivity = activity;</div><div class="line">        mMainComponentName = mainComponentName;</div><div class="line">        mFragmentActivity = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (mMainComponentName != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// 载入 app 页面</span></div><div class="line">            loadApp(mMainComponentName);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// ...开发调试配置</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadApp</span><span class="params">(String appKey)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (mReactRootView != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot loadApp while app is already running."</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 创建ReactRootView作为根视图 ,它本质上是一个FrameLayout</span></div><div class="line">        mReactRootView = createRootView();</div><div class="line">        <span class="comment">// 启动应用程序</span></div><div class="line">        mReactRootView.startReactApplication(</div><div class="line">            getReactNativeHost().getReactInstanceManager(),</div><div class="line">            appKey,</div><div class="line">            getLaunchOptions());</div><div class="line">        <span class="comment">// mActivity.setContentView</span></div><div class="line">        getPlainActivity().setContentView(mReactRootView);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建阶段主要了做了如下几个事情：</p>
<ol>
<li>创建ReactRootView作为应用的容器，它本质上是一个FrameLayout。</li>
<li>调用ReactRootView.startReactApplication()进一步执行应用启动流程。</li>
<li>调用Activity.setContentView() 将创建的 ReactRootView 作为 ReactActivity的content view。</li>
</ol>
<p>所以呢，RN 其实被渲染到了一个 <code>ReactRootView</code> 上面，他可以被用在 Android 任何地方（比如 RN 视图和 原生视图组合）。接下来我们看启动过程 <code>startReactApplication</code>。</p>
<h5 id="ReactRootView-startReactApplication-ReactInstanceManager-reactInstanceManager-String-moduleName-Nullable-Bundle-launchOptions"><a href="#ReactRootView-startReactApplication-ReactInstanceManager-reactInstanceManager-String-moduleName-Nullable-Bundle-launchOptions" class="headerlink" title="ReactRootView.startReactApplication(ReactInstanceManager reactInstanceManager, String moduleName, @Nullable Bundle launchOptions)"></a>ReactRootView.startReactApplication(ReactInstanceManager reactInstanceManager, String moduleName, @Nullable Bundle launchOptions)</h5><p>简要代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReactRootView</span> <span class="keyword">extends</span> <span class="title">SizeMonitoringFrameLayout</span></span></div><div class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">RootView</span>, <span class="title">MeasureSpecProvide</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startReactApplication</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">        ReactInstanceManager reactInstanceManager,</span></span></div><div class="line"><span class="function"><span class="params">        String moduleName,</span></span></div><div class="line"><span class="function"><span class="params">        @Nullable Bundle initialProperties,</span></span></div><div class="line"><span class="function"><span class="params">        @Nullable String initialUITemplate)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 判断是否运行在主线程上</span></div><div class="line">            UiThreadUtil.assertOnUiThread();</div><div class="line">            mReactInstanceManager = reactInstanceManager;</div><div class="line">            mJSModuleName = moduleName;</div><div class="line">            mAppProperties = initialProperties;</div><div class="line">            mInitialUITemplate = initialUITemplate;</div><div class="line"></div><div class="line">            <span class="comment">// 创建RN应用上下文</span></div><div class="line">            <span class="keyword">if</span> (!mReactInstanceManager.hasStartedCreatingInitialContext()) &#123;</div><div class="line">                mReactInstanceManager.createReactContextInBackground();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            attachToReactInstanceManager();</div><div class="line"></div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参数信息：</p>
<ul>
<li>ReactInstanceManager reactInstanceManager：ReactInstanceManager 实例</li>
<li>String moduleName：模块的名字，对应ReactActivity.getMainComponentName()与AppRegistry.registerComponent()</li>
<li>Bundle launchOptions：Bundle 类型，可以在 startActivity 时候传递参数到 JS 层</li>
</ul>
<p>（UiThreadUtil 主要包装了两个方法：UiThreadUtil.isOnUiThread()，UiThreadUtil.runOnUiThread(Runnable runnable)）</p>
<p>主要还是调用了 ReactInstanceManager 上的 <code>createReactContextInBackground</code> 方法。</p>
<h5 id="ReactInstanceManager-createReactContextInBackground"><a href="#ReactInstanceManager-createReactContextInBackground" class="headerlink" title="ReactInstanceManager.createReactContextInBackground()"></a>ReactInstanceManager.createReactContextInBackground()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReactInstanceManager</span> </span>&#123;</div><div class="line"> <span class="comment">/**</span></div><div class="line"><span class="comment">  * Trigger react context initialization asynchronously in a background async task. This enables</span></div><div class="line"><span class="comment">  * applications to pre-load the application JS, and execute global code before</span></div><div class="line"><span class="comment">  * &#123;<span class="doctag">@link</span> ReactRootView&#125; is available and measured. This should only be called the first time the</span></div><div class="line"><span class="comment">  * application is set up, which is enforced to keep developers from accidentally creating their</span></div><div class="line"><span class="comment">  * application multiple times without realizing it.</span></div><div class="line"><span class="comment">  *</span></div><div class="line"><span class="comment">  * Called from UI thread.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"> <span class="meta">@ThreadConfined</span>(UI)</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createReactContextInBackground</span><span class="params">()</span> </span>&#123;</div><div class="line">    Log.d(ReactConstants.TAG, <span class="string">"ReactInstanceManager.createReactContextInBackground()"</span>);</div><div class="line">    Assertions.assertCondition(</div><div class="line">        !mHasStartedCreatingInitialContext,</div><div class="line">        <span class="string">"createReactContextInBackground should only be called when creating the react "</span> +</div><div class="line">            <span class="string">"application for the first time. When reloading JS, e.g. from a new file, explicitly"</span> +</div><div class="line">            <span class="string">"use recreateReactContextInBackground"</span>);</div><div class="line"></div><div class="line">    mHasStartedCreatingInitialContext = <span class="keyword">true</span>;</div><div class="line">    recreateReactContextInBackgroundInner();</div><div class="line">  &#125;</div><div class="line">  <span class="meta">@ThreadConfined</span>(UI)</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recreateReactContextInBackgroundInner</span><span class="params">()</span> </span>&#123;</div><div class="line">    UiThreadUtil.assertOnUiThread();</div><div class="line"></div><div class="line">    <span class="comment">// 这里有一大堆代码，都是在开发模式下在线更新 bundle (mDevSupportManager.handleReloadJS())，调用开发菜单等调试功能的地方</span></div><div class="line">    <span class="comment">// 但是实际上都调用到了 下面那句话</span></div><div class="line">    <span class="keyword">if</span> (mUseDeveloperSupport &amp;&amp; mJSMainModulePath != <span class="keyword">null</span>) &#123;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 线上模式</span></div><div class="line">    recreateReactContextInBackgroundFromBundleLoader();</div><div class="line">  &#125;</div><div class="line">  <span class="meta">@ThreadConfined</span>(UI)</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recreateReactContextInBackgroundFromBundleLoader</span><span class="params">()</span> </span>&#123;</div><div class="line">    recreateReactContextInBackground(mJavaScriptExecutorFactory, mBundleLoader);</div><div class="line">  &#125;</div><div class="line">  <span class="meta">@ThreadConfined</span>(UI)</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recreateReactContextInBackground</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">    JavaScriptExecutorFactory jsExecutorFactory,</span></span></div><div class="line"><span class="function"><span class="params">    JSBundleLoader jsBundleLoader)</span> </span>&#123;</div><div class="line">    UiThreadUtil.assertOnUiThread();</div><div class="line"></div><div class="line">    <span class="comment">// ReactContextInitParams 类就是实现了一个断言，两个参数必须有</span></div><div class="line">    <span class="keyword">final</span> ReactContextInitParams initParams = <span class="keyword">new</span> ReactContextInitParams(</div><div class="line">      jsExecutorFactory,</div><div class="line">      jsBundleLoader);</div><div class="line">    <span class="keyword">if</span> (mCreateReactContextThread == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="comment">// 初始化一个异步任务，创建 ReactContextInitAsyncTask</span></div><div class="line">      runCreateReactContextOnNewThread(initParams);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// 创建ReactContext的后台任务已经开启，缓存initParams在队列中等待重新创建ReactContext</span></div><div class="line">      mPendingReactContextInitParams = initParams;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ReactContextInitParams</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">    JavaScriptExecutorFactory jsExecutorFactory,</span></span></div><div class="line"><span class="function"><span class="params">    JSBundleLoader jsBundleLoader)</span> </span>&#123;</div><div class="line">    mJsExecutorFactory = Assertions.assertNotNull(jsExecutorFactory);</div><div class="line">    mJsBundleLoader = Assertions.assertNotNull(jsBundleLoader);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里创建过程从上到下执行，最后调用到 <code>runCreateReactContextOnNewThread</code>。该方法实际上就是新启了一个线程，来执行如下内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> ReactApplicationContext reactApplicationContext =</div><div class="line">                    createReactContext(</div><div class="line">                        initParams.getJsExecutorFactory().create(),</div><div class="line">                        initParams.getJsBundleLoader());</div><div class="line"><span class="comment">// 如果创建完毕 createContext 则回调这个线程</span></div><div class="line">Runnable setupReactContextRunnable =</div><div class="line">                      <span class="keyword">new</span> Runnable() &#123;</div><div class="line">                        <span class="meta">@Override</span></div><div class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                          <span class="keyword">try</span> &#123;</div><div class="line">                            setupReactContext(reactApplicationContext);</div><div class="line">                          &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                            mDevSupportManager.handleException(e);</div><div class="line">                          &#125;</div><div class="line">                        &#125;</div><div class="line">                      &#125;;</div><div class="line"><span class="comment">// c++ 层回调</span></div><div class="line">                  reactApplicationContext.runOnNativeModulesQueueThread(setupReactContextRunnable);</div><div class="line">``` </div><div class="line"></div><div class="line">完成 ReactApplicationContext 的创建。我们看传入的两个参数：</div><div class="line"></div><div class="line">* JsExecutorFactory jsExecutor：当该类被加载时，它会自动去加载<span class="string">"reactnativejnifb.so"</span>库，并会调用 Native 方</div><div class="line">法 initHybrid() 初始化 C++层 RN 与 JSC通信的框架。</div><div class="line">* JSBundleLoader jsBundleLoader：缓存了JSBundle的信息，封装了上层加载JSBundle的相关接口，CatalystInstance通过其间接调用ReactBridge 去加载J S文件，不同的场景会创建不同的加载器，具体可以查看类JSBundleLoader。</div><div class="line"></div><div class="line"></div><div class="line">##### ReactInstanceManager.createReactContext( JavaScriptExecutor jsExecutor, JSBundleLoader jsBundleLoader)</div><div class="line">简要代码如下</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">```java</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReactInstanceManager</span> </span>&#123;</div><div class="line">      <span class="function"><span class="keyword">private</span> ReactApplicationContext <span class="title">createReactContext</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">      JavaScriptExecutor jsExecutor,</span></span></div><div class="line"><span class="function"><span class="params">      JSBundleLoader jsBundleLoader)</span> </span>&#123;</div><div class="line">    <span class="comment">// ReactApplicationContext 是 ReactContext的包装类。实际上调用的就是 ReactContext。</span></div><div class="line">    <span class="keyword">final</span> ReactApplicationContext reactContext = <span class="keyword">new</span> ReactApplicationContext(mApplicationContext);</div><div class="line"></div><div class="line">    NativeModuleCallExceptionHandler exceptionHandler = mNativeModuleCallExceptionHandler != <span class="keyword">null</span></div><div class="line">        ? mNativeModuleCallExceptionHandler</div><div class="line">        : mDevSupportManager;</div><div class="line">    reactContext.setNativeModuleCallExceptionHandler(exceptionHandler);</div><div class="line">    <span class="comment">// 创建 JavaModule 注册表Builder，用来创建JavaModule注册表，JavaModule注册表将所有的JavaModule注册到CatalystInstance中。</span></div><div class="line">    <span class="comment">// mPackages 就是 ReactNativeHost 那里 getPackages 的各种模块 ReactPackage</span></div><div class="line">    NativeModuleRegistry nativeModuleRegistry = processPackages(reactContext, mPackages, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 创建 CatalystInstance </span></div><div class="line">    CatalystInstanceImpl.Builder catalystInstanceBuilder = <span class="keyword">new</span> CatalystInstanceImpl.Builder()</div><div class="line">      .setReactQueueConfigurationSpec(ReactQueueConfigurationSpec.createDefault())</div><div class="line">      .setJSExecutor(jsExecutor)</div><div class="line">      .setRegistry(nativeModuleRegistry)</div><div class="line">      .setJSBundleLoader(jsBundleLoader)</div><div class="line">      .setNativeModuleCallExceptionHandler(exceptionHandler);</div><div class="line"></div><div class="line">    <span class="keyword">final</span> CatalystInstance catalystInstance;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      catalystInstance = catalystInstanceBuilder.build();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE);</div><div class="line">      ReactMarker.logMarker(CREATE_CATALYST_INSTANCE_END);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (mJSIModulePackage != <span class="keyword">null</span>) &#123;</div><div class="line">      catalystInstance.addJSIModules(mJSIModulePackage</div><div class="line">        .getJSIModules(reactContext, catalystInstance.getJavaScriptContextHolder()));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (mBridgeIdleDebugListener != <span class="keyword">null</span>) &#123;</div><div class="line">      catalystInstance.addBridgeIdleDebugListener(mBridgeIdleDebugListener);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 通过CatalystInstance开始加载JS Bundle</span></div><div class="line">    <span class="comment">// runJSBundle 在 CatalysInstanceImp 中</span></div><div class="line">    catalystInstance.runJSBundle();</div><div class="line">    <span class="comment">// 关联ReacContext与CatalystInstance</span></div><div class="line">    reactContext.initializeWithInstance(catalystInstance);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">return</span> reactContext;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>主要创建 JavaModule 表，交给 CatalystInstance 管理</li>
<li>处理ReactPackage，将JavaModule与JavaScriptModule放进各自对应的注册表里。</li>
<li>通过上面jsExecutor、nativeModuleRegistry、jsModulesRegistry、jsBundleLoader、exceptionHandler等参数创建CatalystInstance实例。</li>
<li>关联 ReactContext 与 CatalystInstance，并将JS Bundle加载进来，等待ReactContextInitAsyncTask结束以后调用JS入口渲染页面。</li>
<li>最后调用 CatalystInstance.runJSBundle()去加载 JS Bundle</li>
</ol>
<p>最终由 C++ 中的JSCExecutor.cpp 完成了 JS Bundle 的加载。<br>这里起到作用的就是 <code>CatalystInstance</code> 他由 CatalystInstanceImpl 构造而成。查看代码：</p>
<h4 id="CatalystInstanceImpl"><a href="#CatalystInstanceImpl" class="headerlink" title="CatalystInstanceImpl"></a>CatalystInstanceImpl</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CatalystInstanceImpl</span> <span class="keyword">implements</span> <span class="title">CatalystInstance</span> </span>&#123;</div><div class="line">  <span class="comment">// C++ parts</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HybridData mHybridData;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> HybridData <span class="title">initHybrid</span><span class="params">()</span></span>;</div><div class="line">  <span class="comment">// 在C++层初始化通信桥ReactBridge</span></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">initializeBridge</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">      ReactCallback callback,</span></span></div><div class="line"><span class="function"><span class="params">      JavaScriptExecutor jsExecutor,</span></span></div><div class="line"><span class="function"><span class="params">      MessageQueueThread jsQueue,</span></span></div><div class="line"><span class="function"><span class="params">      MessageQueueThread moduleQueue,</span></span></div><div class="line"><span class="function"><span class="params">      Collection&lt;JavaModuleWrapper&gt; javaModules,</span></span></div><div class="line"><span class="function"><span class="params">      Collection&lt;ModuleHolder&gt; cxxModules)</span></span>;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">CatalystInstanceImpl</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">    <span class="keyword">final</span> ReactQueueConfigurationSpec reactQueueConfigurationSpec,</span></span></div><div class="line"><span class="function"><span class="params">    <span class="keyword">final</span> JavaScriptExecutor jsExecutor,</span></span></div><div class="line"><span class="function"><span class="params">    <span class="keyword">final</span> NativeModuleRegistry nativeModuleRegistry,</span></span></div><div class="line"><span class="function"><span class="params">    <span class="keyword">final</span> JSBundleLoader jsBundleLoader,</span></span></div><div class="line"><span class="function"><span class="params">    NativeModuleCallExceptionHandler nativeModuleCallExceptionHandler)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// Native方法，用来创建JNI相关状态，并返回mHybridData。</span></div><div class="line">    mHybridData = initHybrid();</div><div class="line">    <span class="comment">// RN中的三个线程：Native Modules Thread、JS Thread、UI Thread，都是通过Handler来管理的。</span></div><div class="line">    mReactQueueConfiguration = ReactQueueConfigurationImpl.create(</div><div class="line">        reactQueueConfigurationSpec,</div><div class="line">        <span class="keyword">new</span> NativeExceptionHandler());</div><div class="line">    mBridgeIdleListeners = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</div><div class="line">    mNativeModuleRegistry = nativeModuleRegistry;</div><div class="line">    mJSModuleRegistry = <span class="keyword">new</span> JavaScriptModuleRegistry();</div><div class="line">    mJSBundleLoader = jsBundleLoader;</div><div class="line">    mNativeModuleCallExceptionHandler = nativeModuleCallExceptionHandler;</div><div class="line">    mNativeModulesQueueThread = mReactQueueConfiguration.getNativeModulesQueueThread();</div><div class="line">    mTraceListener = <span class="keyword">new</span> JSProfilerTraceListener(<span class="keyword">this</span>);</div><div class="line">    <span class="comment">// Native方法，调用initializeBridge()方法，并创建BridgeCallback实例，初始化Bridge。</span></div><div class="line">    initializeBridge(</div><div class="line">      <span class="keyword">new</span> BridgeCallback(<span class="keyword">this</span>),</div><div class="line">      jsExecutor,</div><div class="line">      mReactQueueConfiguration.getJSQueueThread(),</div><div class="line">      mNativeModulesQueueThread,</div><div class="line">      mNativeModuleRegistry.getJavaModules(<span class="keyword">this</span>),</div><div class="line">      mNativeModuleRegistry.getCxxModules());</div><div class="line"></div><div class="line">    mJavaScriptContextHolder = <span class="keyword">new</span> JavaScriptContextHolder(getJavaScriptContext());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>ReactCallback callback：CatalystInstanceImpl的静态内部类ReactCallback，负责接口回调。</li>
<li>JavaScriptExecutor jsExecutor：JS执行器，将JS的调用传递给C++层。</li>
<li>MessageQueueThread jsQueue.getJSQueueThread()：JS线程，通过mReactQueueConfiguration.getJSQueueThread()获得，</li>
<li>Collection<javamodulewrapper> javaModules：java modules，来源于mJavaRegistry.getJavaModules(this)。</javamodulewrapper></li>
<li>Collection<moduleholder> cxxModules)：c++ modules，来源于mJavaRegistry.getCxxModules()。</moduleholder></li>
</ul>
<p>CatalystInstanceImpl 创建好，调用 runJSBundle 来加载js</p>
<h5 id="CatalystInstanceImpl-runJSBundle"><a href="#CatalystInstanceImpl-runJSBundle" class="headerlink" title="CatalystInstanceImpl.runJSBundle()"></a>CatalystInstanceImpl.runJSBundle()</h5><p>这个代码最后会调用，初始化创建 ReactInstanceManager -&gt; createReactContext 传入的 <code>JSBundleLoader bundleLoader</code> 上的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 调用加载器加载JS Bundle，不同情况下加载器各不相同。</span></div><div class="line">mJSBundleLoader.loadScript(CatalystInstanceImpl.<span class="keyword">this</span>);</div></pre></td></tr></table></figure>
<p>bundleLoader 由 <code>ReactInstanceManagerBuilder.setJSBundleFile(String jsBundleFile)</code> 创建而来 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public ReactInstanceManagerBuilder setJSBundleFile(<span class="built_in">String</span> jsBundleFile) &#123;</div><div class="line">    <span class="keyword">if</span> (jsBundleFile.startsWith(<span class="string">"assets://"</span>)) &#123;</div><div class="line">        mJSBundleAssetUrl = jsBundleFile;</div><div class="line">        mJSBundleLoader = <span class="literal">null</span>;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> setJSBundleLoader(JSBundleLoader.createFileLoader(jsBundleFile));</div><div class="line">&#125;</div><div class="line">public ReactInstanceManagerBuilder setJSBundleLoader(JSBundleLoader jsBundleLoader) &#123;</div><div class="line">    mJSBundleLoader = jsBundleLoader;</div><div class="line">    mJSBundleAssetUrl = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>JSBundleLoader 提供了多种加载方案，通过 <code>ReactInstanceManagerBuilder.setJSBundleFile(String jsBundleFile)</code> 调用的加载器如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">JSBundleLoader</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JSBundleLoader <span class="title">createFileLoader</span><span class="params">(<span class="keyword">final</span> String fileName)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> createFileLoader(fileName, fileName, <span class="keyword">false</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JSBundleLoader <span class="title">createFileLoader</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">      <span class="keyword">final</span> String fileName,</span></span></div><div class="line"><span class="function"><span class="params">      <span class="keyword">final</span> String assetUrl,</span></span></div><div class="line"><span class="function"><span class="params">      <span class="keyword">final</span> <span class="keyword">boolean</span> loadSynchronously)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JSBundleLoader() &#123;</div><div class="line">      <span class="meta">@Override</span></div><div class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">loadScript</span><span class="params">(CatalystInstanceImpl instance)</span> </span>&#123;</div><div class="line">        instance.loadScriptFromFile(fileName, assetUrl, loadSynchronously);</div><div class="line">        <span class="keyword">return</span> fileName;</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">/** Loads the script, returning the URL of the source it loaded. */</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">loadScript</span><span class="params">(CatalystInstanceImpl instance)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，在这种加载器下，最后调用的是 <code>CatalystInstanceImpl</code> 上的 <code>loadScriptFromFile</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CatalystInstanceImpl</span> <span class="keyword">implements</span> <span class="title">CatalystInstance</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">jniLoadScriptFromFile</span><span class="params">(String fileName, String sourceURL, <span class="keyword">boolean</span> loadSynchronously)</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">loadScriptFromFile</span><span class="params">(String fileName, String sourceURL, <span class="keyword">boolean</span> loadSynchronously)</span> </span>&#123;</div><div class="line">    mSourceURL = sourceURL;</div><div class="line">    <span class="comment">// C++ 方法</span></div><div class="line">    jniLoadScriptFromFile(fileName, sourceURL, loadSynchronously);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>CatalystInstanceImpl.java 最终还是调用C++层的 CatalystInstanceImpl.cpp去加载JS Bundle。</p>
<p>接下来就是 <code>C++</code> 部分了，不太会了呢。</p>
<h5 id="ReactInstanceManager-setupReactContext-final-ReactApplicationContext-reactContext"><a href="#ReactInstanceManager-setupReactContext-final-ReactApplicationContext-reactContext" class="headerlink" title="ReactInstanceManager.setupReactContext(final ReactApplicationContext reactContext)"></a>ReactInstanceManager.setupReactContext(final ReactApplicationContext reactContext)</h5><p>当 <code>createContext</code> 调用完毕后，C++ 会回调了 <code>setupReactContextRunnable</code> 线程，该线程调用的就是 <code>setupReactContext</code> 方法。代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReactInstanceManager</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setupReactContext</span><span class="params">(<span class="keyword">final</span> ReactApplicationContext reactContext)</span> </span>&#123;</div><div class="line">    Log.d(ReactConstants.TAG, <span class="string">"ReactInstanceManager.setupReactContext()"</span>);</div><div class="line">    ReactMarker.logMarker(PRE_SETUP_REACT_CONTEXT_END);</div><div class="line">    ReactMarker.logMarker(SETUP_REACT_CONTEXT_START);</div><div class="line">    Systrace.beginSection(TRACE_TAG_REACT_JAVA_BRIDGE, <span class="string">"setupReactContext"</span>);</div><div class="line">    <span class="keyword">synchronized</span> (mAttachedRootViews) &#123;</div><div class="line">      <span class="keyword">synchronized</span> (mReactContextLock) &#123;</div><div class="line">        mCurrentReactContext = Assertions.assertNotNull(reactContext);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      CatalystInstance catalystInstance =</div><div class="line">          Assertions.assertNotNull(reactContext.getCatalystInstance());</div><div class="line">      <span class="comment">// 执行Native Java module的初始化</span></div><div class="line">      catalystInstance.initialize();</div><div class="line">      <span class="comment">// 重置DevSupportManager的ReactContext</span></div><div class="line">      mDevSupportManager.onNewReactContextCreated(reactContext);</div><div class="line">      <span class="comment">// 内存状态回调设置</span></div><div class="line">      mMemoryPressureRouter.addMemoryPressureListener(catalystInstance);</div><div class="line">      <span class="comment">// 复位生命周期 (和这个有关 LifecycleState.RESUMED)</span></div><div class="line">      moveReactContextToCurrentLifecycleState();</div><div class="line"></div><div class="line">      ReactMarker.logMarker(ATTACH_MEASURED_ROOT_VIEWS_START);</div><div class="line">      <span class="keyword">for</span> (ReactRootView rootView : mAttachedRootViews) &#123;</div><div class="line">        attachRootViewToInstance(rootView);</div><div class="line">      &#125;</div><div class="line">      ReactMarker.logMarker(ATTACH_MEASURED_ROOT_VIEWS_END);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ReactInstanceEventListener[] listeners =</div><div class="line">      <span class="keyword">new</span> ReactInstanceEventListener[mReactInstanceEventListeners.size()];</div><div class="line">    <span class="keyword">final</span> ReactInstanceEventListener[] finalListeners =</div><div class="line">        mReactInstanceEventListeners.toArray(listeners);</div><div class="line"></div><div class="line">    UiThreadUtil.runOnUiThread(</div><div class="line">        <span class="keyword">new</span> Runnable() &#123;</div><div class="line">          <span class="meta">@Override</span></div><div class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">for</span> (ReactInstanceEventListener listener : finalListeners) &#123;</div><div class="line">              listener.onReactContextInitialized(reactContext);</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;);</div><div class="line">    Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE);</div><div class="line">    ReactMarker.logMarker(SETUP_REACT_CONTEXT_END);</div><div class="line">    reactContext.runOnJSQueueThread(</div><div class="line">        <span class="keyword">new</span> Runnable() &#123;</div><div class="line">          <span class="meta">@Override</span></div><div class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);</div><div class="line">            ReactMarker.logMarker(CHANGE_THREAD_PRIORITY, <span class="string">"js_default"</span>);</div><div class="line">          &#125;</div><div class="line">        &#125;);</div><div class="line">    reactContext.runOnNativeModulesQueueThread(</div><div class="line">        <span class="keyword">new</span> Runnable() &#123;</div><div class="line">          <span class="meta">@Override</span></div><div class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);</div><div class="line">          &#125;</div><div class="line">        &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>ReactInstanceManager.attachRootViewToInstance</code> 方法，重置 <code>ReactRootView</code> 内容，然后将ReactRootView作为根布局，作为根布局进行绘制。随后调用 <code>rootView.setRootViewTag(rootTag);</code> 设置内相关内容，调用 <code>rootView.runApplication()</code> 启动 js。</p>
<p><code>rootView.runApplication</code> 里面就是包装了一些启动参数 launchOptions 与 模块名 jsAppModuleName。然后最终调用了 </p>
<p><code>catalystInstance.getJSModule(AppRegistry.class).runApplication(jsAppModuleName, appParams)</code> 方法：</p>
<p>检查下这个代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * JS module interface - main entry point for launching React application for a given key.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AppRegistry</span> <span class="keyword">extends</span> <span class="title">JavaScriptModule</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">runApplication</span><span class="params">(String appKey, WritableMap appParameters)</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unmountApplicationComponentAtRootTag</span><span class="params">(<span class="keyword">int</span> rootNodeTag)</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">startHeadlessTask</span><span class="params">(<span class="keyword">int</span> taskId, String taskKey, WritableMap data)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据注释我们知道这有可能就是js层暴露给java的接口方法。?? (AppRegister.js)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章主要来探讨一下，RN 的启动过程都做了什么？同时简单的介绍下在 Android 中是如何实现 ReactNative 的。进而引出解决一个重要的问题，ReactNative 的预加载。&lt;/p&gt;
    
    </summary>
    
      <category term="大前端(无线)" scheme="http://yoursite.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF-%E6%97%A0%E7%BA%BF/"/>
    
    
      <category term="ReactNative" scheme="http://yoursite.com/tags/ReactNative/"/>
    
  </entry>
  
  <entry>
    <title>ReactNative 详解(三) 基础内容之小技巧</title>
    <link href="http://yoursite.com/2018/10/18/ReactNative%E5%9F%BA%E7%A1%803/"/>
    <id>http://yoursite.com/2018/10/18/ReactNative基础3/</id>
    <published>2018-10-18T07:30:26.000Z</published>
    <updated>2019-04-10T08:46:38.715Z</updated>
    
    <content type="html"><![CDATA[<p>前面两篇已经介绍完了 ReactNative 的基础内容：视图，手势等。基本页面开发应该就没问题了，本章我们介绍下 ReactNative 剩下的一些小技巧。</p>
<a id="more"></a>
<h2 id="InteractionManager-交互管理器"><a href="#InteractionManager-交互管理器" class="headerlink" title="InteractionManager 交互管理器"></a>InteractionManager 交互管理器</h2><p>想想我们在 js 中，为了保证交互动作，动画的流畅，就需要避免同时存在 js 密集执行的情况。在前端，我们一般不太好把握这个尺度。在前端延迟手段：</p>
<ol>
<li>requestAnimationFrame()：放到下一帧去做，一般绘制动画用</li>
<li>setTimeout(): 在稍后执行代码，不好把控时间</li>
<li>requestIdleCallback()：浏览器空闲时间处理，这个看着还不错。但是开启和结束的时间，有浏览器自行决定</li>
</ol>
<p>在 RN 中，提供了一个 Interactionmanager 可以将一些耗时较长的工作安排到所有互动或动画完成之后再进行。这样可以保证 JavaScript 动画的流畅运行。示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span>&lt;<span class="title">any</span>, <span class="title">any</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(props: any) &#123;</div><div class="line">        <span class="keyword">super</span>(props);</div><div class="line">        <span class="keyword">this</span>.state = &#123;</div><div class="line">            v: &#123;</div><div class="line">                width: <span class="number">50</span>,</div><div class="line">                height: <span class="number">50</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    runAnimate = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="comment">// 只有在动画结束后才会触发</span></div><div class="line">        InteractionManager.runAfterInteractions(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'动画结束了'</span>);</div><div class="line">        &#125;);</div><div class="line">        LayoutAnimation.linear();</div><div class="line">        <span class="keyword">this</span>.setState(&#123;</div><div class="line">            v: &#123;</div><div class="line">                width: <span class="number">200</span>,</div><div class="line">                height: <span class="number">200</span></div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;View&gt;</div><div class="line">                &lt;View style=&#123;[&#123;<span class="attr">backgroundColor</span>: <span class="string">'#ff0000'</span>&#125;, <span class="keyword">this</span>.state.v]&#125;&gt;&lt;/View&gt;</div><div class="line">                &lt;Button title=<span class="string">"运行动画"</span> onPress=&#123;() =&gt; &#123;<span class="keyword">this</span>.runAnimate()&#125;&#125;/&gt;</div><div class="line">            &lt;<span class="regexp">/View&gt;</span></div><div class="line"><span class="regexp">        )</span></div><div class="line"><span class="regexp">    &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure>
<p>我们也可以通过手动控制执行的时机：<br>在开始的时候创建句柄，只有手动清除句柄后，才会执行 <code>runAfterInteractions</code>        </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> handle = InteractionManager.createInteractionHandle();</div><div class="line"><span class="comment">// 执行动画... (`runAfterInteractions`中的任务现在开始排队等候)</span></div><div class="line"><span class="comment">// 在动画完成之后开始清除句柄：</span></div><div class="line">InteractionManager.clearInteractionHandle(handle);</div><div class="line"><span class="comment">// 在所有句柄都清除之后，现在开始依序执行队列中的任务</span></div></pre></td></tr></table></figure>
<h2 id="ScrollView-amp-amp-FlatList"><a href="#ScrollView-amp-amp-FlatList" class="headerlink" title="ScrollView &amp;&amp; FlatList"></a>ScrollView &amp;&amp; FlatList</h2><h3 id="ScrollView"><a href="#ScrollView" class="headerlink" title="ScrollView"></a>ScrollView</h3><p>ScrollView 类 Android 中的 ScrollView，会简单粗暴地把所有子元素一次性全部渲染出来。但是不适合长列表渲染。</p>
<p>常用属性如下：</p>
<ul>
<li>showsVerticalScrollIndicator：true|false，表示是否显示垂直滚动条；</li>
<li>horizontal：true|false，表示滚动方向，true表示横向滚动，false表示竖向滚动。</li>
<li>refreshControl：指定RefreshControl组件，用于为ScrollView提供下拉刷新功能，只能用于垂直视图。</li>
<li>scrollEnabled：当值为 false 则禁止滚动</li>
</ul>
<p>常用方法如下：</p>
<ul>
<li>onScrollBeginDrag：当用户开始拖动此视图时调用此函数。</li>
<li>onScroll：在滚动的过程中，每帧最多调用一次此回调函数。调用的频率可以用scrollEventThrottle属性来控制。(滚动距离：event.nativeEvent.contentOffset.x，event.nativeEvent.contentOffset.x)</li>
<li>onScrollEndDrag：当用户停止拖动此视图时调用此函数</li>
<li>scrollTo()：滚动到指定的x, y偏移处。第三个参数为是否启用平滑滚动动画</li>
</ul>
<h3 id="FlatView"><a href="#FlatView" class="headerlink" title="FlatView"></a>FlatView</h3><p>类似Android中的ListView或RecyclerView。和ScrollView不同的是，FlatList并不立即渲染所有元素，而是优先渲染屏幕上可见的元素。<br>FlatList组件必须的两个属性是data和renderItem,data是列表的数据源，而renderItem则从数据源中逐个解析数据，然后返回一个设定好格式的组件来渲染。<br>（详细使用可以参考文档）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面两篇已经介绍完了 ReactNative 的基础内容：视图，手势等。基本页面开发应该就没问题了，本章我们介绍下 ReactNative 剩下的一些小技巧。&lt;/p&gt;
    
    </summary>
    
      <category term="大前端(无线)" scheme="http://yoursite.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF-%E6%97%A0%E7%BA%BF/"/>
    
    
      <category term="ReactNative" scheme="http://yoursite.com/tags/ReactNative/"/>
    
  </entry>
  
  <entry>
    <title>ReactNative 详解(二) 基础内容之手势处理</title>
    <link href="http://yoursite.com/2018/10/16/ReactNative%E5%9F%BA%E7%A1%802/"/>
    <id>http://yoursite.com/2018/10/16/ReactNative基础2/</id>
    <published>2018-10-16T02:57:12.000Z</published>
    <updated>2019-04-10T08:46:44.282Z</updated>
    
    <content type="html"><![CDATA[<p>在上篇文章中，我们介绍了 ReactNative 的基础布局，动画相关内容。除此之外，我们还需要和元素有交互才可以。我们看到在 ReactNative 中，有些组件是自带交互事件的，比如 <code>button</code>, <code>Text</code> 就有 <code>onPress</code> 事件。但是我们在普通的 <code>View</code> 上面就没有对应的手势事件。且，向前端那些<code>DOM</code>的手势事件 <code>click</code>等都不存在的。为此，ReactNative 专门提供了几个直接相应处理事件的组件：TouchableHighlight，TouchableNativeFeedback，TouchableOpacity和TouchableWidthoutFeedback。</p>
<a id="more"></a>
<h2 id="Touchable-组件"><a href="#Touchable-组件" class="headerlink" title="Touchable* 组件"></a>Touchable* 组件</h2><p>ReactNative 为我们提供了几个常用的触控组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">TouchableHighlight,</div><div class="line">TouchableNativeFeedback,</div><div class="line">TouchableOpacity,</div><div class="line">TouchableWithoutFeedback</div></pre></td></tr></table></figure>
<p>他们的功能和使用方法基本类似，只是在Touch的时候反馈的效果不同。一般来说，你可以使用TouchableHighlight来制作按钮或者链接。注意此组件的背景会在用户手指按下时变暗。在 Android 上还可以使用TouchableNativeFeedback，它会在用户手指按下时形成类似墨水涟漪的视觉效果。ouchableOpacity会在用户手指按下时降低按钮的透明度，而不会改变背景的颜色。如果你想在处理点击事件的同时不显示任何视觉反馈，则需要使用TouchableWithoutFeedback。</p>
<p>触摸组件响应事件回调如下：</p>
<ol>
<li>onPress：类似前端的 click 事件</li>
<li>onPressIn：类似前端的 touchstart 事件</li>
<li>onPressOut：类似前端的 touchend 事件</li>
<li>onLongPress：长按事件，onPress -&gt; onLongPress</li>
</ol>
<p>这很前端了，嘿嘿。然而我们并不满足，我就是想在 <code>View</code> 等其他组件上绑定事件呢。</p>
<h2 id="手势相应系统"><a href="#手势相应系统" class="headerlink" title="手势相应系统"></a>手势相应系统</h2><p>在不支持事件处理的组件上添加事件，我们要完成对 <code>Responder</code> 的申请和释放(在 ReactNative 持有<code>Responder</code> 的才可以响应事件，且全局只有一个 <code>Responder</code>)。大致流程如下：</p>
<blockquote>
<p>申请成为触摸事件响应者 -&gt; 成为触摸事件响应者 -&gt; 处理触摸事件 -&gt; 释放触摸事件 -&gt; 触摸事件结束</p>
</blockquote>
<h3 id="申请"><a href="#申请" class="headerlink" title="申请"></a>申请</h3><p>首先我们要成为申请者，RN 提供了两个申请阶段：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 如果返回true就是申请成为触摸事件的响应者</span></div><div class="line">onStartShouldSetPanResponder: <span class="function">(<span class="params">evt, gestureState</span>) =&gt;</span> <span class="literal">true</span></div><div class="line"><span class="comment">// 如果返回true就是申请成为滑动过程中的响应者</span></div><div class="line">onMoveShouldSetPanResponder: <span class="function">(<span class="params">evt, gestureState</span>) =&gt;</span> <span class="literal">true</span></div></pre></td></tr></table></figure>
<h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><p>1.手势操作开始，可以理解为 <code>touchstart</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">onPanResponderGrant: <span class="function">(<span class="params">event, gestureState</span>) =&gt;</span> &#123;&#125;</div></pre></td></tr></table></figure>
<p>其中 event.nativeEvent 属性为:</p>
<ul>
<li>changedTouches - 在上一次事件之后，所有发生变化的触摸事件的数组集合（即上一次事件后，所有移动过的触摸点）</li>
<li>identifier - 触摸点的ID</li>
<li>locationX - 触摸点相对于父元素的横坐标</li>
<li>locationY - 触摸点相对于父元素的纵坐标</li>
<li>pageX - 触摸点相对于根元素的横坐标</li>
<li>pageY - 触摸点相对于根元素的纵坐标</li>
<li>target - 触摸点所在的元素ID</li>
<li>timestamp - 触摸事件的时间戳，可用于移动速度的计算</li>
<li>touches - 当前屏幕上的所有触摸点的集合 (多指触控用)</li>
</ul>
<p>gestureState 是封装好的，辅助我们计算的值：</p>
<ul>
<li>stateID - 触摸状态的ID。在屏幕上有至少一个触摸点的情况下，这个ID会一直有效。</li>
<li>moveX - 最近一次移动时的屏幕横坐标</li>
<li>moveY - 最近一次移动时的屏幕纵坐标</li>
<li>x0 - 当响应器产生时的屏幕坐标</li>
<li>y0 - 当响应器产生时的屏幕坐标</li>
<li>dx - 从触摸操作开始时的累计横向路程</li>
<li>dy - 从触摸操作开始时的累计纵向路程</li>
<li>vx - 当前的横向移动速度</li>
<li>vy - 当前的纵向移动速度</li>
<li>numberActiveTouches - 当前在屏幕上的有效触摸点的数量</li>
</ul>
<p>2.手势移动，类似 <code>touchmove</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">onPanResponderMove: <span class="function">(<span class="params">evt, gestureState</span>) =&gt;</span> &#123;&#125;</div></pre></td></tr></table></figure>
<p>3.手势结束，类似 <code>touchend</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">onPanResponderRelease: <span class="function">(<span class="params">evt, gestureState</span>) =&gt;</span> &#123;&#125;,</div></pre></td></tr></table></figure>
<p>4.另一个组件成为手势响应者，当前手势被取消</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">onPanResponderTerminate: <span class="function">(<span class="params">evt, gestureState</span>) =&gt;</span> &#123;&#125;</div></pre></td></tr></table></figure>
<p>基本流程如下：</p>
<img src="/2018/10/16/ReactNative基础2/a.png" alt="a.png" title=""> 
<h3 id="触摸事件拦截"><a href="#触摸事件拦截" class="headerlink" title="触摸事件拦截"></a>触摸事件拦截</h3><p>在前端开发汇总，事件模型分为冒泡和捕获两种。在 RN 中，事件响应类似冒泡，先从子组件开始。向上查找，找到第一个成为响应者的组件为止。如下，如果 A，B，C 都成为了事件响应者，那么只有 C 会触发。</p>
<img src="/2018/10/16/ReactNative基础2/b.png" alt="b.png" title=""> 
<p>但有的时候，我们就想让组件 A 能响应呢？这就需要一种劫持机制，RN 提供了一个劫持机制，也就是在触摸事件往下传递的时候，先询问父组件是否需要劫持，不给子组件传递事件。</p>
<p>在触摸事件开始（touchDown）的时候，RN 容器组件会回调此函数，询问组件是否要劫持事件响应者设置，自己接收事件处理，如果返回 true，表示需要劫持</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">onStartShouldSetPanResponderCapture: <span class="function">(<span class="params">evt, gestureState</span>) =&gt;</span> <span class="literal">true</span></div></pre></td></tr></table></figure>
<p>此函数类似，不过是在触摸移动事件（touchMove）询问容器组件是否劫持c</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">onMoveShouldSetPanResponderCapture: <span class="function">(<span class="params">evt, gestureState</span>) =&gt;</span> <span class="literal">true</span></div></pre></td></tr></table></figure>
<p>简单的是示意图如下：</p>
<img src="/2018/10/16/ReactNative基础2/c.png" alt="c.png" title=""> 
<p>其他的还有：<br><code>View.props.onResponderTerminationRequest: (evt) =&gt; true</code> - 有其他组件请求接替响应者，当前的View是否“放权”？返回true的话则释放响应者权力。</p>
<p><code>View.props.onResponderTerminate: (evt) =&gt; {}</code> - 响应者权力已经交出。这可能是由于其他View通过onResponderTerminationRequest请求的，也可能是由操作系统强制夺权（比如iOS上的控制中心或是通知中心）。</p>
<p>(注意：这里介绍的都是 <code>PanResponder</code>，这也是我们常用的，还有原始 <code>Redponder</code>，本质上就是现在所有方法去掉 <code>Pan</code> 关键字，同时删去 <code>gestureState</code> 回调参数)</p>
<h3 id="pointerEvents-属性"><a href="#pointerEvents-属性" class="headerlink" title="pointerEvents 属性"></a>pointerEvents 属性</h3><p>用于控制当前视图是否可以作为触控事件的目标。</p>
<ul>
<li>auto：视图可以作为触控事件的目标。</li>
<li>none：视图不能作为触控事件的目标。</li>
<li>box-none：视图自身不能作为触控事件的目标，但其子视图可以。类似于你在 CSS 中这样设置:</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box-none</span> &#123;</div><div class="line">     <span class="attribute">pointer-events</span>: none;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.box-none</span> * &#123;</div><div class="line">     <span class="attribute">pointer-events</span>: all;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>‘box-only’:视图自身可以作为触控事件的目标，但其子视图不能。类似于你在 CSS 中这样设置:</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box-only</span> &#123;</div><div class="line">     <span class="attribute">pointer-events</span>: all;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.box-only</span> * &#123;</div><div class="line">     <span class="attribute">pointer-events</span>: none;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="简单的应用"><a href="#简单的应用" class="headerlink" title="简单的应用"></a>简单的应用</h3><p>有了这些我们就可以建立一个简单的手势封装了，参考另一篇文章 <a href="/2016/08/23/移动端交互手势详解与实现/">移动端手势交互详解与实现</a></p>
<p>试着封装一个手势组件实现 <code>tap</code>，<code>press</code>, <code>doubletap</code> （做成高阶组件也行）。<br>简要代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div></pre></td><td class="code"><pre><div class="line">enum IGesStatue &#123;</div><div class="line">    TAPPING,</div><div class="line">    PRESSING,</div><div class="line">    PANNING,</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gesture</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span>&lt;<span class="title">IGestureProps</span>, <span class="title">any</span>&gt; </span>&#123;</div><div class="line">    private panResponder: PanResponderInstance | <span class="literal">null</span> =  <span class="literal">null</span>;</div><div class="line">    private gestures: IGestures = &#123;&#125;;</div><div class="line">    private _lastTap: any = &#123;&#125;;</div><div class="line">    <span class="keyword">constructor</span>(props: any) &#123;</div><div class="line">        <span class="keyword">super</span>(props);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 多个手指手势保存到 gestures中，gesturesp[touch.identifer] = touch</span></div><div class="line">    private addTouchPoint(touches: <span class="built_in">Array</span>&lt;NativeTouchEvent&gt;, <span class="attr">event</span>: any) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; touches.length; i++) &#123;</div><div class="line">            <span class="keyword">let</span> touch: NativeTouchEvent = touches[i];</div><div class="line">            <span class="keyword">let</span> startTouch = <span class="built_in">Object</span>.assign(&#123;&#125;, touch);</div><div class="line">            <span class="comment">// 用来保存手势触控信息</span></div><div class="line">            <span class="keyword">let</span> gesture: IGesture = &#123;</div><div class="line">                startTime: touch.timestamp,</div><div class="line">                lastTime: touch.timestamp,</div><div class="line">                identifier: touch.identifier,</div><div class="line">                target: touch.target,</div><div class="line">                <span class="comment">// 默认触摸</span></div><div class="line">                status: IGesStatue.TAPPING,</div><div class="line">                startTouch: startTouch,</div><div class="line">                lastTouch: startTouch,</div><div class="line">                duration: <span class="number">0</span>,</div><div class="line">                velocityX: <span class="number">0</span>,</div><div class="line">                velocityY: <span class="number">0</span>,</div><div class="line">                <span class="comment">// 定时器，500ms 后，应该触发 `press` 事件。</span></div><div class="line">                pressingHandler: setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (gesture.status === IGesStatue.TAPPING) &#123;</div><div class="line">                        <span class="comment">// 修改状态为 Pressing</span></div><div class="line">                        gesture.status = IGesStatue.PRESSING;</div><div class="line">                        <span class="comment">// 触发 press 事件</span></div><div class="line">                        <span class="keyword">if</span> (<span class="keyword">this</span>.props.press) &#123;</div><div class="line">                            <span class="keyword">this</span>.props.press(touch, event, <span class="literal">null</span>);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    clearTimeout(gesture.pressingHandler);</div><div class="line">                    gesture.pressingHandler = <span class="number">-1</span>;</div><div class="line">                &#125;, <span class="number">500</span>)</div><div class="line">            &#125;;</div><div class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.gestures[gesture.identifier]) &#123;</div><div class="line">                <span class="keyword">this</span>.gestures[gesture.identifier] = gesture;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 创建 PanResponder</span></div><div class="line">    componentWillMount() &#123;</div><div class="line">        <span class="keyword">this</span>.panResponder = PanResponder.create(&#123;</div><div class="line">            onStartShouldSetPanResponder: <span class="function"><span class="params">()</span> =&gt;</span> <span class="literal">true</span>,</div><div class="line">            onMoveShouldSetPanResponder: <span class="function"><span class="params">()</span> =&gt;</span> <span class="literal">true</span>,</div><div class="line">            onPanResponderGrant: <span class="function">(<span class="params">event, gestureState</span>) =&gt;</span> &#123;</div><div class="line">                <span class="keyword">let</span> touches: <span class="built_in">Array</span>&lt;NativeTouchEvent&gt; = event.nativeEvent.changedTouches;</div><div class="line">                <span class="keyword">this</span>.addTouchPoint(touches, event);</div><div class="line">            &#125;,</div><div class="line">            onPanResponderMove: <span class="function">(<span class="params">event, gestureState</span>) =&gt;</span> &#123;</div><div class="line">                <span class="comment">//....</span></div><div class="line">            &#125;,</div><div class="line">            onPanResponderRelease: <span class="function">(<span class="params">event, gestureState</span>) =&gt;</span> &#123;</div><div class="line">                <span class="keyword">let</span> touches: <span class="built_in">Array</span>&lt;NativeTouchEvent&gt; = event.nativeEvent.changedTouches;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; touches.length; i++) &#123;</div><div class="line">                    <span class="keyword">let</span> touch: NativeTouchEvent = touches[i];</div><div class="line">                    <span class="keyword">let</span> gesture: IGesture = <span class="keyword">this</span>.gestures[touch.identifier];</div><div class="line">                    <span class="comment">// 计算手势相对起始点移动距离</span></div><div class="line">                    <span class="keyword">let</span> disX: number = touch.pageX - gesture.startTouch.pageX,</div><div class="line">                        disY: number = touch.pageY - gesture.startTouch.pageY,</div><div class="line">                        distance: number = <span class="built_in">Math</span>.sqrt(disX ** <span class="number">2</span> + disY ** <span class="number">2</span>);</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (!gesture) &#123;</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// 清除 press 判断定时器</span></div><div class="line">                    <span class="keyword">if</span> (gesture.pressingHandler &gt; <span class="number">-1</span>) &#123;</div><div class="line">                        clearTimeout(gesture.pressingHandler);</div><div class="line">                        gesture.pressingHandler = <span class="number">-1</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// 如果当前触摸状态为 TAPPING 且 移动距离小于 5</span></div><div class="line">                    <span class="keyword">if</span> ((gesture.status === IGesStatue.TAPPING) &amp;&amp; distance &lt; <span class="number">5</span>) &#123;</div><div class="line">                        <span class="keyword">let</span> now = <span class="built_in">Date</span>.now();</div><div class="line">                        <span class="keyword">if</span> (<span class="keyword">this</span>.props.tap) &#123;</div><div class="line">                            <span class="keyword">this</span>.props.tap(touch, event, <span class="literal">null</span>);</div><div class="line">                        &#125;</div><div class="line">                        <span class="comment">// 两次点击间隔少于 300ms 触发 double</span></div><div class="line">                        <span class="keyword">if</span> (<span class="keyword">this</span>._lastTap &amp;&amp; now - <span class="keyword">this</span>._lastTap.timestamp &lt; <span class="number">300</span>) &#123;</div><div class="line">                            <span class="keyword">if</span> (<span class="keyword">this</span>.props.dbltap) &#123;</div><div class="line">                                <span class="keyword">this</span>.props.dbltap(touch, event, <span class="literal">null</span>);</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                        <span class="comment">// 记录上一次 tap 时间</span></div><div class="line">                        <span class="keyword">this</span>._lastTap = &#123;</div><div class="line">                            timestamp: now</div><div class="line">                        &#125;;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// 如果状态时 Pressing 则触发 pressend 事件</span></div><div class="line">                    <span class="keyword">if</span> (gesture.status === IGesStatue.PRESSING) &#123;</div><div class="line">                        <span class="keyword">if</span> (<span class="keyword">this</span>.props.pressEnd) &#123;</div><div class="line">                            <span class="keyword">this</span>.props.pressEnd(touch, event, <span class="literal">null</span>);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">delete</span> <span class="keyword">this</span>.gestures[touch.identifier];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">let</span> &#123;style, ...others&#125; = <span class="keyword">this</span>.props;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;View</div><div class="line">                style=&#123;style&#125;</div><div class="line">                &#123;...others&#125;</div><div class="line">                &#123;...this.panResponder!.panHandlers&#125;&gt;</div><div class="line">                &#123;<span class="keyword">this</span>.props.children&#125;</div><div class="line">            &lt;<span class="regexp">/View&gt;</span></div><div class="line"><span class="regexp">        )</span></div><div class="line"><span class="regexp">    &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://reactnative.cn/docs/0.50/panresponder.html" target="_blank" rel="external">PanResponder</a></li>
<li><a href="https://www.jianshu.com/p/ad7cee7f9011" target="_blank" rel="external">ReactNative中的手势冲突</a></li>
<li><a href="https://blog.csdn.net/u013718120/article/details/83213261" target="_blank" rel="external">React Native 手势触摸事件机制详解（进阶篇）</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上篇文章中，我们介绍了 ReactNative 的基础布局，动画相关内容。除此之外，我们还需要和元素有交互才可以。我们看到在 ReactNative 中，有些组件是自带交互事件的，比如 &lt;code&gt;button&lt;/code&gt;, &lt;code&gt;Text&lt;/code&gt; 就有 &lt;code&gt;onPress&lt;/code&gt; 事件。但是我们在普通的 &lt;code&gt;View&lt;/code&gt; 上面就没有对应的手势事件。且，向前端那些&lt;code&gt;DOM&lt;/code&gt;的手势事件 &lt;code&gt;click&lt;/code&gt;等都不存在的。为此，ReactNative 专门提供了几个直接相应处理事件的组件：TouchableHighlight，TouchableNativeFeedback，TouchableOpacity和TouchableWidthoutFeedback。&lt;/p&gt;
    
    </summary>
    
      <category term="大前端(无线)" scheme="http://yoursite.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF-%E6%97%A0%E7%BA%BF/"/>
    
    
      <category term="ReactNative" scheme="http://yoursite.com/tags/ReactNative/"/>
    
  </entry>
  
  <entry>
    <title>ReactNative 详解(一) 基础内容之视图相关</title>
    <link href="http://yoursite.com/2018/10/12/ReactNative%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/10/12/ReactNative基础/</id>
    <published>2018-10-12T08:14:59.000Z</published>
    <updated>2019-04-14T06:12:56.895Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要从前端的角度介绍 ReactNative 的用法，主要介绍 ReactNative 的基本用法(布局，样式，动画，手势，特殊API) 帮助大家快速掌握 ReactNaitve。而对于 ReactNative 封装的各种组件就不会过多深入了。（阅读建议：掌握 react 用法，熟悉前端）</p>
<a id="more"></a>
<h2 id="视图层"><a href="#视图层" class="headerlink" title="视图层"></a>视图层</h2><p>ReactNative 本质上开发和前端没有任何区别，仅仅是用了 ReactNative 专用的标签（组件）和一套精简过的 css 来完成的绘制。常用的类比如下：</p>
<ul>
<li><code>&lt;div&gt;</code> -&gt; <code>&lt;View&gt;</code></li>
<li><code>&lt;span&gt;</code> -&gt; <code>&lt;Text&gt;</code></li>
<li><code>&lt;input&gt;, &lt;textarea&gt;</code> -&gt; <code>&lt;TextInput&gt;</code></li>
<li><code>&lt;img&gt;</code> -&gt; <code>&lt;Image&gt;</code></li>
<li>其他封装的组件</li>
</ul>
<p>而，CSS 不再以 <code>.css</code> 文件的形式存在，而是变成一个通过 <code>StyleSheet</code> 创建的对象。引用的时候不再有 <code>className=&#39;xxx&#39;</code> 的写法，而统一为：<code>style={xxx}</code></p>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> &#123;View, Text, StyleSheet&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> Style = StyleSheet.create(&#123;</div><div class="line">    wrap: &#123;</div><div class="line">        justifyContent: <span class="string">'center'</span>,</div><div class="line">        height: <span class="string">'100%'</span>,</div><div class="line">        alignItems: <span class="string">'center'</span></div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;View style=&#123;Style.wrap&#125;&gt;</div><div class="line">                &lt;Text&gt;hello world&lt;<span class="regexp">/Text&gt;</span></div><div class="line"><span class="regexp">            &lt;/</span>View&gt;</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>效果如下：</p>
<img src="/2018/10/12/ReactNative基础/a.png" alt="a.png" title=""> 
<p>似不似很简单。</p>
<h3 id="Style-样式"><a href="#Style-样式" class="headerlink" title="Style 样式"></a>Style 样式</h3><p>ReactNative 使用的是阉割版的 css，需要用 StyleSheet.create 来创建样式。没有样式文件一说，统统 js。大部分，常用的 css 样式你都可以在 ReactNative 中找到(注意写成驼峰形式)。这里列举几个和 css 表现不太一致的样式：</p>
<h4 id="与-css-对比"><a href="#与-css-对比" class="headerlink" title="与 css 对比"></a>与 css 对比</h4><p>差异如下：</p>
<ol>
<li>fontWeight：去掉了 <code>bolder</code> 属性；</li>
<li>textAlignVertical：center 取代了 middle，并阉割了 baseline, sub 等值</li>
<li>textDecorationLine：阉割了 overline, blink 取值</li>
<li>textDecorationStyle： 阉割了 wavy 取值</li>
<li>position：阉割了 static, fixed 取值 （注意：在 ReactNative 里面，absolute 定位不再相对于父辈非 static 的元素定位，变简单了，直接相对于父元素定位。）</li>
<li>magrin： 只能定义一个参数，用以表示上、右、下、左4个方位的外补白</li>
<li>marginHorizontal：CSS中没有对应的属性，相当于同时设置marginRight和marginLeft</li>
<li>marginVertical：CSS中没有对应的属性，相当于同时设置marginTop和marginBottom</li>
<li>padding 同 margin</li>
<li>borderStyle：阉割了 none, hidden, double, groove, ridge, inset, outset 取值，且无方向分拆属性</li>
<li>shadowColor：对应 CSS 中的 box-shadow 属性中的颜色定义</li>
<li>shadowOffset：取值 {width: number, height: number} ，对应 CSS 中的 box-shadow 属性中的阴影偏移定义</li>
<li>shadowRadius：在 CSS 中，阴影的圆角大小取决于元素的圆角定义，不需要额外定义</li>
<li>shadowOpacity：对应 CSS 中的 box-shadow 属性中的阴影透明度定义</li>
<li>transform: 写法变成数组，例如平移x,y  [{translateX: number}, {translateY: number}]</li>
<li>Flex 系列后面单独说</li>
<li>overflow：阉割了 scroll, auto 取值</li>
<li>elevation： <code>Android</code> 特有，css 无</li>
<li>resizeMode：CSS 中没有对应的属性，可以参考 background-size 属性</li>
<li>tintColor：<code>iOS</code> 特有 CSS中没有对应的属性，iOS 图像上特殊的色彩，改变不透明像素的颜色</li>
<li>其他各段特有属性，不再一一列举</li>
</ol>
<p>取值：<br>在 ReactNative 中，没有 <code>px</code> 单位，统一为数字 <code>width: 10</code> ，长度单位为 dp。<br>这样，就省略了有前端在移动端适配这一环节，当然如果你想用 fixedWidth 方式适配也不是不行，ReactNative 提供了获取相应的计算值方案，这里不深入讲解，有兴趣的可参考下面资料：</p>
<ul>
<li><a href="https://www.jianshu.com/p/7836523b4d20" target="_blank" rel="external">React Native 分辨率适配(px,dp)</a></li>
<li><a href="https://www.cnblogs.com/JLZT1223/p/6784449.html" target="_blank" rel="external">Android开发中dp、dpi、px的区别</a></li>
</ul>
<p>同时，width，height 支持百分比单位 (低版本，并不支持)。</p>
<p>还有一点要注意的就是，ReactNative 并不支持样式继承。<br>对于样式覆盖，我们可以给 style=[{}, {}] 一个数组，倒是可以。</p>
<h4 id="flex-布局"><a href="#flex-布局" class="headerlink" title="flex 布局"></a>flex 布局</h4><p>在 ReactNative 不再有所谓的 <code>display</code> 属性。除了 <code>position</code>，布局上采用 <code>flexbox</code> 布局。熟悉前端的大家一定不陌生。但是在 ReactNative 中，默认的 <code>flexDirection</code> 方向为 <code>column</code> 纵向。且相应的属性仍有不少删减：</p>
<img src="/2018/10/12/ReactNative基础/b.png" alt="b.png" title="">
<h3 id="常用组件差别"><a href="#常用组件差别" class="headerlink" title="常用组件差别"></a>常用组件差别</h3><p>我们来看下，标签(组件)的差别。<br>在 ReactNative 中，文本必须被包裹在 <code>&lt;Text&gt;</code> 中（而在前端这并不是强制的，但是我推荐文本至少要包裹在 <code>span</code> 之类的内联元素中，而不是暴露在 <code>div</code> 中，当初了拖拽选蓝的时候，你会发现这个规则非常的有帮助）<br>前端常用的 <code>input, textarea</code> 处理输入，到了 ReactNative 统一为 <code>TextInput</code> 组件。</p>
<h4 id="TextInput"><a href="#TextInput" class="headerlink" title="TextInput"></a>TextInput</h4><p>默认为单行输入框，这就和 <code>input</code> 是一样的了， 大部分属性和前端一致。<br>列举几个不一样的常用属性：</p>
<ul>
<li>editable：如果为false，文本框是不可编辑的。默认值为true。</li>
<li>keyboardType：决定弹出何种软键盘类型，譬如numeric（纯数字键盘)</li>
<li>placeholderTextColor：占位字符串（placeholder）颜色</li>
<li>secureTextEntry：密码输入框效果</li>
<li>selection：取值 {start: number,end: number}，设置选中文字的范围（指定首尾的索引值）。如果首尾为同一索引位置，则相当于指定光标的位置</li>
<li>selectTextOnFocus：如果为true，当获得焦点的时候，所有的文字都会被选中</li>
<li>autoFocus：如果为true，在componentDidMount后会获得焦点。默认值为false</li>
</ul>
<p>可以看出，ReactNative 上文本输入框能力的强大，许多焦点设置都有对应的属性来实现，同时还额外提供了输入修正等能力。有兴趣的可以看文档。</p>
<p>那么，如果我想要多行文本输入 <code>textarea</code> 呢？<br>我们可以通过设置：<code>multiline = true</code> 来实现，同时我们还可以指定输入框最大行数：<code>numberOfLines</code>。另外对于多行文本输入，还提供了根据输入内容，自动转换成可点击URL的设定：<code>dataDetectorTypes</code>。</p>
<p>有了这些，我们还需要获得和设置文本框的值。设置我们可以通过 <code>value</code> 属性。但是获取就没有那么容易了，在 ReactNative 中，<code>TextInput</code> 最终会被转换成 Native 原生节点。并不是DOM节点，所以我们无法通过 <code>ref</code> 手段来像前端那样直接获取节点属性。所以我们必须采用受控组件的方式，来通过 <code>state</code> 来获取值。同样我们也可以监听 <code>onChangeText</code> 事件，来实时得到文本变化的内容 (这也是唯一的获取手段)。</p>
<p>TextInput 支持事件主要有：</p>
<ul>
<li>onChange：当文本框内容变化时调用此回调函数。回调参数为{ nativeEvent: { eventCount, target, text} }</li>
<li>onChangeText：onChange 的简化版，只有 text</li>
<li>onEndEditing：当文本输入结束后调用此回调函数</li>
<li>onKeyPress：当一个键被按下的时候调用此回调。传递给回调函数的参数为{ nativeEvent: { key: keyValue } }，其中keyValue即为被按下的键。会在onChange之前调用。注意：在Android上只有软键盘会触发此事件，物理键盘不会触发。</li>
<li>onSubmitEditing：此回调函数当软键盘的确定/提交按钮被按下的时候调用此函数，所传参数为{nativeEvent: {text, eventCount, target}}。如果multiline={true}，此属性不可用。</li>
</ul>
<p>同样还有一些和焦点，选蓝有关的事件，也不一一介绍了。总之很全面，嘿嘿。</p>
<p>在前端，我们还会关注一个问题就是，键盘弹起遮挡当前内容。这个可以通过使用 <code>KeyboardAvoidingView</code> 组件来解决。<br>当然了，熟悉 Android 的，我们也可以在 native 端设置 <code>android:windowSoftInputMode=&quot;adjustPan&quot;</code> 来解决哦。</p>
<p>键盘遮挡问题参考：</p>
<ul>
<li><a href="https://www.jianshu.com/p/020d2d1a2ab1" target="_blank" rel="external">https://www.jianshu.com/p/020d2d1a2ab1</a></li>
</ul>
<h4 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h4><p>基本格式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Image source=&#123;xxx&#125;&gt;</div></pre></td></tr></table></figure>
<p>和前端不同，在 ReactNative 中，如果使用静态图片地址，地址必须是静态字符串，不能包含变量。如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 正确</span></div><div class="line">&lt;Image source=&#123;<span class="built_in">require</span>(<span class="string">'./my-icon.png'</span>)&#125; /&gt;;</div><div class="line"></div><div class="line"><span class="comment">// 错误</span></div><div class="line"><span class="keyword">var</span> icon = <span class="keyword">this</span>.props.active ? <span class="string">'my-icon-active'</span> : <span class="string">'my-icon-inactive'</span>;</div><div class="line">&lt;Image source=&#123;<span class="built_in">require</span>(<span class="string">'./'</span> + icon + <span class="string">'.png'</span>)&#125; /&gt;;</div><div class="line"></div><div class="line"><span class="comment">// 正确</span></div><div class="line"><span class="keyword">var</span> icon = <span class="keyword">this</span>.props.active</div><div class="line">  ? <span class="built_in">require</span>(<span class="string">'./my-icon-active.png'</span>)</div><div class="line">  : <span class="built_in">require</span>(<span class="string">'./my-icon-inactive.png'</span>);</div><div class="line">&lt;Image source=&#123;icon&#125; /&gt;;</div></pre></td></tr></table></figure>
<p>这主要是因为，require 时在编译时期执行，而非运行使其执行。</p>
<p>如果加载网络图片，格式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;Image source=&#123;&#123;<span class="attr">uri</span>: <span class="string">'https://facebook.github.io/react/logo-og.png'</span>&#125;&#125;</div><div class="line">       style=&#123;&#123;<span class="attr">width</span>: <span class="number">400</span>, <span class="attr">height</span>: <span class="number">400</span>&#125;&#125; /&gt;</div></pre></td></tr></table></figure>
<p>注意，这里必须给图片尺寸(静态资源不需要)。同样 uri 后面可以跟，base64 的资源。 </p>
<p>ReactNative 还提供了对网络图片，更加精细的加载请求(设置HTTP头部等)，不过多介绍。<br>另外，对于混合资源等细节，请参阅文档。</p>
<p>思考一个问题，如果我们想加载一个背景图片呢？ReactNative 提供了 <code>ImageBackground</code> 组件来解决这一问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;ImageBackground source=&#123;...&#125; style=&#123;&#123;<span class="attr">width</span>: <span class="string">'100%'</span>, <span class="attr">height</span>: <span class="string">'100%'</span>&#125;&#125;&gt;</div><div class="line">    &lt;Text&gt;Inside&lt;<span class="regexp">/Text&gt;</span></div><div class="line"><span class="regexp">&lt;/</span>ImageBackground&gt;</div></pre></td></tr></table></figure>
<p>想了想，常用的视图有关就这么多了呢。剩下那些扩展组件，需要使用哪儿个查哪儿个就好了。</p>
<h2 id="改变视图"><a href="#改变视图" class="headerlink" title="改变视图"></a>改变视图</h2><p>有了布局等内容，我们现在思考如何改变某一部分样式。在前端改变 css 或者 style 即可。而在 ReactNative 中，第一种修改方式就是讲组件样式作为 <code>state</code> 来处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> Style = StyleSheet.create(&#123;</div><div class="line">    style1: &#123;</div><div class="line">        width: <span class="number">50</span>,</div><div class="line">        height: <span class="number">50</span>,</div><div class="line">        backgroundColor: <span class="string">'#ff0000'</span></div><div class="line">    &#125;,</div><div class="line">    style2: &#123;</div><div class="line">        width: <span class="number">50</span>,</div><div class="line">        height: <span class="number">50</span>,</div><div class="line">        backgroundColor: <span class="string">'#00ff00'</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(props) &#123;</div><div class="line">        <span class="keyword">this</span>.state = &#123;</div><div class="line">            style: Style.style2</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;View&gt;</div><div class="line">                &lt;View style=&#123;<span class="keyword">this</span>.state.style&#125;&gt;&lt;/View&gt;</div><div class="line">                &lt;Button onPress=&#123;()=&gt;&#123;<span class="keyword">this</span>.setState(&#123;<span class="attr">style</span>: Style.style2&#125;)&#125;&#125;/&gt;</div><div class="line">            &lt;<span class="regexp">/View&gt;</span></div><div class="line"><span class="regexp">        );</span></div><div class="line"><span class="regexp">    &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure>
<p>但是这里有个问题，我们知道触发 <code>setState</code> 会导致树 re-render。频繁的改变 <code>setState</code> 就会引起页面卡顿。这里我们就需要一种像直接操作 DOM 的方案，来改变一个组件的样式。</p>
<h3 id="setNativeProp"><a href="#setNativeProp" class="headerlink" title="setNativeProp"></a>setNativeProp</h3><p>在 React Native 中，setNativeProps就是等价于直接操作 DOM 节点的方法。setNativeProps 一般来说只是用来创建连续的动画，同时避免渲染组件结构和同步太多视图变化所带来的大量开销。<br>通过 ref 获得组件的引用，然后就可以直接使用了。距离如下： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// React16 语法</span></div><div class="line"><span class="keyword">this</span>.viewRef.current.setNativeProps(&#123;</div><div class="line">    width: <span class="number">100</span>,</div><div class="line">    height: <span class="number">100</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这里要注意，setNativeProps 只能直接作用在 RN 组件上，也就是说不能作用在自定义组件上面(这时候，请考虑 React.forwardRef 来转发 ref)。</p>
<p>setNativeProps 还可以用来直接改变 <code>TextInput</code> 的值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.textRef.setNativeProps(&#123;<span class="attr">text</span>: <span class="string">''</span>&#125;);</div></pre></td></tr></table></figure>
<h3 id="获取节点样式信息"><a href="#获取节点样式信息" class="headerlink" title="获取节点样式信息"></a>获取节点样式信息</h3><p>在前端有时候我们需要获取元素的宽高，在屏幕中的位置信息等。这个要怎么计算呢？</p>
<h4 id="屏幕宽高-Dimensions"><a href="#屏幕宽高-Dimensions" class="headerlink" title="屏幕宽高 Dimensions"></a>屏幕宽高 Dimensions</h4><p>获取屏幕宽高，React Native 提供了直接的获取方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123;width, height, scale, fontScale&#125; = Dimensions.get(<span class="string">'window'</span>);</div></pre></td></tr></table></figure>
<p>同样，如果我们想监听屏幕变化，<code>Dimensions.addEventListener(&#39;change&#39;, callback)</code> 即可。</p>
<h4 id="组件位置和大小"><a href="#组件位置和大小" class="headerlink" title="组件位置和大小"></a>组件位置和大小</h4><p>1.onLayout 事件属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">_onLayout(event)&#123;</div><div class="line">    <span class="keyword">let</span> &#123;x,y,width,height&#125; = e.nativeEvent.layout</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;View onLayout=&#123;(e) =&gt; <span class="keyword">this</span>._onLayout&#125;&gt;&lt;/View&gt;</div></pre></td></tr></table></figure>
<p>当组件重新渲染时，该方法就能重新获取到元素的宽高和位置信息，但是有时组件并没有重新render那么就获取不到正确的值，例如页面滚动，但是state没有发生变化，组件也就没有重新渲染。</p>
<p>2.元素自带measure方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;View ref=&#123;(view) =&gt; <span class="keyword">this</span>.myView = view&#125;&gt;&lt;/View&gt;</div></pre></td></tr></table></figure>
<p>然后需要注意的是需要在componentDidMount方法里面添加一个定时器，定时器里面再进行测量，否则拿到的数据都为0.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">componentDidMount()&#123;</div><div class="line">    setTimeOut(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">this</span>.myView.measure(<span class="function">(<span class="params">x, y, width, height, left, top</span>) =&gt;</span> &#123;</div><div class="line">        <span class="comment">//todo</span></div><div class="line">        &#125;)</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意不能用在自定义组件上面哦，但是下面这个方法可以用在自定义组件上面。</p>
<p>3.使用UIManager measure方法<br>首先引入：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;</div><div class="line">    UIManager,</div><div class="line">    findNodeHandle</div><div class="line">&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</div></pre></td></tr></table></figure>
<p>再加入：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;MyComponent ref=&#123;<span class="keyword">this</span>.myComponent&#125; /&gt;</div></pre></td></tr></table></figure>
<p>最后测量一下即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">UIManager.measure(findNodeHandle(<span class="keyword">this</span>.myComponent),(x,y,width,height,pageX,pageY)=&gt;&#123;</div><div class="line">    <span class="comment">//todo</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>同样的，这个也不能在 <code>componentDidMount</code> 后立即计算。</p>
<h2 id="Animated-动画"><a href="#Animated-动画" class="headerlink" title="Animated 动画"></a>Animated 动画</h2><p>在动画方面，ReactNative 使用 Animated 来做动画。Animated仅封装了四个可以动画化的组件：View、Text、Image和ScrollView。(Animated.createAnimatedComponent() 可以封装自定义组件)，举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;Animated&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(props) &#123;</div><div class="line">        <span class="keyword">super</span>(props);</div><div class="line">        <span class="comment">// 一个动画变量</span></div><div class="line">        <span class="keyword">this</span>.scaleValue = <span class="keyword">new</span> Animated.Value(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    fadeIn() &#123;</div><div class="line">        <span class="keyword">let</span> fade = Animated.timing(</div><div class="line">            <span class="keyword">this</span>.scaleValue,</div><div class="line">            &#123;</div><div class="line">                toValue: <span class="number">1</span>,</div><div class="line">                duration: <span class="number">2000</span></div><div class="line">            &#125;</div><div class="line">        );</div><div class="line">        <span class="comment">// 也可以 fade.stop</span></div><div class="line">        fade.start();</div><div class="line">    &#125;</div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;View&gt;</div><div class="line">                &lt;Animated.View</div><div class="line">                    style=&#123;&#123;</div><div class="line">                        width: <span class="number">50</span>,</div><div class="line">                        height: <span class="number">50</span>,</div><div class="line">                        transform: [&#123;<span class="attr">scale</span>: <span class="keyword">this</span>.scaleValue&#125;],</div><div class="line">                        backgroundColor: <span class="string">'#2ede2e'</span>,</div><div class="line">                    &#125;&#125;&gt;&lt;/Animated.View&gt;</div><div class="line">                &lt;Button </div><div class="line">                    title="改变样式" </div><div class="line">                    onPress=&#123;() =&gt; &#123;</div><div class="line">                        this.fadeIn();</div><div class="line">                    &#125;&#125;/&gt;</div><div class="line">            &lt;/View&gt;</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Animated 主要是以声明的形式来定义动画的输入与输出 （Animated.Value 变量），在其中建立一个可配置的变化函数，然后使用简单的 <code>start/stop</code> 方法来控制动画按顺序执行。</p>
<p>Animated 提供的动画类型：</p>
<ul>
<li>Animated.decay()以指定的初始速度开始变化，然后变化速度越来越慢直至停下。</li>
<li>Animated.spring()提供了一个简单的弹簧物理模型.</li>
<li>Animated.timing()使用easing 函数让数值随时间动起来。</li>
</ul>
<p>同时还提供了组合动画的方式：</p>
<ul>
<li>Animated.delay(time) 在给定延迟后开始动画。</li>
<li>Animated.parallel(animations, config?) 同时启动多个动画。</li>
<li>Animated.sequence(animations) 按顺序启动动画，等待每一个动画完成后再开始下一个动画。</li>
<li>Animated.stagger(time, animations) 按照给定的延时间隔，顺序并行的启动动画。</li>
<li>Animated.loop(animation, config?) 无限循环一个指定的动画</li>
</ul>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Animated.sequence([</div><div class="line">  <span class="comment">// decay, then spring to start and twirl</span></div><div class="line">  Animated.decay(position, &#123;</div><div class="line">    <span class="comment">// coast to a stop</span></div><div class="line">    velocity: &#123; <span class="attr">x</span>: gestureState.vx, <span class="attr">y</span>: gestureState.vy &#125;, <span class="comment">// velocity from gesture release</span></div><div class="line">    deceleration: <span class="number">0.997</span></div><div class="line">  &#125;),</div><div class="line">  Animated.parallel([</div><div class="line">    <span class="comment">// after decay, in parallel:</span></div><div class="line">    Animated.spring(position, &#123;</div><div class="line">      toValue: &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125; <span class="comment">// return to start</span></div><div class="line">    &#125;),</div><div class="line">    Animated.timing(twirl, &#123;</div><div class="line">      <span class="comment">// and twirl</span></div><div class="line">      toValue: <span class="number">360</span></div><div class="line">    &#125;)</div><div class="line">  ])</div><div class="line">]).start(); <span class="comment">// start the sequence group</span></div></pre></td></tr></table></figure>
<p>同事，对于 Aniamted.Value 还提供了加减乘除以及取余运算，插值器等，需要的自己看吧。</p>
<h3 id="动画有点卡，试试-useNativeDriver"><a href="#动画有点卡，试试-useNativeDriver" class="headerlink" title="动画有点卡，试试 useNativeDriver"></a>动画有点卡，试试 useNativeDriver</h3><p>我在模拟器上，改变动画确实卡的要命。这个 RN 同样提供了一个方案：启动原生动化。在动画中启用原生驱动非常简单。只需在开始动画之前，在动画配置中加入一行useNativeDriver: true，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Animated.timing(<span class="keyword">this</span>.state.animatedValue, &#123;</div><div class="line">    toValue: <span class="number">1</span>,</div><div class="line">    duration: <span class="number">500</span>,</div><div class="line">    useNativeDriver: <span class="literal">true</span> <span class="comment">// 加上这一行</span></div><div class="line">&#125;).start();</div></pre></td></tr></table></figure>
<blockquote>
<p>Animated的 API 是可序列化的（即可转化为字符串表达以便通信或存储）。通过启用原生驱动，我们在启动动画前就把其所有配置信息都发送到原生端，利用原生代码在 UI 线程执行动画，而不用每一帧都在两端间来回沟通。如此一来，动画一开始就完全脱离了 JS 线程，因此此时即便 JS 线程被卡住，也不会影响到动画了。</p>
</blockquote>
<p>然而，并不是所有的属性都可以启用原生动画，只有  <code>non-layout</code> 类型的属性才可以。那这就很尴尬了，我想要实现一个折叠面板，也卡的我难受。咋弄呢？</p>
<h3 id="LayoutAnimation"><a href="#LayoutAnimation" class="headerlink" title="LayoutAnimation"></a>LayoutAnimation</h3><p>它常用来更新 flexbox 布局，因为它可以无需测量或者计算特定属性就能直接产生动画。(感觉和 Android 的 <code>&lt;LayoutAnimation&gt;</code> 有关呢)。使用也十分的简单：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">_changeView() &#123;</div><div class="line">    LayoutAnimation.spring();</div><div class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">w</span>: <span class="keyword">this</span>.state.w + <span class="number">15</span>, <span class="attr">h</span>: <span class="keyword">this</span>.state.h + <span class="number">15</span>&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>只需要在改动之前，调用一下 LayoutAnimation 即可。同样，LayoutAnimation 也提供了其他动画方式(easeInEaseOut, linear, spring)，和动画的基础配置。<br>这里有一点要注意的是，如果在 Android 需要加入如下内容：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在执行任何动画代码之前，比如在入口文件App.js中执行</span></div><div class="line">UIManager.setLayoutAnimationEnabledExperimental &amp;&amp;</div><div class="line">  UIManager.setLayoutAnimationEnabledExperimental(<span class="literal">true</span>);</div></pre></td></tr></table></figure>
<p>除了这些，ReactNative 还提供了滚动，滑动等事件值映射到动画值上面。<code>Animated.Event</code> 这样就可以将动画和手势结合起来。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实 RN 的动画效果并不是很好，我们看见只有动画脱离了 JS (useNativeDriver) 才好点，这其中和 js 到 native 的频繁通信有很大的关系。脱离通信就好多了。<br>联系到，如果我们想做一些，复杂的交互动画效果，同样会产生问题。频繁的通信，序列化与反序列化。<br>这里推荐一篇文章，其解决思路可以参考：</p>
<ul>
<li><a href="http://taobaofed.org/blog/2018/05/31/a-rich-interaction-solution-based-on-bindingx/" target="_blank" rel="external">基于 BindingX 的富交互解决方案</a>  </li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要从前端的角度介绍 ReactNative 的用法，主要介绍 ReactNative 的基本用法(布局，样式，动画，手势，特殊API) 帮助大家快速掌握 ReactNaitve。而对于 ReactNative 封装的各种组件就不会过多深入了。（阅读建议：掌握 react 用法，熟悉前端）&lt;/p&gt;
    
    </summary>
    
      <category term="大前端(无线)" scheme="http://yoursite.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF-%E6%97%A0%E7%BA%BF/"/>
    
    
      <category term="ReactNative" scheme="http://yoursite.com/tags/ReactNative/"/>
    
  </entry>
  
  <entry>
    <title>从 javascript 角度看 Dart【三】</title>
    <link href="http://yoursite.com/2018/09/19/%E4%BB%8Ejs%E8%A7%92%E5%BA%A6%E7%9C%8Bdart3/"/>
    <id>http://yoursite.com/2018/09/19/从js角度看dart3/</id>
    <published>2018-09-19T06:06:54.000Z</published>
    <updated>2019-03-18T07:55:47.734Z</updated>
    
    <content type="html"><![CDATA[<p>前两篇文章，已经介绍了 Dart 的基础语法部分，并适当的结合 js 来进行对比。总的来看，Dart 设计的还是和 JS 很像的。本文，是最后一篇介绍 Dart 语言的。本文将着重介绍一下，Dart 的一些基础库。  </p>
<a id="more"></a>
<h2 id="库"><a href="#库" class="headerlink" title="库"></a>库</h2><p>使用import 和 library 机制可以方便的创建一个模块或分享代码。一个Dart 库不仅能够提供相应的API，还可以包含一些以_开头的变量用于在库内部使用。</p>
<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>用 <code>import</code> 来引入一个定义好的库。例如：  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">'dart:html'</span>;</div></pre></td></tr></table></figure>
<p>在import语句后面需要接上库文件的 URI。</p>
<ul>
<li>对Dart 语言提供的库文件以dart:xx 格式</li>
<li>其它第三方的库文件使用package:xx格式</li>
</ul>
<h4 id="设置库的前缀"><a href="#设置库的前缀" class="headerlink" title="设置库的前缀"></a>设置库的前缀</h4><p>如果两个库具有同样的标识符，则会出现命名冲突，可以用库前缀解决命名冲突。  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">'package:lib1/lib1.dart'</span>;</div><div class="line"><span class="keyword">import</span> <span class="string">'package:lib2/lib2.dart'</span> <span class="keyword">as</span> lib2;</div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">var</span> element1 = <span class="keyword">new</span> <span class="built_in">Element</span>();      <span class="comment">// 用 lib1 的 Element</span></div><div class="line"><span class="keyword">var</span> element2 = <span class="keyword">new</span> lib2.<span class="built_in">Element</span>(); <span class="comment">// 用 lib2 的 Element</span></div></pre></td></tr></table></figure>
<h4 id="只导入库的一部分"><a href="#只导入库的一部分" class="headerlink" title="只导入库的一部分"></a>只导入库的一部分</h4><p>如果你只使用库的一部分，可以导入只使用的功能 <code>show</code>, <code>hide</code>  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">'package:lib1/lib1.dart'</span> show foo; <span class="comment">// 仅导入 foo</span></div><div class="line"><span class="keyword">import</span> <span class="string">'package:lib2/lib2.dart'</span> hide foo; <span class="comment">// 除了 foo 外都导出</span></div></pre></td></tr></table></figure>
<h4 id="延迟加载库"><a href="#延迟加载库" class="headerlink" title="延迟加载库"></a>延迟加载库</h4><p>延迟加载机制，可以在需要使用的时候再加载库。关键字 <code>deferred as</code>  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">'package:deferred/hello.dart'</span> deferred <span class="keyword">as</span> hello;</div></pre></td></tr></table></figure>
<p>然后在需要使用的时候调用loadLibrary()方法。  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hello.loadLibrary();</div></pre></td></tr></table></figure>
<p>可以在代码中多次调用loadLibrary()方法。但是实际上它只会被执行一次。</p>
<h3 id="实现一个库"><a href="#实现一个库" class="headerlink" title="实现一个库"></a>实现一个库</h3><p>使用 <code>library</code> 加上一个标示符定义当前库的名字:  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span> point; <span class="comment">// 定义这个库的名字是 point</span></div></pre></td></tr></table></figure>
<h4 id="part-amp-part-of"><a href="#part-amp-part-of" class="headerlink" title="part &amp; part of"></a>part &amp; part of</h4><p>如果一个库的所有代码都写在一个文件中，会导致文件太大不好维护。Dart 允许你把代码写在多个文件中，并使用类似 include 的机制把多个文件包含到库的主文件中。库的主文件就是定义 library 语句所在的文件，在这个文件中可以使用 part 语句包含其它文件。part 语句的语法是 part 加上字符串形式的 fileUri 。与 part 语句相对应的是 part of 语句，需要在被包含的文件的顶部使用 part of 语句声明这个文件属于哪个库。  </p>
<p>library 语句所在的主文件中可以使用 import 和 part 语句，但 part of 所在的实现文件中不能使用任何 import、library 和 part 语句。库使用的所有 import 和 part 语句都必需放在主文件中声明。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 主文件 定义一个 math 库。它由 base，random 两部分组成</span></div><div class="line"><span class="keyword">library</span> math;</div><div class="line"><span class="keyword">part</span> <span class="string">'base.dart'</span>;</div><div class="line"><span class="keyword">part</span> <span class="string">'random.dart'</span>;</div></pre></td></tr></table></figure>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在 base.dart 文件的开头</span></div><div class="line"><span class="keyword">part</span> of math</div></pre></td></tr></table></figure>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在 random.dart 文件的开头</span></div><div class="line"><span class="keyword">part</span> of math;</div></pre></td></tr></table></figure>
<h4 id="export"><a href="#export" class="headerlink" title="export"></a>export</h4><p>你可以使用 export 语句重新导出库，比如：把多个较小的库组合为一个较大的库或者重新导出库的一部分作为一个新的库。既可以导出库的全部，也可以导出库的一部分（使用 show 和 hide）。</p>
<h2 id="dart-async-异步编程"><a href="#dart-async-异步编程" class="headerlink" title="dart:async - 异步编程"></a>dart:async - 异步编程</h2><h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>Future 通常座位异步函数得返回值出现，一个 Future 对象保证在未来的某个时间返回一个结果， 当一个 future 完成的时候，返回的值就可以使用了。这个东西，类似于 js 中的 Promise。利用 Dart 异步读取文件如下：  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">File f = <span class="keyword">new</span> File(<span class="string">"..."</span>);</div><div class="line">f.readAsString().then((<span class="built_in">String</span> str) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;).catchError((e) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>对比一下 js 的 Promise  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">path</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">        fs.readFile(path, (err, data) =&gt; &#123;</div><div class="line">            <span class="keyword">if</span>(err) &#123;</div><div class="line">                reject(err);</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                resolve(err);</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">readFile(<span class="string">'...'</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>可以看到，Future 和 Promise 本质是一个概念的。<br>使用 Future.wait() 静态函数来管理多个 Future 并等待所有 Future 一起完成。这一点类似 Promis.all。 </p>
<h3 id="async-amp-await"><a href="#async-amp-await" class="headerlink" title="async &amp; await"></a>async &amp; await</h3><p>和 js 一样， Dart 中 async 与 await 都是用来生命异步功能的，且 Dart 和 js 中关于这部分的用法几乎一样。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> readAllFile() <span class="keyword">async</span> &#123;</div><div class="line">    File f1 = <span class="keyword">new</span> File(<span class="string">"..."</span>);</div><div class="line">    File f2 = <span class="keyword">new</span> File(<span class="string">"..."</span>);</div><div class="line">    <span class="built_in">String</span> str1 = <span class="keyword">await</span> f1.readAsString();</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="built_in">String</span> str2 = <span class="keyword">await</span> f2.readAsString();</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line">readAllFile();</div></pre></td></tr></table></figure>
<h2 id="dart-convert-编解码"><a href="#dart-convert-编解码" class="headerlink" title="dart:convert 编解码"></a>dart:convert 编解码</h2><p>dart:convert 库 提供了 JSON 和 UTF-8 编码的转换器，还支持创建自定义转换器。 JSON 是一个用来表达结构化对象和集合的文本格式。 UTF-8 是一个常用的 Unicode 字符编码。<br>web 应用和命令行应用都可以使用 dart:convert 库。 import dart:convert 即可使用。</p>
<ul>
<li>编解码JSON：JSON.decode(), JSON.encode()</li>
<li>编解码UTF-8： UTF8.decode(),  UTF8.encode() </li>
</ul>
<p>其他的还有类似操作 dom 的 <code>dart:html</code> 库，命令行应用的 I/O 操作 <code>dart:io</code>，数学库 <code>dart:math</code> 等。就不多介绍了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两篇文章，已经介绍了 Dart 的基础语法部分，并适当的结合 js 来进行对比。总的来看，Dart 设计的还是和 JS 很像的。本文，是最后一篇介绍 Dart 语言的。本文将着重介绍一下，Dart 的一些基础库。  &lt;/p&gt;
    
    </summary>
    
      <category term="Flutter" scheme="http://yoursite.com/categories/Flutter/"/>
    
    
      <category term="Dart 语言" scheme="http://yoursite.com/tags/Dart-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="移动开发" scheme="http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>从 javascript 角度看 Dart【二】</title>
    <link href="http://yoursite.com/2018/09/13/%E4%BB%8Ejs%E8%A7%92%E5%BA%A6%E7%9C%8Bdart2/"/>
    <id>http://yoursite.com/2018/09/13/从js角度看dart2/</id>
    <published>2018-09-13T03:12:32.000Z</published>
    <updated>2018-09-17T11:19:04.349Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章，主要介绍了 Dart 的基本语法（数据类型，函数等），并与 js 进行了简单的对比，方便大家从 js 的角度来快速理解 Dart。本文主要介绍 Dart 中类的使用，总的来看差别不大，在构造函数上我们需要格外注意即可。还有几个 Dart 特有的内容也简单介绍下。    </p>
<a id="more"></a> 
<h2 id="新的运算符"><a href="#新的运算符" class="headerlink" title="新的运算符"></a>新的运算符</h2><p>在 Dart 中多出了一个类型测试操作符，具体如下：  </p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>类型转换</th>
</tr>
</thead>
<tbody>
<tr>
<td>as</td>
<td>类型转换</td>
</tr>
<tr>
<td>is</td>
<td>如果 对象是该类型 则返回 true</td>
</tr>
<tr>
<td>is!</td>
<td>如果 对象是该类型 则返回 false</td>
</tr>
</tbody>
</table>
<p>如果obj 实现了T 所定义的借口，那么obj is T 将返回 true。比如， obj is Object 必然返回 true。使用as 操作符可以把一个对象转换为特定类型。一般来说，如果在is 测试之后还有一些关于对象的表达式。 </p>
<h2 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h2><p>首先我们看下 js 简单声明一个类：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> id = <span class="string">"Point Map"</span>;</div><div class="line">	_prop = <span class="string">"prototype"</span>;</div><div class="line">	<span class="keyword">constructor</span>(x, y) &#123;</div><div class="line">    	<span class="keyword">this</span>.x = x;</div><div class="line">      	<span class="keyword">this</span>.y = y;</div><div class="line">    &#125;;</div><div class="line">	get prop() &#123;</div><div class="line">    	<span class="keyword">return</span> <span class="keyword">this</span>._prop;</div><div class="line">    &#125;</div><div class="line">    set prop(prop) &#123;</div><div class="line">    	<span class="keyword">this</span>._prop = prop + <span class="string">"test"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而用 Dart 翻译上面的 js 代码为：  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="built_in">double</span> y;</div><div class="line">    <span class="built_in">double</span> x;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">String</span> id = <span class="string">"Point Map"</span>;</div><div class="line">    <span class="built_in">String</span> _prop = <span class="string">"prototype"</span>;</div><div class="line">    Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</div><div class="line">    <span class="built_in">String</span> <span class="keyword">get</span> prop =&gt; <span class="keyword">this</span>._prop + <span class="string">"test"</span>;</div><div class="line">    <span class="keyword">void</span> <span class="keyword">set</span> prop(<span class="built_in">String</span> prop) =&gt; <span class="keyword">this</span>._prop = prop;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>Dart 的构造函数的名字和类名一样，其中 this 关键字引用当前实例。和 js 不同的是，Dart 提供了一个语法糖来方便我们赋值：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  num x;</div><div class="line">  num y;</div><div class="line">  <span class="comment">// 在构造函数体执行之前设置实例变量的语法糖</span></div><div class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="构造函数规则"><a href="#构造函数规则" class="headerlink" title="构造函数规则"></a>构造函数规则</h4><p>这一部分，完全和 js 的规则不一样， Dart 对构造函数有如下限制：</p>
<h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4><p>如果没有定义构造函数，则会生成一个默认构造函数。 默认构造函数没有参数，并调用没有参数的 superclass（父类） 构造函数。</p>
<h4 id="命名构造函数"><a href="#命名构造函数" class="headerlink" title="命名构造函数"></a>命名构造函数</h4><p>对于 Dart 语言，同样不支持函数重载。那么如果我想要我的类有多个构造方法该如何呢？Dart 使用命名构造来提供多个构造函数：  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="built_in">num</span> x;</div><div class="line">    <span class="built_in">num</span> y;</div><div class="line">    Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</div><div class="line">    <span class="comment">// 命名构造函数</span></div><div class="line">    Point.fromJson(<span class="built_in">Map</span> json) &#123;</div><div class="line">        x = json[<span class="string">'x'</span>];</div><div class="line">        y = json[<span class="string">'y'</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Point p = <span class="keyword">new</span> Point.fromJson(&#123;&#125;);</div></pre></td></tr></table></figure>
<h4 id="构造函数不支持继承"><a href="#构造函数不支持继承" class="headerlink" title="构造函数不支持继承"></a>构造函数不支持继承</h4><p>任何类型的构造函数都不支持继承。 如果你想让子类也能用父类的构造函数，则你必需在子类中定义并实现该构造函数。默认情况下，子类的构造函数，会调用父类无名无参数的默认构造函数。但是大多数情况下，我们的父类肯定有自己实现的构造函数。这样父类就不会有默认构造函数了，因此我们必须为子类的构造函数手工调用一个父类的构造函数。在冒号 (:) 后面和构造函数体之前指定要调用的父类构造函数。  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="built_in">double</span> x;</div><div class="line">    <span class="built_in">double</span> y;</div><div class="line">    Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</div><div class="line">    Point.fromJson(<span class="built_in">Map</span> data) &#123;</div><div class="line">        <span class="keyword">this</span>.x = data[<span class="string">'x'</span>];</div><div class="line">        <span class="keyword">this</span>.y = data[<span class="string">'y'</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3D</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="built_in">double</span> z;</div><div class="line">    Point3D(x, y, <span class="keyword">this</span>.z): <span class="keyword">super</span>(x, y);</div><div class="line">    Point3D.fromJson(<span class="built_in">Map</span> data): <span class="keyword">super</span>.fromJson(data) &#123;</div><div class="line">        <span class="comment">// 这里如果 this.z = data.z 就会报错</span></div><div class="line">        <span class="keyword">this</span>.z = data[<span class="string">"z"</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="常量构造函数"><a href="#常量构造函数" class="headerlink" title="常量构造函数"></a>常量构造函数</h4><p>如果你的类生成从来不改变的对象，则可以把这些对象定义为编译期常量。 用一个 const 构造函数并把实例变量设置为 final 来实现该功能。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImmutablePoint</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="built_in">num</span> x;</div><div class="line">    <span class="keyword">final</span> <span class="built_in">num</span> y;</div><div class="line">    <span class="keyword">const</span> ImmutablePoint(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ImmutablePoint origin = <span class="keyword">const</span> ImmutablePoint(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="工厂构造函数"><a href="#工厂构造函数" class="headerlink" title="工厂构造函数"></a>工厂构造函数</h4><p>如果一个构造函数并不总是创建一个新的对象，则可以用 factory 关键字来实现构造函数。 例如，一个工厂构造函数可以从缓存中返回一个实例，也可以返回一个子类型的实例。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="built_in">String</span> name;</div><div class="line">    <span class="built_in">bool</span> mute = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">// _cache is library-private, thanks to the _ in front of its name.</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Logger&gt; _cache = &lt;<span class="built_in">String</span>, Logger&gt;&#123;&#125;;</div><div class="line">  </div><div class="line">    <span class="keyword">factory</span> Logger(<span class="built_in">String</span> name) &#123;</div><div class="line">        <span class="keyword">if</span> (_cache.containsKey(name)) &#123;</div><div class="line">            <span class="keyword">return</span> _cache[name];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">final</span> logger = <span class="keyword">new</span> Logger._internal(name);</div><div class="line">            _cache[name] = logger;</div><div class="line">            <span class="keyword">return</span> logger;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    Logger._internal(<span class="keyword">this</span>.name);</div><div class="line">  </div><div class="line">    <span class="keyword">void</span> log(<span class="built_in">String</span> msg) &#123;</div><div class="line">        <span class="keyword">if</span> (!mute) &#123;</div><div class="line">            <span class="built_in">print</span>(msg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>工厂构造函数无法访问 this</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>Dart 为我们提供了 abstract 抽象类  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 该类为 abstract 的，所以无法实例化</span></div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractContainer</span> </span>&#123;</div><div class="line">    <span class="comment">// ...Define constructors, fields, methods...</span></div><div class="line">    <span class="keyword">void</span> updateChildren(); <span class="comment">// 抽象函数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="隐式接口"><a href="#隐式接口" class="headerlink" title="隐式接口"></a>隐式接口</h3><p>每个类都隐式的定义了一个包含所有实例变量和所实现所有接口的接口。 如果你想创建一个类 A 支持 类 B 的 API，但是又不想继承类 B 的实现，则类 A 可以实现 类 B 的隐式接口。<br>类通过 implements 语句来定义其实现的其他类的接口， 并实现需要的 API。 例如：  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 一个  person 类， 隐式接口包含  greet().</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> _name;          <span class="comment">// 该变量在隐式接口中，但是是库返回可见的</span></div><div class="line">    Person(<span class="keyword">this</span>._name);   <span class="comment">// 这是个构造函数，不在隐式接口中</span></div><div class="line">    <span class="built_in">String</span> greet(who) =&gt; <span class="string">'Hello, $who. I am $_name.'</span>; <span class="comment">// 在隐式接口中</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 实现 Person 的隐式接口。</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Imposter</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> _name = <span class="string">""</span>;      <span class="comment">// We have to define this, but we don't use it.</span></div><div class="line">    <span class="built_in">String</span> greet(who) =&gt; <span class="string">'Hi $who. Do you know who I am?'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>关键字 <code>extends</code> 和 js 继承没有太大区别，唯一需要注意的就是构造函数，之前已经说过了。另外在 Dart 中提供了注解功能。我们可以用 @override 来表明正在重写的函数或者变量。这一点有点类似 java。  </p>
<h3 id="类（静态）变量和函数"><a href="#类（静态）变量和函数" class="headerlink" title="类（静态）变量和函数"></a>类（静态）变量和函数</h3><p>关键字 <code>static</code> 和 js 没有太大区别。</p>
<h3 id="Typedefs"><a href="#Typedefs" class="headerlink" title="Typedefs"></a>Typedefs</h3><p>在 js 里面，我们很容易的就可以将函数作为参数进行传递。在 Dart 中我们也可以像 js 一样方便的传递函数。但是这样，有时候我们需要指明函数的类型，比如有多少个参数啊，返回值之类的，从而方便类型检查。<br>在 Dart 中函数也是对象。我们可以用 <code>typedef</code> 来定义一个名称来指明函数名字, 并且定义参数和返回值。  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">int</span> CalFunc(<span class="built_in">int</span> num1, <span class="built_in">int</span> num2);</div><div class="line">main() &#123;</div><div class="line">    <span class="built_in">int</span> num1 = <span class="number">1</span>;</div><div class="line">    <span class="built_in">int</span> num2 = <span class="number">2</span>;</div><div class="line">    <span class="built_in">int</span> calculate(CalFunc func) &#123;</div><div class="line">        <span class="keyword">return</span> func(num1, num2);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="built_in">int</span> result = calculate((<span class="built_in">int</span> num1, <span class="built_in">int</span> num2) &#123;</div><div class="line">        <span class="keyword">return</span> num1 - num2;</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">print</span>(result);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>（思考了下，java 能不能将函数作为参数直接传递？不能直接简单的传递，我们可以利用 interface 继承的方式；在 java8 中我们还可以用 lambada 表达式。）   </p>
<h3 id="Metadata（元数据）"><a href="#Metadata（元数据）" class="headerlink" title="Metadata（元数据）"></a>Metadata（元数据）</h3><p>用元数据给你的代码提供额外的信息。元数据注解 使用 @ 字符开头，后面跟着一个引用合作 编译期常量（例如 deprecated）或者调用一个 常量构造函数。<br>下面三个注解，所有的 Dart 代码都可以使用： @deprecated、 @override、 和 @proxy。<br>Metadata 可以出现在 library、 class、 typedef、 type parameter、 constructor、factory、 function、 field、 parameter、或者 variable declaration 、import 或者 export 之前。 以后，可以通过反射来获取元数据信息。 </p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型，由于 js 是动态类型的语言，因此没有泛型的概念。Dart 中我们可以使用泛型，也可以不适用。个人倾向于应该主动使用泛型，来帮助我们更好的表达意图。也方便 IDE 对代码的错误的检查，提高效率。具体内容比较杂，就不对比了。  </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Dart 语言的基础到这里就介绍的差不多了，总的来看还算简单。我觉得从 js 的角度 和 java 的角度综合分析下，还是蛮好玩的。下篇文章主要介绍下 Dart 常用库。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文章，主要介绍了 Dart 的基本语法（数据类型，函数等），并与 js 进行了简单的对比，方便大家从 js 的角度来快速理解 Dart。本文主要介绍 Dart 中类的使用，总的来看差别不大，在构造函数上我们需要格外注意即可。还有几个 Dart 特有的内容也简单介绍下。    &lt;/p&gt;
    
    </summary>
    
      <category term="Flutter" scheme="http://yoursite.com/categories/Flutter/"/>
    
    
      <category term="Dart 语言" scheme="http://yoursite.com/tags/Dart-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="移动开发" scheme="http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>从 javascript 角度看 Dart【一】</title>
    <link href="http://yoursite.com/2018/09/10/%E4%BB%8Ejs%E8%A7%92%E5%BA%A6%E7%9C%8Bdart/"/>
    <id>http://yoursite.com/2018/09/10/从js角度看dart/</id>
    <published>2018-09-10T04:09:50.000Z</published>
    <updated>2018-09-17T07:34:36.805Z</updated>
    
    <content type="html"><![CDATA[<p>最近准备尝试下谷歌的 Flutter 开发，因此需要学习一下 dart 语言。本文主要将 javascript 和 dart 进行对比，从而帮助我们快速入门 dart 语言。  </p>
<h2 id="Dart-简介"><a href="#Dart-简介" class="headerlink" title="Dart 简介"></a>Dart 简介</h2><blockquote>
<p>Dart是谷歌开发的计算机编程语言，后来被Ecma (ECMA-408)认定为标准。它被用于web、服务器、移动应用和物联网等领域的开发。它是宽松开源许可证（修改的BSD证书）下的开源软件。Dart是面向对象的、类定义的、单继承的语言。它的语法类似C语言，可以转译为JavaScript，支持接口(interfaces)、混入(mixins)、抽象类(abstract classes)、具体化泛型(reified generics)、可选类型(optional typing)和 sound type system。     </p>
</blockquote>
<a id="more"></a> 
<h3 id="Dart-应用"><a href="#Dart-应用" class="headerlink" title="Dart 应用"></a>Dart 应用</h3><p>Dart 语言最早提出的目的就是来做为浏览器开发语言， Google 本来打算将 Dart 的虚拟机放入浏览器中。后来没有实现，目前 Dart 可以被看做类似 typescript 一样。<br>在移动开发中，Google 开发的移动端 UI 框架 Flutter 采用的就是 Dart 语言。  </p>
<h2 id="Dart-语法"><a href="#Dart-语法" class="headerlink" title="Dart 语法"></a>Dart 语法</h2><h3 id="Dart-的几个基本概念"><a href="#Dart-的几个基本概念" class="headerlink" title="Dart 的几个基本概念"></a>Dart 的几个基本概念</h3><p>关于 Dart 语法有下面几个概念需要注意：  </p>
<ul>
<li>每个变量都是一个对象，。甚至数字，函数，和null都是对象。所有对象都继承自Object 类。这一点和 js 保持一致。  </li>
<li>Dart 的变量可以指定静态类型，也可以不指定，这里建议所有变量都要指明其类型。  </li>
<li>Dart 支持顶级方法（例如 main()），也支持实例函数和类函数（静态函数）。 你还可以在一个方法内创建另外一个方法（nested（嵌入方法） 或者 local functions（本地方法））。</li>
<li>同样，Dart 也支持顶级 变量，也支持实例变量和类变量（静态变量）。 实例变量有时候被称之为 值域或者属性（fields 或者 properties）。 </li>
<li>Dart 有两种 运行模式： 生产模式和检测模式（ production and checked）。生产模式效率高，但是测试模式可以在开发的时候帮助调试代码。</li>
</ul>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>对比如下：  </p>
<img src="/2018/09/10/从js角度看dart/a.png" alt="a.png" title="">     
<p>总的来说 Numbers, String 差异不多，这里仅仅列出一些不同点。  </p>
<p>在 dart 定义常量用关键字: <code>final</code>, <code>const</code> 两个，区别在于：  </p>
<ol>
<li>final 要求变量只能初始化一次，并不要求赋的值一定是编译时常量，可以是常量也可以不是。而 const 要求在声明时初始化，并且赋值必需为编译时常量。</li>
<li>final 是惰性初始化，即在运行时第一次使用前才初始化。而 const 是在编译时就确定值了。<br>(<code>编译时常量</code>指的是：字面量（如数字、bool、字符串、List的字面量形式）、其它常量 或者 常量的算术运算，也可以是这些的组合形式（递归要求），简单地说常量就是可以在编译时确定的值)</li>
</ol>
<p>注意： </p>
<ul>
<li>字符串的其他操作也和 js 一致(dart 中字符串没有 slice 方法)。 </li>
<li>在 dart 中字符串模板使用的是 单引号 ‘ ，而不是反引号 ` </li>
<li>我们可以用（’’’）来包含换行文本内容   </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String str = &apos;&apos;&apos;</div><div class="line">换行文本内容&apos;&apos;&apos;;</div></pre></td></tr></table></figure>
<p>对于 List 和 Maps 上的操作，不同的地方如下。  </p>
<h4 id="List-的差别"><a href="#List-的差别" class="headerlink" title="List 的差别"></a>List 的差别</h4><h5 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h5><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="comment">// 添加一个元素，类似 arr.push(5)</span></div><div class="line">arr.add(<span class="number">5</span>);  </div><div class="line"><span class="comment">// 一次添加多项, 类似 arr.concat(5, 6, 7, 8)</span></div><div class="line">arr.addAll([<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]);</div><div class="line"><span class="comment">// 指定位置添加元素, 类似 arr.splice(0, 0, 0);</span></div><div class="line">arr.insert(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line"><span class="comment">// 指定位置添加多个元素，类似 arr.splice(0, 0, -1, -2);</span></div><div class="line">arr.insertAll(<span class="number">0</span>, [<span class="number">-1</span>, <span class="number">-2</span>])</div></pre></td></tr></table></figure>
<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 删除第一个匹配到的元素  </span></div><div class="line">arr.remove(<span class="number">3</span>);</div><div class="line"><span class="comment">// 删除第几个元素，类似 arr.splice(1, 1);</span></div><div class="line">arr.removeAt(<span class="number">1</span>);</div><div class="line"><span class="comment">// 删除所有元素  </span></div><div class="line">arr.clear(); </div><div class="line"><span class="comment">// 移除开始下标（包括）至结束下标（不包括）内的元素  </span></div><div class="line">arr.removeRange(<span class="number">1</span>, <span class="number">4</span>);</div><div class="line"><span class="comment">// 移除并替换开始下标（包括）至结束下标（不包括）内的元素  </span></div><div class="line">arr.replaceRange(<span class="number">1</span>, <span class="number">4</span>, [<span class="number">6</span>, <span class="number">7</span>]);</div></pre></td></tr></table></figure>
<h5 id="查询-amp-排序"><a href="#查询-amp-排序" class="headerlink" title="查询 &amp; 排序"></a>查询 &amp; 排序</h5><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回从开始下标（包括）到结束下标（不包括）元素的列表; 类似： arr.slice(1, 3)  </span></div><div class="line">arr.sublist(<span class="number">1</span>, <span class="number">2</span>);  </div><div class="line"><span class="comment">// 数组随机排序  </span></div><div class="line">arr.shuffle();</div></pre></td></tr></table></figure>
<p>List 的操作 和 Set 操作几乎一致，这里就不在列出 Set 了。 </p>
<h4 id="Maps-的差别"><a href="#Maps-的差别" class="headerlink" title="Maps 的差别"></a>Maps 的差别</h4><p>map 通常被称之为 dictionary 或者 hash， map 是一个无序的 key-value（键-值） 对。 map 中每个值都有一个对应的键便于访问。和 JavaScript 不同， Dart 对象不是 map。    </p>
<h5 id="所有属性"><a href="#所有属性" class="headerlink" title="所有属性"></a>所有属性</h5><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">int</span>&gt; map = &#123;<span class="string">"a"</span>:<span class="number">1</span>, <span class="string">"b"</span>:<span class="number">2</span>, <span class="string">"c"</span>:<span class="number">3</span>&#125;;</div><div class="line"><span class="comment">// 返回映射的哈希码</span></div><div class="line">map.hashCode  </div><div class="line"><span class="comment">// 映射上是否没有键值对  </span></div><div class="line">map.isEmpty</div><div class="line"><span class="comment">// 映射上是否有键值对  </span></div><div class="line">map.isNotEmpty  </div><div class="line"><span class="comment">// 返回映射的所有键, 类似 Object.keys(map)</span></div><div class="line">map.keys    </div><div class="line"><span class="comment">// 返回对象运行时的类型  </span></div><div class="line">map.runtimeType</div></pre></td></tr></table></figure>
<p>注意：这里的 Map 并不像是简单的 js 的对象。如果你想访问属性建议使用 <code>[]</code> 的方式，例如：<code>map[&quot;a&quot;]</code>。不要使用 <code>.</code> 的方式 (在 Map 作为参数的时候会报错);</p>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 按顺序迭代映射    </span></div><div class="line">map.forEach((key, value)&#123;</div><div class="line">    <span class="built_in">print</span>(key + <span class="string">" : "</span> + value.toString());</div><div class="line">&#125;);  </div><div class="line"><span class="comment">// 添加其他键值对到映射中  </span></div><div class="line">map.addAll(&#123;<span class="string">"d"</span>:<span class="number">4</span>, <span class="string">"e"</span>:<span class="number">5</span>&#125;);  </div><div class="line"><span class="comment">// 映射是否包含指定键  </span></div><div class="line">map.containsKey(<span class="string">"d"</span>);  </div><div class="line"><span class="comment">// 映射是否包含指定值  </span></div><div class="line">map.containsValue(<span class="number">5</span>);  </div><div class="line"><span class="comment">// 删除指定键值对  </span></div><div class="line">map.remove(<span class="string">"a"</span>);</div><div class="line"><span class="comment">// 删除所有键值对</span></div><div class="line">map.clear();  </div><div class="line"><span class="comment">// 如果想在 key 不存在的时候 才设置该值，则可以用 putIfAbsent() 函数。该函数 的参数为返回设置的值的方法  </span></div><div class="line">m.putIfAbsent(<span class="string">"d"</span>, () =&gt; <span class="number">4</span>);</div></pre></td></tr></table></figure>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>在 Dart 中函数的基本语法和 JavaScript 类似，但是不需要输入 function 关键字，定义一个函数：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> printNumber(<span class="built_in">int</span> <span class="built_in">num</span>) &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="built_in">num</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><p>在 dart 中，比 js 多一个 可选参数的概念；可选参数可以是 <code>命名参数</code> 或者 <code>位置参数</code>，但是不能同时使用两种类型。</p>
<h5 id="可选-命名参数"><a href="#可选-命名参数" class="headerlink" title="可选 - 命名参数"></a>可选 - 命名参数</h5><p>用 {param1, param2, …} 来定义方法的 命名参数：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> text(&#123;<span class="built_in">int</span> a, <span class="built_in">int</span> b&#125;) &#123;</div><div class="line">    <span class="built_in">print</span>(a);</div><div class="line">    <span class="built_in">print</span>(b);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>注意</code>：对于这种方式如果想要设置参数默认值，需要用 <code>:</code> ; 其他的情况，我们可以采用 <code>=</code> 来设置默认值。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> text(&#123;<span class="built_in">int</span> a: <span class="number">1</span>, <span class="built_in">int</span> b&#125;) &#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当我们想给参数 b 设置内容的时候，调用如下： </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">text(b: <span class="number">5</span>);    <span class="comment">// 输出 null, 5</span></div></pre></td></tr></table></figure>
<h5 id="可选-位置参数"><a href="#可选-位置参数" class="headerlink" title="可选 - 位置参数"></a>可选 - 位置参数</h5><p>位于 [] 中间的参数为可选位置 参数：  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> setPersonInfo(<span class="built_in">String</span> name, <span class="built_in">int</span> age, [<span class="built_in">String</span> addr]) &#123;</div><div class="line">    <span class="comment">//....</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="main-函数"><a href="#main-函数" class="headerlink" title="main 函数"></a>main 函数</h4><p>每一个应用都必须有一个顶级函数main() ，这个函数就是整个应用的入口函数。main() 函数返回值类型为 void 并且有一个可选参数List<string> ，这点也是和 js 完全不同的。  </string></p>
<h4 id="语法作用域"><a href="#语法作用域" class="headerlink" title="语法作用域"></a>语法作用域</h4><p>Dart 是一种语法作用域语言，也就是说 变量的作用域 是根据代码布局静态判断的。 可以根据“变量位于花括号内外”来判断一个变量是否在作用域中。  </p>
<h4 id="语法闭包"><a href="#语法闭包" class="headerlink" title="语法闭包"></a>语法闭包</h4><p>一个 closure（闭包） 是一个可以 访问位于其语法作用域内变量的方法对象，即时该方法用在其定义的作用域之外，也可以访问这些变量。方法可以覆盖定义在附近作用域的变量。</p>
<h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><p>对于只有一个表达式的方法，你可以用缩写形式：<br>printNumber(number) =&gt; print(‘The number is $number.’);  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">printNumber(<span class="built_in">num</span> number) =&gt; <span class="built_in">print</span>(<span class="string">'The number is $number.'</span>);</div></pre></td></tr></table></figure>
<p>但是请注意，和 js 不同，dart 只有简写的时候 <code>=&gt;</code> 才是函数，如果不是简写，不能用这个 <code>=&gt;</code> 来表示一个函数。在 Dart 中，匿名函数是没有 <code>=&gt;</code> 的形式。 例如，匿名函数:  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// IIFE </span></div><div class="line"><span class="comment">// 在 javascript 这是正确的  </span></div><div class="line">(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</div><div class="line">&#125;)()  </div><div class="line"></div><div class="line"><span class="comment">// 在 Dart 中  </span></div><div class="line"></div><div class="line">() &#123;</div><div class="line">    print(<span class="number">1</span>);</div><div class="line">&#125;();</div><div class="line"></div><div class="line">lists.forEach((item) &#123;</div><div class="line">    <span class="comment">//....</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了，Dart 的基础语法部分。对于运算符，循环，判断等就不介绍了，因为和 js 一样。总的来看，Dart 和 js 语法相似度还是很高的。下篇，讲介绍 类与泛型。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近准备尝试下谷歌的 Flutter 开发，因此需要学习一下 dart 语言。本文主要将 javascript 和 dart 进行对比，从而帮助我们快速入门 dart 语言。  &lt;/p&gt;
&lt;h2 id=&quot;Dart-简介&quot;&gt;&lt;a href=&quot;#Dart-简介&quot; class=&quot;headerlink&quot; title=&quot;Dart 简介&quot;&gt;&lt;/a&gt;Dart 简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Dart是谷歌开发的计算机编程语言，后来被Ecma (ECMA-408)认定为标准。它被用于web、服务器、移动应用和物联网等领域的开发。它是宽松开源许可证（修改的BSD证书）下的开源软件。Dart是面向对象的、类定义的、单继承的语言。它的语法类似C语言，可以转译为JavaScript，支持接口(interfaces)、混入(mixins)、抽象类(abstract classes)、具体化泛型(reified generics)、可选类型(optional typing)和 sound type system。     &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Flutter" scheme="http://yoursite.com/categories/Flutter/"/>
    
    
      <category term="Dart 语言" scheme="http://yoursite.com/tags/Dart-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="移动开发" scheme="http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序架构原理</title>
    <link href="http://yoursite.com/2018/09/03/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/09/03/微信小程序架构原理/</id>
    <published>2018-09-03T07:09:20.000Z</published>
    <updated>2019-04-09T05:19:17.772Z</updated>
    
    <content type="html"><![CDATA[<p>好久没有整理文章了，懒了啊，补一个最近工作中调研的内容吧。本文主要从源码方面介绍微信小程序的架构原理，并简单总结下这么做的好处。</p>
<h2 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h2><p>微信小程序包含下面四种文件：  </p>
<ul>
<li>js </li>
<li>json    配置文件</li>
<li>wxml  小程序专用 xml 文件</li>
<li>wxss   小程序专用 css 文件     </li>
</ul>
<a id="more"></a>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">"window"</span>&gt;</span>&#123;&#123; text &#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Page(&#123;</div><div class="line">  data:&#123;</div><div class="line">    text:<span class="string">"这是一个页面"</span></div><div class="line">  &#125;,</div><div class="line">  onLoad:<span class="function"><span class="keyword">function</span>(<span class="params">options</span>)</span>&#123;</div><div class="line">    <span class="comment">// 页面初始化 options为页面跳转所带来的参数</span></div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// ........</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>微信小程序只能通过其 mvvm 的模板语法来动态改变页面，本身 js 并不支持 BOM 和 DOM 操作。  </p>
<h2 id="从开发工具看微信小程序架构"><a href="#从开发工具看微信小程序架构" class="headerlink" title="从开发工具看微信小程序架构"></a>从开发工具看微信小程序架构</h2><p> 在 mac 端直接解压应用 发现 app.nw 文件夹，即开发工具源码。可以知道该项目由 nw.js 编写；<br> 在 package.json 文件下找到应用入口：<code>app/html/index.html</code>。入口 js 为 <code>dist/app.js</code> 我们可以看到整个编辑器的大致逻辑。<br> 但我们关心的是构建过程，在 weapp 文件夹下存在 build.js 文件。没有找到有用的信息，只看到了 <code>upload</code> 模块，包括对大小限制，上传包命名。<br>为此怀疑，微信小程序本身和 RN 类似。是在服务端打包成 native 语言的。但是通过 android 边框测试发现，微信小程序根本不是 native 原生内容。<br>原生界面效果<br><img src="/2018/09/03/微信小程序架构原理/tgy-wx-a.jpg" alt="tgy-wx-a.jpg" title=""> </p>
<h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p>继续在 trans 文件夹下发现了编译模板。  </p>
<ul>
<li>transWxmlToJs     wxml 转 js</li>
<li>transWxssToCss    wxss 转 css</li>
<li>transConfigToPf   模板页配置</li>
<li>transWxmlToHtml   wxml 转 html</li>
<li>transManager      管理器  </li>
</ul>
<p>用到的内容：  </p>
<ul>
<li>发现用到了一个模板：<code>app.nw/app/dist/weapp/tpl/pageFrameTpl.js</code>, <code>app.mw/app.dist.weapp/tpl/appserviceTpl.js</code>  </li>
<li>wcc 可执行程序，wcc 用于转换 wxml 中的自定义 tag 为 virtual_dom</li>
<li>wcsc 可执行程序，用于将 wxss 转为 view 模块使用的 css 代码，使用方式为 wcsc xxx.wxss</li>
</ul>
<p>在模板中，我们发现使用了 <code>WAWebview.js</code> 文件，<code>WAService.js</code>文件。<br>在 transWxmlToJs 中我们发现一段 generateFuncReady 事件的函数。对比注册该事件的函数在 <code>WAWebview.js</code> 中。<br>我们尝试使用 wcc 对input.xml 文件进行编译。</p>
<blockquote>
<p>wcc -d input.xml  </p>
</blockquote>
<p>生成了一段脚本：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.__wcc_version__ = <span class="string">'v0.6vv_20161230_fbi'</span></div><div class="line"><span class="keyword">var</span> $gwxc</div><div class="line"><span class="keyword">var</span> $gaic = &#123;&#125;</div><div class="line">$gwx = <span class="function"><span class="keyword">function</span> (<span class="params">path, global</span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">        b &amp;&amp; a.children.push(b);</div><div class="line">    &#125;</div><div class="line">    ....</div></pre></td></tr></table></figure>
<p>通过代码我们发现，调用 $gwx 函数会再生成一个有返回值的函数(前提是 path 填写正确)；于是我们执行如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$gwx(<span class="string">"input.xml"</span>)(<span class="string">"test"</span>)</div></pre></td></tr></table></figure>
<p>得出如下内容：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"tag"</span>: <span class="string">"wx-page"</span>,</div><div class="line">    <span class="string">"children"</span>: [</div><div class="line">        &#123;</div><div class="line">            <span class="string">"tag"</span>: <span class="string">"wx-view"</span>,</div><div class="line">            <span class="string">"attr"</span>: &#123;</div><div class="line">                <span class="string">"class"</span>: <span class="string">"section"</span></div><div class="line">            &#125;,</div><div class="line">            <span class="string">"children"</span>: [</div><div class="line">                &#123;</div><div class="line">                    <span class="string">"tag"</span>: <span class="string">"wx-input"</span>,</div><div class="line">                    <span class="string">"attr"</span>: &#123;</div><div class="line">                        <span class="string">"autoFocus"</span>: <span class="literal">true</span>,</div><div class="line">                        <span class="string">"placeholder"</span>: <span class="string">"这是一个可以自动聚焦的input"</span></div><div class="line">                    &#125;,</div><div class="line">                    <span class="string">"children"</span>: []</div><div class="line">                &#125;</div><div class="line">            ]</div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这应该是一个类似 Virtual dom 的对象，交给了 WAWebivew.js 来渲染，标签名为 <code>wx-view</code>, <code>wx-input</code>。  </p>
<h4 id="WAWebview-js"><a href="#WAWebview-js" class="headerlink" title="WAWebview.js"></a>WAWebview.js</h4><ol>
<li><p>代码在最一开始提供的是兼容性工具，还有一个 WeixinJSBridge 引入。</p>
</li>
<li><p>接下来是一个 Reporter 对象，它的作用就是发送错误和性能统计数据给后台。</p>
<img src="/2018/09/03/微信小程序架构原理/tgy-wx-b.jpg" alt="tgy-wx-b.jpg" title="">  
</li>
<li><p>wx 核心对象，包含了 wx 对象下的 api。但是这里的 api 数量远远少于官方的 api 文档数量。</p>
  
<p>我们可以在代码里面发现，wx 下注册的 api 最终都会调用 WeixinJSBridge 方法，这个方法。应该是在打包的时候端上注入的。然而，我们也可以在 WAServeice.js 中找到该方法的定义。  </p>
<img src="/2018/09/03/微信小程序架构原理/tgy-wx-d.jpg" alt="tgy-wx-d.jpg" title="">    
<p>所以我们得到了一个结论，WAService.js 是编辑器用来接受 wx 方法回调的代码。</p>
</li>
<li>wxparser 对象，提供 dom 到 wx element 对象之间的映射操作，提供元素操作管理和事件管理功能。</li>
<li><p>之后代码是对 exparser 对象的处理，包括注册 WeixinJSBridge 全局事件，Virtual dom 算法实现，样式注入等。介绍几个组件重要的内容  </p>
<ul>
<li><p>exparser.registerBehavior 注册组件基础行为，供组件继承。</p>
<img src="/2018/09/03/微信小程序架构原理/tgy-wx-e.jpg" alt="tgy-wx-e.jpg" title="">      
</li>
<li><p>exparser.registerElement 为各种内置组件，注册模板，行为，属性，监听器等内容</p>
</li>
</ul>
</li>
</ol>
 
<p>这里我们观察到，组件：<code>wx-video</code>, <code>wx-canvas</code>, <code>wx-contact-button</code>, <code>wx-map</code>, <code>wx-textarea</code> 等 behaviors 都含有 “wx-native” 属性。这是不是意味着，这类组件都是 native 原生实现的呢。我们打开边框检查，发现这类组件确实都是原生的组件。<br><img src="/2018/09/03/微信小程序架构原理/tgy-wx-g.jpg" alt="tgy-wx-g.jpg" title="">   </p>
<img src="/2018/09/03/微信小程序架构原理/tgy-wx-h.jpg" alt="tgy-wx-h.jpg" title="">   
<p>综上，微信小程序的界面有部分组件使用原生方式实现的，native 组件层在 WebView 层之上。大部分还是用前端实现的，这样解释了微信小程序的一个bug。</p>
<blockquote>
<p>微信官方文档：<br><img src="/2018/09/03/微信小程序架构原理/tgy-wx-i.jpg" alt="tgy-wx-i.jpg" title="">  </p>
</blockquote>
<p>因为 scroll-view 是前端实现，在里面使用 native 组件，这样就无法监听滚动了。  </p>
<h4 id="WeixinJSBridge"><a href="#WeixinJSBridge" class="headerlink" title="WeixinJSBridge"></a>WeixinJSBridge</h4><p>组件是需要数据来渲染的，查看文档我们知道发送请求的 api 为 <code>wx.request</code>;通过上面分析，我么你知道 wx.request 实际调用的是 <code>WeixinJSBridge</code>。现在我们看看 <code>WeixinJSBridge</code><br><img src="/2018/09/03/微信小程序架构原理/tgy-wx-j.jpg" alt="tgy-wx-j.jpg" title=""><br>WeixinJSBridge 真正发送处理数据请求的是这端代码；如果当前环境是 ios, 那么调用 WKWebview的 window.webkit.messageHandlers.invokeHandler.postMessage。如果所处环境是 android 则调用 WeixinJSCore.invokeHandler(调用的时候，默认会带上当前webviewID)。  </p>
<h4 id="WAService-js"><a href="#WAService-js" class="headerlink" title="WAService.js"></a>WAService.js</h4><p>在对 WeixinJSBridge.js 分析中，我们并没有发现前端的通讯功能，路由能力，数据绑定等内容。进一步查看找到了一个 <code>WAService.js</code> 文件。<br>查看 <code>WAService.js</code> 文件源码：  </p>
<ol>
<li>在代码最开始，跟 WAWebview.js 一样的 WeixinJSBridge 兼容模块</li>
<li>然后是跟 WAWebview.js 一样的 Reporter 模块。</li>
<li>比 WAWebview.js 中 wx 功能更为丰富 wx 接口模块。(剩余的那部分 wx api 都在这里)</li>
<li>appServiceEngine 模块，提供 Page，App，GetApp 接口</li>
<li>为 window 对象添加 AMD 接口 require define  </li>
</ol>
<p>综上，WAService.js 主要实现的功能：  </p>
<ul>
<li>App() 小程序的入口；Page( ) 页面的入口</li>
<li>wx API;</li>
<li>页面有的作用域，提供模块化能力</li>
<li>数据绑定、事件分发、生命周期管理、路由管理</li>
</ul>
<p>到这里我们得出结论，小程序的架构方案：<br>   </p>
<p>整个小程序由两个 webview 组成，代码分为 UI 层和逻辑层。UI 层运行在第一个 WebView 当中，执行 DOM 操作和交互事件的响应，里面是 WAWebview.js 代码及编译后的内容。逻辑层执行在（第二个webview 中）独立的 JS 引擎中（iOS：JavaScriptCore, android：X5 JS解析器；统称 JSCore；开发工具中，nwjs Chrome 内核），WAService.js 代码和业务逻辑。</p>
<p>当我们对 view 层进行事件操作后，会通过 WeixinJSBridge 将数据传递到 Native 系统层。Native 系统层决定是否要用 native 处理，然后丢给 逻辑层进行用户的逻辑代码处理。逻辑层处理完毕后会将数据通过 WeixinJSBridge 返给 View 层。View 渲染更新视图。</p>
<h2 id="架构的讨论"><a href="#架构的讨论" class="headerlink" title="架构的讨论"></a>架构的讨论</h2><p>微信的这种架构，对逻辑和UI进行了完全隔离，小程序逻辑和UI完全运行在2个独立的Webview里面来处理。那么这么做的好处是啥？总感觉更加麻烦了。除了小程序外，还有人采用这种架构设计么？<br>在网上搜索了一下，目前使用这种架构的项目还真有一个：<a href="http://ued.qunar.com/yis/index.html" target="_blank" rel="external">去哪儿最新的 YIS 框架</a>   </p>
<blockquote>
<p>YIS 采取了类似小程序的架构，分为逻辑层和UI层。UI 层运行在 WebView 中，而逻辑层运行在独立的 JS 引擎中。相应地，整个应用的代码，也分为两个大的部分，一部分运行在 WebView 中，一部分运行在JS引擎中。JS引擎计算DOM结构输出给WebView，WebView转发用户的点击事件给JS引擎。</p>
</blockquote>
<p>该项目做法和小程序十分类似，唯一缺少的就是没有 native 的组件吧。然而官方文档上也没有任何介绍，为什么要这么做，只是说更流畅了。  </p>
<h3 id="一些看法"><a href="#一些看法" class="headerlink" title="一些看法"></a>一些看法</h3><p>传统 web 页面显示需要经历一下几个步骤:  </p>
<ol>
<li>webview 初始化</li>
<li>加载 HTML, CSS, JS</li>
<li>编译 JS</li>
<li>Render 计算</li>
<li>DOM Path</li>
</ol>
<p>而利用小程序架构后，我们就可以将上述过程拆解成两部分并行执行：<br>webview 部分：</p>
<ol>
<li>webview 初始化</li>
<li>加载HTML，CSS, JS (经过拆分后，体积大幅度减小)</li>
<li>编译JS</li>
<li>等待页面需要的数据</li>
<li>反序列化数据</li>
<li>执行Patch</li>
<li>渲染页面</li>
<li>等待更多消息</li>
</ol>
<p>jscore 部分：</p>
<ol>
<li>初始化</li>
<li>加载框架 js 代码</li>
<li>编译 js</li>
<li>加载业务逻辑 js 代码</li>
<li>编译 js</li>
<li>计算首屏虚拟 DOM 结构</li>
<li>序列化数据，传输</li>
<li>等待 webview 消息，或者 Native 消息  </li>
</ol>
<p>这样渲染进程和逻辑进程分离，并行处理：加速首屏渲染速度；避免单线程模型下，js 运算时间过长，UI 出现卡顿。<br>完全采用数据驱动的方式，不能直接操作 DOM，避免低质量的代码。</p>
<p>当然这种架构方案也有这一定的缺点：  </p>
<ol>
<li>不能灵活操作 DOM，无法实现较为复杂的效果。</li>
<li>部分和NA相关的视图有使用限制，如微信的 scrollView 内不能有 textarea。</li>
<li>页面大小、打开页面数量都受到限制。</li>
<li>需要单独开发适配，不能复用现有代码资源。</li>
<li>在 jscore 中JS 体积比较大的情况下，其初始化时间会产生影响。</li>
<li>传输数据中，序列化和反序列化耗时需要考虑</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.zhihu.com/question/50920642" target="_blank" rel="external">微信小程序底层的实现原理是怎样的</a></li>
<li><a href="http://www.bbs0101.com/archives/1495.html" target="_blank" rel="external">微信小程序架构解析，工作原理解析</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/22754296" target="_blank" rel="external">微信小程序架构分析</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久没有整理文章了，懒了啊，补一个最近工作中调研的内容吧。本文主要从源码方面介绍微信小程序的架构原理，并简单总结下这么做的好处。&lt;/p&gt;
&lt;h2 id=&quot;微信小程序&quot;&gt;&lt;a href=&quot;#微信小程序&quot; class=&quot;headerlink&quot; title=&quot;微信小程序&quot;&gt;&lt;/a&gt;微信小程序&lt;/h2&gt;&lt;p&gt;微信小程序包含下面四种文件：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;js &lt;/li&gt;
&lt;li&gt;json    配置文件&lt;/li&gt;
&lt;li&gt;wxml  小程序专用 xml 文件&lt;/li&gt;
&lt;li&gt;wxss   小程序专用 css 文件     &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="大前端(无线)" scheme="http://yoursite.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF-%E6%97%A0%E7%BA%BF/"/>
    
    
      <category term="架构设计" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Hybird 开发" scheme="http://yoursite.com/tags/Hybird-%E5%BC%80%E5%8F%91/"/>
    
      <category term="微信小程序" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>immer.js 源码分析</title>
    <link href="http://yoursite.com/2018/08/16/immer-js%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/08/16/immer-js源码分析/</id>
    <published>2018-08-16T09:28:12.000Z</published>
    <updated>2018-08-16T09:28:20.674Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Riot.js 源码解析 【二】 组件详解</title>
    <link href="http://yoursite.com/2017/10/18/riot-js%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%902/"/>
    <id>http://yoursite.com/2017/10/18/riot-js源码解析2/</id>
    <published>2017-10-18T06:24:12.000Z</published>
    <updated>2017-11-22T02:54:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="riot-组件"><a href="#riot-组件" class="headerlink" title="riot 组件"></a>riot 组件</h1><p>使用 riot 编写组件是以 .tag 后缀结尾的文件，我们的 html, css, js 都可以放在里面。这些文件在编译阶段会被编译成对应的js代码(见<a href="">Riot.js 源码解析 【一】 基础内容</a>)。每个组件都是一个 Tag 对象(代码在 /tag/tag.js 里面)，里面包含了对象的各种属性和方法。本文主要介绍，riot 组件的生命周期，更新原理(一个粗粒度的 virtual dom)以及简单更新优化手段。<br><a id="more"></a>     </p>
<h1 id="Tag-对象"><a href="#Tag-对象" class="headerlink" title="Tag 对象"></a>Tag 对象</h1><p>每一个 riot.js 组件其实就是一个 Tag 对象。Tag 类被定义在 /tag/tag.js 文件下面。Tag 类基本内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// impl 包含组件的模板，逻辑等属性  </span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Tag</span>(<span class="params">impl = &#123;&#125;, conf = &#123;&#125;, innerHTML</span>) </span>&#123;</div><div class="line">    ...各种属性初始化</div><div class="line">    defineProperty(<span class="keyword">this</span>, <span class="string">'__'</span>, &#123;...&#125;)</div><div class="line">    defineProperty(<span class="keyword">this</span>, <span class="string">'_riot_id'</span>, ++__uid)</div><div class="line">    defineProperty(<span class="keyword">this</span>, <span class="string">'refs'</span>, &#123;&#125;)</div><div class="line">    ...</div><div class="line">    <span class="comment">// 定义组件更新方法</span></div><div class="line">    defineProperty(<span class="keyword">this</span>, <span class="string">'update'</span>, <span class="function"><span class="keyword">function</span> <span class="title">tagUpdate</span>(<span class="params">data</span>)</span>&#123;...&#125;.bind(<span class="keyword">this</span>))</div><div class="line">    <span class="comment">// 定义组件 mixin 方法</span></div><div class="line">    defineProperty(<span class="keyword">this</span>, <span class="string">'update'</span>, <span class="function"><span class="keyword">function</span> <span class="title">tagMixin</span>(<span class="params">data</span>)</span>&#123;...&#125;.bind(<span class="keyword">this</span>))</div><div class="line">    <span class="comment">// 定义组件加载方法</span></div><div class="line">    defineProperty(<span class="keyword">this</span>, <span class="string">'mount'</span>, <span class="function"><span class="keyword">function</span> <span class="title">tagMount</span>(<span class="params">data</span>)</span>&#123;...&#125;.bind(<span class="keyword">this</span>))</div><div class="line">    <span class="comment">// 定义组件卸载方法</span></div><div class="line">    defineProperty(<span class="keyword">this</span>, <span class="string">'mount'</span>, <span class="function"><span class="keyword">function</span> <span class="title">tagUnmount</span>(<span class="params">data</span>)</span>&#123;...&#125;.bind(<span class="keyword">this</span>))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="riot-生命周期"><a href="#riot-生命周期" class="headerlink" title="riot 生命周期"></a>riot 生命周期</h1><p>riot 组件状态分为以下几个部分：  </p>
<ul>
<li>before-mount：标签被加载之前</li>
<li>mount：标签实例被加载到页面上以后</li>
<li>update：允许在更新之前重新计算上下文数据</li>
<li>updated：标签模板更新后</li>
<li>before-unmount：标签实例被卸载之前</li>
<li>unmount：标签实例被从页面上卸载后    </li>
</ul>
<p>riot.js 采用事件驱动的方式来进行通讯，我们可以采用如下函数来监听上面的事件，例如处理 update 事件：  </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">riot-demo</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript">        <span class="keyword">this</span>.on(<span class="string">'update'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></div><div class="line"><span class="javascript">            <span class="comment">// 标签更新后的处理</span></span></div><div class="line"><span class="undefined">        &#125;)</span></div><div class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">riot-demo</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="组件状态触发时机"><a href="#组件状态触发时机" class="headerlink" title="组件状态触发时机"></a>组件状态触发时机</h2><p>当我们调用 <code>riot.mount()</code> 渲染指定组件的时候，riot 会从 <code>__TAG_IMPL</code> 中获取相对应的已经注册好的模板内容，并生成相应的 <code>Tag</code> 实例对象。并且触发其上的 <code>Tag.mount()</code> 函数，最后将 <code>Tag</code> 对象缓存到 <code>__TAGS_CACHE</code> 中。代码如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountTo</span>(<span class="params">root, tagName, opts, ctx</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> impl = __TAG_IMPL[tagName],   <span class="comment">// 获取 html 模板</span></div><div class="line">        implClass = __TAG_IMPL[tagName].class, <span class="comment">// ?</span></div><div class="line">        tag = ctx || (implClass ? <span class="built_in">Object</span>.create(implClass.prototype) : &#123;&#125;),</div><div class="line">        innerHTML = root._innerHTML = root._innerHTML || root.innerHTML</div><div class="line">    <span class="keyword">var</span> conf = extend(&#123;</div><div class="line">        root: root,</div><div class="line">        opts: opts</div><div class="line">    &#125;, &#123;</div><div class="line">        parent: opts ? opts.parent : <span class="literal">null</span></div><div class="line">    &#125;)</div><div class="line">    <span class="keyword">if</span> (impl &amp;&amp; root) Tag.apply(tag, [impl, conf, innerHTML]);</div><div class="line">    <span class="keyword">if</span> (tag &amp;&amp; tag.mount) &#123;</div><div class="line">        tag.mount(<span class="literal">true</span>)</div><div class="line">        <span class="comment">// add this tag to the virtualDom variable</span></div><div class="line">        <span class="keyword">if</span> (!contains(__TAGS_CACHE, tag)) __TAGS_CACHE.push(tag)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> tag</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Tag.mount()</code> 函数流程如下：      </p>
<img src="/2017/10/18/riot-js源码解析2/a.png" alt="a.png" title="">  
<p>组件加载阶段，首先会整理标签上所有的 attribute 的内容，区分普通属性，和带有表达式 expr 的属性。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">defineProperty(<span class="keyword">this</span>, <span class="string">'mount'</span>, <span class="function"><span class="keyword">function</span> <span class="title">tagMount</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    ...</div><div class="line"></div><div class="line">    parseAttributes.apply(parent, [root, root.attributes, (attr, expr) =&gt; &#123;</div><div class="line">        <span class="comment">// 检测 expr 是否在 RefExpr 的原型链中</span></div><div class="line">        <span class="keyword">if</span> (!isAnonymous &amp;&amp; RefExpr.isPrototypeOf(expr)) expr.tag = <span class="keyword">this</span>;</div><div class="line">        <span class="comment">// 挂载在 root.attributs 上面 root 为组件所在的 dom 对象</span></div><div class="line">        attr.expr = expr</div><div class="line">        instAttrs.push(attr)</div><div class="line">    &#125;])   </div><div class="line"></div><div class="line">    <span class="comment">// impl 对象包含组件上的各种属性，包括模板，逻辑等内容</span></div><div class="line">    implAttrs = []</div><div class="line">    walkAttrs(impl.attrs, (k, v) =&gt; &#123;</div><div class="line">        implAttrs.push(&#123;</div><div class="line">            name: k,</div><div class="line">            value: v</div><div class="line">        &#125;)</div><div class="line">    &#125;)</div><div class="line">    <span class="comment">// 检查的是 implAttrs</span></div><div class="line">    parseAttributes.apply(<span class="keyword">this</span>, [root, implAttrs, (attr, expr) =&gt; &#123;</div><div class="line">        <span class="keyword">if</span> (expr) expressions.push(expr)   <span class="comment">//插入表达式</span></div><div class="line">        <span class="keyword">else</span> setAttr(root, attr.name, attr.value)</div><div class="line">    &#125;])</div><div class="line"></div><div class="line">    ... </div><div class="line">&#125;).bind(<span class="keyword">this</span>)</div></pre></td></tr></table></figure>
<p>初始化这些表达式内容，然后为组件添加全局注册的mixin 内容。接下来，会执行我们为组件添加的函数内容，此时触发 <code>before-mount</code> 事件。触发完毕后，解析标签上的表达式，比如 if each 等内容，然后执行组件的 <code>update()</code> 函数。    </p>
<p>在 <code>update()</code> 函数中，首先会检查用户是否定义了组件的 <code>shouldUpdate()</code> 函数，如果有定义则传入两个参数，第一个是想要更新的内容(即调用this.update() 时传入的参数)。第二个为接收的父组件更新的 opts 内容。若该函数返回值为 true 则更新渲染，否则放弃。  (这里需要注意，<code>Tag.mount()</code> 阶段由于组件尚未处于记载完毕状态，因此不会触发 shouldUpdate() 函数)。    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">defineProperty(<span class="keyword">this</span>, <span class="string">'update'</span>, <span class="function"><span class="keyword">function</span> <span class="title">tagUpdate</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">// shouldUpdate 返回值检测</span></div><div class="line">    <span class="keyword">if</span> (canTrigger &amp;&amp; <span class="keyword">this</span>.isMounted &amp;&amp; isFunction(<span class="keyword">this</span>.shouldUpdate) &amp;&amp; !<span class="keyword">this</span>.shouldUpdate(data, nextOpts)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span></div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">    <span class="comment">// 扩展opts</span></div><div class="line">    extend(opts, nextOpts)</div><div class="line">    <span class="keyword">if</span> (canTrigger) <span class="keyword">this</span>.trigger(<span class="string">'update'</span>, data)</div><div class="line">    update.call(<span class="keyword">this</span>, expressions)</div><div class="line">    <span class="keyword">if</span> (canTrigger) <span class="keyword">this</span>.trigger(<span class="string">'updated'</span>)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span></div><div class="line">&#125;).bind(<span class="keyword">this</span>);</div></pre></td></tr></table></figure>
<p>之后会触发 <code>update</code> 事件，开始渲染新的组件。渲染完毕后触发 <code>updated</code> 事件。   </p>
<p>加载完毕后，修改组件状态 <code>defineProperty(this, &#39;isMounted&#39;, true)</code>。如果渲染的组件不是作为子组件的话，我们就触发自身的 <code>mount</code> 事件。否则的话，需要等到父组件加载完毕后，或者更新完毕后(已经加载过了)，再触发。    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">defineProperty(<span class="keyword">this</span>, <span class="string">'mount'</span>, <span class="function"><span class="keyword">function</span> <span class="title">tagMount</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    ...</div><div class="line">    defineProperty(<span class="keyword">this</span>, <span class="string">'root'</span>, root)</div><div class="line">    defineProperty(<span class="keyword">this</span>, <span class="string">'isMounted'</span>, <span class="literal">true</span>)</div><div class="line">    <span class="keyword">if</span> (skipAnonymous) <span class="keyword">return</span></div><div class="line">    <span class="comment">// 如果不是子组件则触发</span></div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.parent) &#123;</div><div class="line">        <span class="keyword">this</span>.trigger(<span class="string">'mount'</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 否则需要等待父组件的状态渲染状态</span></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">const</span> p = getImmediateCustomParentTag(<span class="keyword">this</span>.parent)</div><div class="line">        p.one(!p.isMounted ? <span class="string">'mount'</span> : <span class="string">'updated'</span>, () =&gt; &#123;</div><div class="line">            <span class="keyword">this</span>.trigger(<span class="string">'mount'</span>)</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span></div><div class="line">&#125;).bind(<span class="keyword">this</span>)</div></pre></td></tr></table></figure>
<p>当我们调用 <code>tag.unmount</code> 卸载组件的时候，首先会触发 <code>before-unmount</code> 事件。再接下来清除所有的属性和事件监听等内容后，触发 ‘unmount’ 事件。  </p>
<h2 id="update-问题"><a href="#update-问题" class="headerlink" title="update 问题"></a>update 问题</h2><p>我们知道除了手动调用 <code>tag.update</code>的方式更新组件，我们通过绑定 dom 事件也能自动触发。这主要是因为在 riot 组件中绑定事件，默认会追加调用 update 的方法。相关代码如下：   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleEvent</span>(<span class="params">dom, handler, e</span>) </span>&#123;</div><div class="line">    <span class="comment">// 执行事件回调</span></div><div class="line">    handle.call(<span class="keyword">this</span>, e);</div><div class="line">    ...</div><div class="line">    <span class="comment">// 阻止 自动 update</span></div><div class="line">    <span class="keyword">if</span> (!settings.autoUpdate) <span class="keyword">return</span>  </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样的话，任何事件操作即使没有引起UI重新渲染，也会触发 update, updated 阶段。我们可以通过设置 <code>riot.settings.autoUpdate (default true)</code> 来更改这种行为。  </p>
<h1 id="更新原理"><a href="#更新原理" class="headerlink" title="更新原理"></a>更新原理</h1><p>在 riot.js 中，想要更新组件我们必须手动调用 <code>tag.update()</code> 方法才可以或者通过绑定 dom 事件触发(通过模板绑定的事件，会在回调执行完毕后自动触发 tag.update )，并不能做到实时的更新处理。例如：    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;riot-demo&gt;</div><div class="line">    &lt;h1&gt;&#123; title &#125;&lt;<span class="regexp">/h1&gt;</span></div><div class="line"><span class="regexp">    &lt;button click=&#123; handleClick &#125;&gt;修改内容&lt;/</span>button&gt;</div><div class="line">    &lt;script&gt;</div><div class="line">        <span class="keyword">this</span>.title = <span class="string">"标题"</span></div><div class="line">        handleClick() &#123;</div><div class="line">            <span class="keyword">this</span>.title = <span class="string">"新标题"</span>;</div><div class="line">            <span class="keyword">this</span>.update();   <span class="comment">// 调用 update 方法才能重新渲染组件</span></div><div class="line">        &#125;</div><div class="line">    &lt;<span class="regexp">/script&gt;</span></div><div class="line"><span class="regexp">&lt;/</span>riot-demo&gt;</div></pre></td></tr></table></figure>
<p>riot.js 并没有提供 virtual dom 的功能，而是实现了一个粗粒度的 virtual dom。riot.js 为每个组件创建的 tag 对象中都保存一个 expressions 数组，更新的时候遍历 expressions 数组，对比旧值，如果有变化就更新DOM。这种更新机制类似angular的脏检查，但是仅有一轮检查（单项数据流）。更新处理依照模板类型来处理：  </p>
<ul>
<li>文本内容的，直接： dom.nodeValue = value</li>
<li>值为空，而且关联的 DOM 属性是 checked/selected 等这种没有属性值的，移除对应的属性</li>
<li>值为函数的，则进行事件绑定</li>
<li>属性名为 if，则做条件判断处理</li>
<li>做了 show/hide 的语法糖处理：   </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">toggleVisibility</span>(<span class="params">dom, show</span>) </span>&#123;</div><div class="line">    dom.style.display = show ? <span class="string">''</span> : <span class="string">'none'</span></div><div class="line">    dom[<span class="string">'hidden'</span>] = show ? <span class="literal">false</span> : <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>普通属性的，直接设置其值</li>
</ul>
<p>riot.js 和 react 一样也有 props(静态，riot 中为 opts) 和本身数据(动态)，具有和 react 一样的输入。但是输出的时候，由于没有 virtual dom UI的更新并没有集中处理，是分散的。<br>riot.js 采用的这种方式，代码量上大大的减少，但是也带来了比较严重的性能问题。  </p>
<h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><p>首先我们来看一段 vue 代码：    </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span>&gt;</span></div><div class="line">            &#123;&#123; item.name &#125;&#125; --- &#123;&#123; item.age &#125;&#125;</div><div class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"handleClick"</span>&gt;</span>更新列表项<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> demo = <span class="keyword">new</span> Vue(&#123;</div><div class="line">    el: <span class="string">'#demo'</span>,</div><div class="line">    data: &#123;</div><div class="line">        items: [</div><div class="line">          &#123; <span class="attr">name</span>: <span class="string">'tgy'</span>, <span class="attr">age</span>: <span class="number">23</span>&#125;,</div><div class="line">        ]</div><div class="line">    &#125;,</div><div class="line">    methods: &#123;</div><div class="line">        handleClick: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.items = [</div><div class="line">                &#123; <span class="attr">name</span>: <span class="string">'tgy'</span>, <span class="attr">age</span>: <span class="number">23</span>&#125;,</div><div class="line">                &#123; <span class="attr">name</span>: <span class="string">'hy'</span>, <span class="attr">age</span>: <span class="number">22</span>&#125;,</div><div class="line">            ]</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    mounted: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">         <span class="built_in">console</span>.log(<span class="string">"组件挂载完毕"</span>);</div><div class="line">         <span class="built_in">document</span>.querySelector(<span class="string">"li"</span>).extraType = <span class="string">"origin"</span>;</div><div class="line">    &#125;,</div><div class="line">    updated: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">         <span class="built_in">console</span>.log(<span class="string">"组件更新完毕"</span>);</div><div class="line">         <span class="built_in">console</span>.log(<span class="built_in">document</span>.querySelector(<span class="string">"li"</span>).extraType);</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>代码很简单，单击按钮，为列表添加一条新数据。在组件挂载完毕后，为第一个 li 的 property 上面添加了 extraType 属性。列表更新后，再去访问这个 li 的 extraType 属性。运行结果如下：  </p>
<img src="/2017/10/18/riot-js源码解析2/b.png" alt="b.png" title="">  
<p>不出意料，可以正常访问到 li 的type属性。这说明了，在更新过程中，第一个 li 节点仅仅是 textContent 发生了改变而不是重新创建的。这样的结果得益于 virtual dom 算法，保证更新最小变动。同样的我们用 riot 来重写上面的代码。      </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">content-demo</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">each</span>=<span class="string">&#123;</span> <span class="attr">items</span> &#125;&gt;</span>&#123; name &#125; -- &#123; age &#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn"</span> <span class="attr">click</span>=<span class="string">&#123;</span> <span class="attr">handleClick</span> &#125;&gt;</span>订阅内容<span class="tag">&lt;/<span class="name">button</span>&gt;</span>  </div><div class="line">   <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript">        <span class="keyword">let</span> self = <span class="keyword">this</span>;</span></div><div class="line"><span class="javascript">        <span class="keyword">this</span>.items = [</span></div><div class="line"><span class="javascript">            &#123;<span class="string">"name"</span>: <span class="string">"tgy"</span>, <span class="attr">age</span>: <span class="number">23</span>&#125;</span></div><div class="line"><span class="undefined">        ];</span></div><div class="line"><span class="undefined">        handleClick() &#123;</span></div><div class="line"><span class="javascript">            <span class="keyword">this</span>.items = [</span></div><div class="line"><span class="javascript">                &#123;<span class="string">"name"</span>: <span class="string">"tgy"</span>, <span class="attr">age</span>: <span class="number">23</span>&#125;,</span></div><div class="line"><span class="javascript">                &#123;<span class="string">"name"</span>: <span class="string">"hy"</span>, <span class="attr">age</span>: <span class="number">22</span>&#125;</span></div><div class="line"><span class="undefined">            ]</span></div><div class="line"><span class="undefined">        &#125;</span></div><div class="line"><span class="javascript">        <span class="keyword">this</span>.on(<span class="string">'mount'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></div><div class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"组件加载完毕"</span>);</span></div><div class="line"><span class="javascript">            <span class="built_in">document</span>.querySelector(<span class="string">"li"</span>).extraType = <span class="string">"origin"</span>;</span></div><div class="line"><span class="undefined">        &#125;)</span></div><div class="line"><span class="javascript">        <span class="keyword">this</span>.on(<span class="string">'updated'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></div><div class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"组件更新完毕"</span>);</span></div><div class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="built_in">document</span>.querySelector(<span class="string">"li"</span>).extraType);</span></div><div class="line"><span class="undefined">        &#125;)</span></div><div class="line"><span class="undefined">   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">content-demo</span>&gt;</span></div></pre></td></tr></table></figure>
<p>查看运行结果：  </p>
<img src="/2017/10/18/riot-js源码解析2/c.png" alt="c.png" title="">
<p>extraType 找不到了，所有的 li 节点都被重新构建了。这里面发生了什么，查看源码 /tag/each.js。渲染逻辑代码如下：     </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">_each</span>(<span class="params">dom, parent, expr</span>) </span>&#123;</div><div class="line">    ...</div><div class="line">    expr.update = <span class="function"><span class="keyword">function</span> <span class="title">updateEach</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        ...</div><div class="line">        each(items, <span class="function"><span class="keyword">function</span> (<span class="params">item, i</span>) </span>&#123;</div><div class="line">            <span class="comment">// 仅仅记录 items 是对象的</span></div><div class="line">            <span class="keyword">var</span></div><div class="line">                doReorder = mustReorder &amp;&amp; <span class="keyword">typeof</span> item === T_OBJECT &amp;&amp; !hasKeys,</div><div class="line">                <span class="comment">// 旧数据</span></div><div class="line">                oldPos = oldItems.indexOf(item),</div><div class="line">                <span class="comment">// 是新的</span></div><div class="line">                isNew = oldPos === <span class="number">-1</span>,</div><div class="line">                pos = !isNew &amp;&amp; doReorder ? oldPos : i,</div><div class="line">                tag = tags[pos],</div><div class="line">                <span class="comment">// 必须追加</span></div><div class="line">                mustAppend = i &gt;= oldItems.length,</div><div class="line">                <span class="comment">// 必须创建 isNew</span></div><div class="line">                mustCreate = doReorder &amp;&amp; isNew || !doReorder &amp;&amp; !tag</div><div class="line">                <span class="comment">// 有key值得时候需要 mkitem</span></div><div class="line">            item = !hasKeys &amp;&amp; expr.key ? mkitem(expr, item, i) : item</div><div class="line">            <span class="comment">// 必须创建一个新 tag </span></div><div class="line">            <span class="keyword">if</span> (mustCreate) &#123;</div><div class="line">                tag = <span class="keyword">new</span> Tag(impl, &#123;</div><div class="line">                    parent,</div><div class="line">                    isLoop,</div><div class="line">                    isAnonymous,</div><div class="line">                    tagName,</div><div class="line">                    root: dom.cloneNode(isAnonymous),</div><div class="line">                    item,</div><div class="line">                    index: i,</div><div class="line">                &#125;, dom.innerHTML)</div><div class="line"></div><div class="line">                <span class="comment">// mount the tag</span></div><div class="line">                tag.mount()</div><div class="line">                <span class="keyword">if</span> (mustAppend)</div><div class="line">                    append.apply(tag, [frag || root, isVirtual])</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    insert.apply(tag, [root, tags[i], isVirtual])</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (!mustAppend) oldItems.splice(i, <span class="number">0</span>, item)</div><div class="line">                tags.splice(i, <span class="number">0</span>, tag)</div><div class="line">                <span class="keyword">if</span> (child) arrayishAdd(parent.tags, tagName, tag, <span class="literal">true</span>)</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pos !== i &amp;&amp; doReorder) &#123;</div><div class="line">                <span class="comment">// move</span></div><div class="line">                <span class="comment">// 移动</span></div><div class="line">                <span class="keyword">if</span> (contains(items, oldItems[pos])) &#123;</div><div class="line">                    move.apply(tag, [root, tags[i], isVirtual])</div><div class="line">                    <span class="comment">// move the old tag instance</span></div><div class="line">                    tags.splice(i, <span class="number">0</span>, tags.splice(pos, <span class="number">1</span>)[<span class="number">0</span>])</div><div class="line">                    <span class="comment">// move the old item</span></div><div class="line">                    oldItems.splice(i, <span class="number">0</span>, oldItems.splice(pos, <span class="number">1</span>)[<span class="number">0</span>])</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (expr.pos) tag[expr.pos] = i</div><div class="line">                <span class="keyword">if</span> (!child &amp;&amp; tag.tags) moveNestedTags.call(tag, i)</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 缓存原始数据到节点上</span></div><div class="line">            tag.__.item = item</div><div class="line">            tag.__.index = i</div><div class="line">            tag.__.parent = parent;</div><div class="line">            <span class="comment">// 如果不是创建的，我们需要更新节点内容。</span></div><div class="line">            <span class="keyword">if</span> (!mustCreate) tag.update(item)</div><div class="line">        &#125;)</div><div class="line">        <span class="comment">// remove the redundant tags</span></div><div class="line">        <span class="comment">// 删除多余的标签</span></div><div class="line">        unmountRedundant(items, tags)</div><div class="line">        <span class="comment">// 记录旧的数据</span></div><div class="line">        <span class="comment">// clone the items array</span></div><div class="line">        oldItems = items.slice()</div><div class="line">        <span class="comment">// dom 插入节点</span></div><div class="line">        root.insertBefore(frag, placeholder)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段为列表渲染逻辑，遍历新的数据items中的每一下 item。在原始数据 oldItems 中去查找(oldItems.indexOf(itemId))，是否存在 item 项。如果不存在，则标记 isNews 为 true。之后走到 if 的 mustCreaete 为 true 的分支，去创建一个新的 tag(将 li 节点看成是一个tag)。以此类推，当全部创建完毕后，删除旧的节点(unmountRedundant(items, tags))。在断点下，可以清楚看到节点的变化情况：   </p>
<img src="/2017/10/18/riot-js源码解析2/d.gif" alt="d.gif" title="">    
<h2 id="优化手段"><a href="#优化手段" class="headerlink" title="优化手段"></a>优化手段</h2><p>综上所述，riot.js 的更新逻辑仅仅是判断新旧数据项是否为同一对象。为此，为了减少 DOM 的变动，降低渲染逻辑。我们修改<code>handleClick</code>函数：   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">handleClick() &#123;</div><div class="line">    <span class="keyword">this</span>.items.push(&#123;<span class="string">"name"</span>: <span class="string">"hy"</span>, <span class="attr">age</span>: <span class="number">22</span>&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样输出结果就会和 vue 的保持一致，并没有创建新的 tag，而是利用了已经存在的内容。源码中，这种情况下 isNews 为 false，从而避开了 创建标签。而仅仅是通过 <code>tags.splice(i, 0, tags.splice(pos, 1)[0]);</code> 来移动位置，<code>if (!mustCreate) { tag.update(item); }</code> 更新节点内容。<br>保证数据项对象地址不变，仅仅是修改上面的不可变对象的值，将大大的提高 riot.js 的渲染效率。     </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 更新第一个li内容  </span></div><div class="line"></div><div class="line"><span class="comment">// 不推荐写法，对象发生变化；</span></div><div class="line"><span class="keyword">this</span>.items[<span class="number">0</span>] = &#123;<span class="string">"name"</span>: <span class="string">"hy"</span>, <span class="attr">age</span>: <span class="number">23</span>&#125;;   </div><div class="line"></div><div class="line"><span class="comment">// 推荐写法，仅仅是修改对象中的值</span></div><div class="line"><span class="keyword">this</span>.items[<span class="number">0</span>].name = <span class="string">"hy"</span>;</div><div class="line"><span class="keyword">this</span>.items[<span class="number">0</span>].age = <span class="number">22</span>;</div></pre></td></tr></table></figure>
<h2 id="数据处理插件"><a href="#数据处理插件" class="headerlink" title="数据处理插件"></a>数据处理插件</h2><p>实际阶段，我们就需要有一个插件，能够帮我们在处理数据项变动的时候，尽量保证大部分数据项地址不发生变化，从而提高 riot 的渲染性能。曾经考虑过使用 Immutable.js 来处理，但是需要修改 riot.js 代码才能实现。所以觉得自己弄个，开发中….  </p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://techblog.toutiao.com/2016/12/13/riotjs/" target="_blank" rel="external">头条PC站基于RIOT的组件化开发实践</a>  </li>
<li><a href="http://imweb.io/topic/573e766f1156025b1dce9404" target="_blank" rel="external">深入探讨前端UI框架</a>  </li>
<li><a href="https://gist.github.com/teabyii/7f6bddf5934915081c5d" target="_blank" rel="external">Riot 源码阅读笔记</a>  </li>
<li><a href="https://github.com/riot/riot/blob/7fe907d161731568c4d7755ab05493ddec12c6fd/lib/browser/tag" target="_blank" rel="external">Riot.js 源代码</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" target="_blank" rel="external">MVC，MVP 和 MVVM 的图示</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;riot-组件&quot;&gt;&lt;a href=&quot;#riot-组件&quot; class=&quot;headerlink&quot; title=&quot;riot 组件&quot;&gt;&lt;/a&gt;riot 组件&lt;/h1&gt;&lt;p&gt;使用 riot 编写组件是以 .tag 后缀结尾的文件，我们的 html, css, js 都可以放在里面。这些文件在编译阶段会被编译成对应的js代码(见&lt;a href=&quot;&quot;&gt;Riot.js 源码解析 【一】 基础内容&lt;/a&gt;)。每个组件都是一个 Tag 对象(代码在 /tag/tag.js 里面)，里面包含了对象的各种属性和方法。本文主要介绍，riot 组件的生命周期，更新原理(一个粗粒度的 virtual dom)以及简单更新优化手段。&lt;br&gt;
    
    </summary>
    
      <category term="前端源码解析" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="前端源码解析" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Riot.js" scheme="http://yoursite.com/tags/Riot-js/"/>
    
  </entry>
  
  <entry>
    <title>Riot.js 源码解析 【一】 基础内容</title>
    <link href="http://yoursite.com/2017/09/21/riot-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%901/"/>
    <id>http://yoursite.com/2017/09/21/riot-js-源码解析1/</id>
    <published>2017-09-21T14:36:37.000Z</published>
    <updated>2017-10-18T07:14:27.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Simple and elegant component-based UI library (Riot.js)    </p>
</blockquote>
<p>riot.js 是一个简单优雅的 js UI框架。具有自定义标签，简单语法，API简单，体积小，学习成本低等特点。riot.js 使用Model-View-Presenter (MVP)设计模式来组织代码，这样它能够更模块化、更具可测试性且易于理解。riot.js 仅仅提供了帮助UI渲染相关的基础功能，并不具备其它复杂的功能，因此其体积很小，压缩后仅有 10.39KB (react.min.js 大约 47.6KB )，很适合组件类的业务开发。<br>目前今日头条PC站，百度Hi的JS组件部分都是基于riot.js来开发的。<br>本系列文章，将会在介绍 riot.js 的使用方法的同时，解析其对应的源码内容，riot.js 版本为3.6.1。<br><a id="more"></a></p>
<h1 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h1><p>来一个简单的例子，基于 webpack 构建，依赖 riotjs-loader。<br>自定义标签代码，content-demo.tag   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> riot <span class="keyword">from</span> <span class="string">'riot'</span>;</div><div class="line">&lt;content-demo&gt; </div><div class="line">    &lt;style&gt;</div><div class="line">        h1 &#123;</div><div class="line">            color: pink;</div><div class="line">        &#125;</div><div class="line">    &lt;<span class="regexp">/style&gt;</span></div><div class="line"><span class="regexp">    &lt;h1&gt;&#123; message &#125;&lt;/</span>h1&gt;</div><div class="line">    &lt;ul&gt;</div><div class="line">        &lt;li each=&#123; lists &#125;&gt;&#123; name &#125;&lt;<span class="regexp">/li&gt;</span></div><div class="line"><span class="regexp">        &lt;script&gt;</span></div><div class="line"><span class="regexp">            this.message = 'hello world';</span></div><div class="line"><span class="regexp">            this.lists = [</span></div><div class="line"><span class="regexp">                &#123;</span></div><div class="line"><span class="regexp">                    'name': 'caelumtian'</span></div><div class="line"><span class="regexp">                &#125;,</span></div><div class="line"><span class="regexp">                &#123;</span></div><div class="line"><span class="regexp">                    'name': 'hyang'</span></div><div class="line"><span class="regexp">                &#125;</span></div><div class="line"><span class="regexp">            ]</span></div><div class="line"><span class="regexp">        &lt;/</span>script&gt;</div><div class="line">    &lt;<span class="regexp">/ul&gt;</span></div><div class="line"><span class="regexp">&lt;/</span>content-demo&gt;</div></pre></td></tr></table></figure>
<p>html 页面代码如下：  </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">content-demo</span>&gt;</span><span class="tag">&lt;/<span class="name">content-demo</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./dist/bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure>
<p>webpack 入口js文件    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> riot <span class="keyword">from</span> <span class="string">'riot'</span>;</div><div class="line"><span class="keyword">import</span> <span class="string">'./tags/content-demo.tag'</span>;</div><div class="line">riot.mount(<span class="string">'*'</span>);</div></pre></td></tr></table></figure>
<p>总体来说，riot.js 采用自定义标签的方式来书写UI组件，组件的生命周期仅有 update,updated,mount,unmount 四个。我们通过调用 riot.mount() 函数来决定页面加载哪些组件。  </p>
<h1 id="riot-js-运行流程"><a href="#riot-js-运行流程" class="headerlink" title="riot.js 运行流程"></a>riot.js 运行流程</h1><p>在上述 demo 中，我们将 <code>&lt;content-demo&gt;</code> 自定义标签写在了 *.tag 格式的文件中，作为一个组件。然后 webpack 打包时会利用 riot-compiler(官方编译工具)，将其编译成 js 代码 riot.tag2()，然后将其内容注册在<code>__TAG_IMPL</code>变量中。 最后用户调用 <code>riot.mount()</code> 函数来指定渲染哪个组件。运行流程，如下图所示：    </p>
<img src="/2017/09/21/riot-js-源码解析1/a.png" alt="a.png" title="">  
<h2 id="自定义标签命名"><a href="#自定义标签命名" class="headerlink" title="自定义标签命名"></a>自定义标签命名</h2><p>riot.js 对自定义标签的书写本身没有任何要求，但是 HTML5 引入了对自定义元素的标准 - <a href="https://w3c.github.io/webcomponents/spec/custom/#custom-elements" target="_blank" rel="external">Custom Elements 标准</a>。标准中对自定义元素名称有了限制：  </p>
<blockquote>
<p>“自定义元素的名字必须包含一个破折号（-）所以 <code>&lt;x-tags&gt;</code>、<code>&lt;my-element&gt;</code>和<code>&lt;my-awesome-app&gt;</code>都是正确的名字，而<tabs>和<foo_bar>是不正确的。这样的限制使得 HTML 解析器可以分辨那些是标准元素，哪些是自定义元素。”   </foo_bar></tabs></p>
</blockquote>
<p>距离来说，如果你的标签名称不带有破折号，那么浏览器会认为自定义元素是 <code>HTMLUnKnownElement</code>，如图所示：  </p>
<img src="/2017/09/21/riot-js-源码解析1/b.png" alt="b.png" title="">    
<p>所以，这里推荐在使用 riot.js 自定义标签的时候，遵守带有破折号的命名方式。  </p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>编译阶段的主要工作就是将riot语法写的<code>.tag</code>文件转换为可执行的.js文件，这部分主要靠编译器来完成。例子中，content-demo 最终会被编译成如下js代码：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">riot.tag2(<span class="string">'content-demo'</span>, <span class="string">'&lt;h1&gt;&#123;message&#125;&lt;/h1&gt; &lt;ul&gt; &lt;li each="&#123;lists&#125;"&gt;&#123;name&#125;&lt;/li&gt; &lt;/ul&gt;'</span>, <span class="string">'content-demo h1,[data-is="content-demo"] h1&#123; color: pink; &#125;'</span>, <span class="string">''</span>, <span class="function"><span class="keyword">function</span> (<span class="params">opts</span>) </span>&#123;</div><div class="line">	<span class="keyword">this</span>.message = <span class="string">'hello world'</span>;</div><div class="line">	<span class="keyword">this</span>.lists = [&#123;</div><div class="line">	    <span class="string">'name'</span>: <span class="string">'caelumtian'</span></div><div class="line">	&#125;, &#123;</div><div class="line">	    <span class="string">'name'</span>: <span class="string">'hyang'</span></div><div class="line">	&#125;];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>riot.tag2 函数在 riot.js 源码中的 core.js 文件中，代码如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">tag2</span>(<span class="params">name, tmpl, css, attrs, fn</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (css) styleManager.add(css, name)</div><div class="line">    <span class="comment">// tags implementation cache 标签接口缓存</span></div><div class="line">    __TAG_IMPL[name] = &#123;</div><div class="line">        name,</div><div class="line">        tmpl,</div><div class="line">        attrs,</div><div class="line">        fn</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> name</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参数含义如下：  </p>
<ul>
<li>name: riot 自定义标签的名称</li>
<li>tmpl: 标签的html内容</li>
<li>css: <code>&lt;style&gt;</code> 标签中的内容</li>
<li>attrs: riot 自定义标签的属性</li>
<li>fn: 用户自定义函数,即 <code>&lt;script&gt;</code> 标签中的内容  </li>
</ul>
<p><code>riot.tag2()</code> 函数将 riot tag 注册到了 <code>__TAG_IMP</code> 对象中，方便之后的使用，css部分则被添加到了 <code>byName</code> 变量中，用于之后统一添加到页面中。在源代码中，还有一个 <code>riot.tag()</code>函数，这个函数用于直接直接创建一个 riot tag 实例的接口，而 <code>riot.tag2()</code> 是暴露给编辑器的接口，本质上功能是一样的。</p>
<h2 id="加载-riot-mount"><a href="#加载-riot-mount" class="headerlink" title="加载 riot.mount()"></a>加载 riot.mount()</h2><p>组件被注册号以后，并没有被渲染，直到我们调用 <code>riot.mount()</code> 函数后，相应的组件才会渲染到页面上。riot.mount 主要用法如下：  </p>
<ul>
<li>riot.mount(‘*’, [opts]): 将注册好的所有 riot tag 都渲染到页面上</li>
<li>riot.mount(customTagSelector, [opts]): 根据标签选择器，渲染指定的 riot tag。 例如：上述示例中，我们也可以这样写 riot.mount(‘content-demo’)。  </li>
<li>riot.mount(selector, tagName, [opts]): 将 riot tag 渲染到指定的节点中。例如： riot.mount(“div#main”, “content-demo”, api)   将 <code>&lt;my-tag&gt;</code>挂载到 <code>div#main</code> 内。  </li>
</ul>
<p>这里面的 opts 为可选参数，是用户设置的标签的其他属性内容。这里就不过多介绍了，之后的文章会有解释。下面为 riot.mount 注释过的源码：      </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params">selector, tagName, opts</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> tags = []</div><div class="line">    <span class="keyword">let</span> elem, allTags</div><div class="line">    <span class="comment">// root &#123;HTMLElement&#125; riot-tag 标签节点</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">pushTagsTo</span>(<span class="params">root</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root.tagName) &#123;</div><div class="line">            <span class="keyword">let</span> riotTag = getAttr(root, IS_DIRECTIVE),    <span class="comment">// 要么 data-is 要么 root.tagName 本身</span></div><div class="line">                tag</div><div class="line">            <span class="comment">// ① 设置 data-is 属性指向</span></div><div class="line">            <span class="keyword">if</span> (tagName &amp;&amp; riotTag !== tagName) &#123;</div><div class="line">                riotTag = tagName</div><div class="line">                setAttr(root, IS_DIRECTIVE, tagName)</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// ② mountTo 创建一个新的 riot tag 实例</span></div><div class="line">            tag = mountTo(root, riotTag || root.tagName.toLowerCase(), opts)</div><div class="line">            <span class="keyword">if</span> (tag)</div><div class="line">                tags.push(tag)</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.length)</div><div class="line">            each(root, pushTagsTo)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// DOM 注入 style 标签</span></div><div class="line">    styleManager.inject()</div><div class="line">    <span class="keyword">if</span> (isObject(tagName)) &#123;</div><div class="line">        opts = tagName</div><div class="line">        tagName = <span class="number">0</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (isString(selector)) &#123;</div><div class="line">        selector = selector === <span class="string">'*'</span> ?</div><div class="line">            allTags = selectTags() :</div><div class="line">            selector + selectTags(selector.split(<span class="regexp">/, */</span>))</div><div class="line">        <span class="comment">// ③ 利用 $$ 来判断 这些 tag 是否已经挂载在 html 上面</span></div><div class="line">        elem = selector ? $$(selector) : []</div><div class="line">    &#125; <span class="keyword">else</span></div><div class="line">        elem = selector</div><div class="line">    <span class="comment">// 将所有元素挂载在根元素中</span></div><div class="line">    <span class="keyword">if</span> (tagName === <span class="string">'*'</span>) &#123;</div><div class="line">        tagName = allTags || selectTags()</div><div class="line">        <span class="keyword">if</span> (elem.tagName)</div><div class="line">            <span class="comment">// 查找elem下的 tagName</span></div><div class="line">            elem = $$(tagName, elem)</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 将查找到的所有节点都 放入 nodeList中</span></div><div class="line">            <span class="keyword">var</span> nodeList = []</div><div class="line">            each(elem, _el =&gt; nodeList.push($$(tagName, _el)))</div><div class="line">            elem = nodeList</div><div class="line">        &#125;</div><div class="line">        tagName = <span class="number">0</span></div><div class="line">    &#125;</div><div class="line">    pushTagsTo(elem)</div><div class="line">    <span class="keyword">return</span> tags</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当调用 riot.mount 后，通过 selector 参数来查找 html 页面上对应的节点。<code>不在 html 上的节点是不会被渲染的</code>。③处代码为查找过程，其中$$为 <code>document.querySelectAll</code>。之后调用 pushTagsTo 函数来渲染 riot tag。<br><code>IS_DIRECTIVE = &#39;data-is&#39;</code> 渲染前，要检查是否含有 tagName 参数，如果有的话即为 上述 riot.mount 的第三个用法。此时需要检测 root 的 data-is 属性值是否和 tagName 相等，如①处。不相等则将 root 设置其 data-is 为 tagName。即 riot.mount(‘div#main’, ‘content-demo’) 渲染出的节点为 :  </p>
<blockquote>
<p><code>&lt;div id=&quot;main&quot; data-is=&quot;content-demo&quot;&gt;&lt;content-demo&gt;...&lt;/content-demo&gt;&lt;/div&gt;</code> </p>
</blockquote>
<p>最后，通过 mountTo 函数渲染处理好的 riot tag，如②处。mountTo 函数后续会有详解。  </p>
<blockquote>
<p>代码中使用了 tagName 而不是 nodeName 原因如下：nodeName是node 接口上的property，而tagName是element 接口上的property，所有的节点（元素节点，属性节点，文本节点等12种）都继承了node接口，而只有元素节点才继承了element节点。  </p>
</blockquote>
<h2 id="取消注册-riot-unregister"><a href="#取消注册-riot-unregister" class="headerlink" title="取消注册 riot.unregister()"></a>取消注册 riot.unregister()</h2><p>riot 全局变量上还包含 riot.unregister(name) 函数用户取消注册过的内容，通常我们在测试程序的时候，创建同名标签使用。示例如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个测试标签</span></div><div class="line">riot.tag(<span class="string">'test-tag'</span>, <span class="string">'&lt;p&gt;&#123; message &#125;&lt;/p&gt;'</span>)</div><div class="line"><span class="comment">// 注册标签</span></div><div class="line"><span class="keyword">var</span> tag = riot.mount(<span class="built_in">document</span>.createElement(<span class="string">'div'</span>), <span class="string">'test-tag'</span>)[<span class="number">0</span>]</div><div class="line">expect(tag.root.querySelector(<span class="string">'p'</span>)).to.be.ok</div><div class="line"><span class="comment">// 取消注册</span></div><div class="line">riot.unregister(<span class="string">'test-tag'</span>)</div><div class="line"><span class="comment">// 重新创建一个同名，但是不一样的标签</span></div><div class="line">riot.tag(<span class="string">'test-tag'</span>, <span class="string">'&lt;div&gt;&#123; message &#125;&lt;/div&gt;'</span>)</div></pre></td></tr></table></figure>
<p>riot.unregister() 源码十分简单，如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">unregister</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    __TAG_IMPL[name] = <span class="literal">null</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>暴露在 riot 全局变量上的函数，还包括 <code>riot.update</code> 和 <code>riot.mixin</code> 两个，将在后面的内容介绍。  </p>
<h1 id="源码目录结构"><a href="#源码目录结构" class="headerlink" title="源码目录结构"></a>源码目录结构</h1><p>riot 3.6.1 的源码目录结构如下：</p>
<pre><code>|____browser
| |____common
| | |____global-variables.js // 使用到的常量
| | |____util                    
| | | |____check.js   // 变量类型，属性等检查
| | | |____dom.js     // dom 操作
| | | |____misc.js    // 用到的工具类函数
| | | |____tags.js    // riot tag 操作      
| |____compiler
| | |____index.js     // riot tag 模板解析
| |____tag
| | |____core.js      // riot 对外暴露函数接口
| | |____each.js      // riot tag each操作渲染
| | |____if.js        // riot tag if操作渲染
| | |____mkdom.js     // 创建 dom 节点
| | |____parse.js     // riot tag 解析
| | |____ref.js       // riot tag ref
| | |____setEventHandler.js  // riot tag 事件绑定
| | |____styleManager.js     // 样式管理
| | |____tag.js              // riot tag 标签类
|___|____update.js           // riot tag 更新操作
</code></pre><p>本文涉及到的源码，主要出自 <code>core.js</code> 和 <code>styleManager.js</code>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Simple and elegant component-based UI library (Riot.js)    &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;riot.js 是一个简单优雅的 js UI框架。具有自定义标签，简单语法，API简单，体积小，学习成本低等特点。riot.js 使用Model-View-Presenter (MVP)设计模式来组织代码，这样它能够更模块化、更具可测试性且易于理解。riot.js 仅仅提供了帮助UI渲染相关的基础功能，并不具备其它复杂的功能，因此其体积很小，压缩后仅有 10.39KB (react.min.js 大约 47.6KB )，很适合组件类的业务开发。&lt;br&gt;目前今日头条PC站，百度Hi的JS组件部分都是基于riot.js来开发的。&lt;br&gt;本系列文章，将会在介绍 riot.js 的使用方法的同时，解析其对应的源码内容，riot.js 版本为3.6.1。&lt;br&gt;
    
    </summary>
    
      <category term="前端源码解析" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="前端源码解析" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Riot.js" scheme="http://yoursite.com/tags/Riot-js/"/>
    
  </entry>
  
  <entry>
    <title>js增量更新算法研究</title>
    <link href="http://yoursite.com/2017/09/18/js%E5%A2%9E%E9%87%8F%E6%9B%B4%E6%96%B0%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6/"/>
    <id>http://yoursite.com/2017/09/18/js增量更新算法研究/</id>
    <published>2017-09-18T03:42:55.000Z</published>
    <updated>2017-09-28T08:21:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="serviceWorker-方案-js增量更新算法研究"><a href="#serviceWorker-方案-js增量更新算法研究" class="headerlink" title="serviceWorker 方案 - js增量更新算法研究"></a>serviceWorker 方案 - js增量更新算法研究</h1><h2 id="调研背景"><a href="#调研背景" class="headerlink" title="调研背景"></a>调研背景</h2><blockquote>
<p>根据之前 serviceWorker 的调研，当服务端文件更新后，serviceWorker 会做对比，并请求这些新的文件。所有发生变化的文件都会被更新。现在 new-mini 内嵌页面，js 都被压缩成了一个文件。这样每次很小的文件改动，都会导致客户端需要下载整个js文件，这样会造成流量的浪费，同时也对服务器造成过大的流量压力。为此我们需要减少更新文件的体积，来更好的完成 serviceWorker 的架构。  </p>
</blockquote>
<a id="more"></a>
<h2 id="js-增量更新算法"><a href="#js-增量更新算法" class="headerlink" title="js 增量更新算法"></a>js 增量更新算法</h2><p>利用增量更新算法，我们大大的降低每次文件变动后传输的大小。这里调研了4中常见的js 增量更新算法：  </p>
<h3 id="基于chunk的增量更新算法"><a href="#基于chunk的增量更新算法" class="headerlink" title="基于chunk的增量更新算法"></a>基于chunk的增量更新算法</h3><p>首先将旧的文件分成n块并并编号<br><img src="/2017/09/18/js增量更新算法研究/a.png" alt="a.png" title=""><br>然后在新文件上进行，滚动查找。如果找到匹配的则记录块号，如果没找到则块往前移动 1 个字符，并把上个字符压入新数据块,然后扫描下一块，最终得到一个新数据和数据块号的组合的增量文件（这一步可以用上线 JavaScript 时用的打包工具或者请求 JavaScript 服务器程序实时计算出来）。<br><img src="/2017/09/18/js增量更新算法研究/b.png" alt="b.png" title=""><br>最终得到的增量文件如下所示：  </p>
<blockquote>
<p>1, data1, 2, 3, data2, 4, 5, 6  </p>
</blockquote>
<p>进一步合并顺序快得到：  </p>
<blockquote>
<p>[1, 1], data1, [2, 2], data2, [4, 4]  </p>
</blockquote>
<p>客户端根据旧文件的 chunk 数据和增量更新数据，我们可以得出新版本数据由如下数据组成：  </p>
<blockquote>
<p>chunk0+data1+chunk1+chunk2+data2+chunk3+chunk4+chunk5  </p>
</blockquote>
<p>例如以 s = ‘‘1345678abcdefghijklmnopq’ 修改为 a = ‘‘13456<code>f</code>78abcd<code>2</code>efghijklmnopq’为例, 设块长度为4 则， 源文件分成：<br><br>通过滚动查找，得到新文件<br><br>最终增量文件表示如下数组: [“a=‘1”,2,”f”,3,”cd2ef”,5,6,7]。 进一步合并顺序块，可用一个js数组表示为： [“a=‘1”,[2,1],“f”,[3,1],“cd2ef”,[5,3]。<br>在 serviceWorker 客户端这边，调用如下函数，进行文件更新：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//source 是上一个版本内容，trunkSize 是块大小，checksumcode 是两个版本间的增量文件数组</span></div><div class="line"><span class="keyword">var</span> rsyncjs = <span class="function"><span class="keyword">function</span>(<span class="params">source,trunkSize,checksumcode</span>)</span>&#123;</div><div class="line">   <span class="keyword">var</span> strResult=<span class="string">""</span>;</div><div class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; checksumcode.length; i++)&#123;</div><div class="line">       <span class="keyword">var</span> code = checksumcode[i];</div><div class="line">       <span class="keyword">if</span>(<span class="keyword">typeof</span> code === <span class="string">'string'</span>)&#123;</div><div class="line">            strResult+=code;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">var</span> start = code[<span class="number">0</span>] * trunkSize;</div><div class="line">            <span class="keyword">var</span> len = code[<span class="number">1</span>] * trunkSize;</div><div class="line">            <span class="keyword">var</span> oldcode = source.substr(start, len);</div><div class="line">            strResult += oldcode;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> strResult;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法存在的问题为：增量更新的精确度依赖于chunk的大小，在实际使用中总是会有不少代码需要冗余下载。  </p>
<h3 id="Myer’s-diff-algorithm"><a href="#Myer’s-diff-algorithm" class="headerlink" title="Myer’s diff algorithm"></a>Myer’s diff algorithm</h3><p>Myer’s diff algorithm 首次出是在1986年一篇论文中<a href="https://neil.fraser.name/software/diff_match_patch/myers.pdf" target="_blank" rel="external">“An O(ND) Difference Algorithm and Its Variations”</a>, 在文中实现上介绍了两种此diff算法 的实现。两种实现的核心思想是一致的，只是在具体的实现过程中，为进一步提升算法的性能及空间利用率，采取了不一致的迭代方式。<br>算法原理比较复杂，github 上有根据该算法实现的 <a href="https://github.com/kpdecker/jsdiff" target="_blank" rel="external">jsdiff 插件</a><br>简单的演示如下：   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>(<span class="string">'colors'</span>);</div><div class="line"><span class="keyword">let</span> jsdiff = <span class="built_in">require</span>(<span class="string">'diff'</span>);</div><div class="line"><span class="keyword">let</span> oldStr = <span class="string">'bcdsgaff2 123'</span>;</div><div class="line"><span class="keyword">let</span> newStr = <span class="string">'accdgadff2 42356'</span>;</div><div class="line"><span class="keyword">let</span> diff = jsdiff.diffChars(oldStr, newStr);</div><div class="line"><span class="built_in">console</span>.log(diff);</div><div class="line">diff.forEach(<span class="function"><span class="params">part</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> color = part.added ? <span class="string">'green'</span> : part.removed ? <span class="string">'red'</span> : <span class="string">'gray'</span>;</div><div class="line">    process.stderr.write(part.value[color]); </div><div class="line">&#125;) </div><div class="line"><span class="string">``</span><span class="string">`    </span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">&#123;% asset_img 5.png %&#125;  </span></div><div class="line"><span class="string">可以清楚的看到差异信息，这里我们利用下面这个函数 简化一下jsdiff输出信息，方便传输。    </span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">`</span><span class="string">``</span>javascript  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">minimizeDiffInfo</span>(<span class="params">originalInfo</span>)</span>&#123;</div><div class="line">    <span class="keyword">let</span> result = originalInfo.map(<span class="function"><span class="params">info</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">if</span>(info.added)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">'+'</span> + info.value;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(info.removed)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">'-'</span> + info.count;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> info.count;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(result);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果为：<br><img src="/2017/09/18/js增量更新算法研究/6.png" alt="6.png" title=""><br>客户端，采用如下函数，更新 serviceWorker 中的资源：  </p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">mergeDiff</span>(<span class="params">oldString, diffInfo</span>)</span>{
    <span class="keyword">let</span> newString = <span class="string">''</span>;
    <span class="keyword">let</span> diffInfo = <span class="built_in">JSON</span>.parse(diffInfo);
    <span class="keyword">let</span> index = <span class="number">0</span>;
    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; diffInfo.length; i++){
        <span class="keyword">let</span> info = diffInfo[i];
        <span class="keyword">if</span>(<span class="keyword">typeof</span> info === <span class="string">'number'</span>){
            newString += oldString.slice(index, index + info);
            index += info;
            <span class="keyword">continue</span>;
        }
        <span class="keyword">if</span>(<span class="keyword">typeof</span> info === <span class="string">'string'</span>){
            <span class="keyword">if</span>(info[<span class="number">0</span>] === <span class="string">'+'</span>){
                <span class="keyword">let</span> addedString = info.slice(<span class="number">1</span>, info.length);
                newString += addedString;
            }
            <span class="keyword">if</span>(info[<span class="number">0</span>] === <span class="string">'-'</span>){
                <span class="keyword">let</span> removedCount = <span class="built_in">parseInt</span>(info.slice(<span class="number">1</span>, info.length));
                index += removedCount;
            }
        }
    }
    <span class="keyword">return</span> newString;
}
</code></pre>
<p>该方案，实际测试结果很糟糕，对于文件很大的内容比对时间都够我睡一觉了。    </p>
<h2 id="基于编辑距离的比对算法"><a href="#基于编辑距离的比对算法" class="headerlink" title="基于编辑距离的比对算法"></a>基于编辑距离的比对算法</h2><h3 id="什么是编辑距离"><a href="#什么是编辑距离" class="headerlink" title="什么是编辑距离"></a>什么是编辑距离</h3><blockquote>
<p>编辑距离是针对二个字符串（例如英文字）的差异程度的量化量测，量测方式是看至少需要多少次的处理才能将一个字符串变成另一个字符串。编辑距离可以用在自然语言处理中，例如拼写检查可以根据一个拼错的字和其他正确的字的编辑距离，判断哪一个（或哪几个）是比较可能的字。DNA也可以视为用A、C、G和T组成的字符串，因此编辑距离也用在生物信息学中，判断二个DNA的类似程度。Unix 下的 diff 及 patch 即是利用编辑距离来进行文本编辑对比的例子。  </p>
</blockquote>
<h4 id="求解算法"><a href="#求解算法" class="headerlink" title="求解算法"></a>求解算法</h4><p>比如要计算cafe和coffee的编辑距离。cafe→caffe→coffe→coffee。先创建一个6×8的表（cafe长度为4，coffee长度为6，各加2):<br><img src="/2017/09/18/js增量更新算法研究/8.png" alt="8.png" title=""><br>接着，在如下位置添加数字<br><img src="/2017/09/18/js增量更新算法研究/9.png" alt="9.png" title=""><br>从3,3格开始，开始计算。取以下三个值的最小值：    </p>
<ul>
<li>如果最上方的字符等于最左方的字符，则为左上方的数字。否则为左上方的数字+1。（对于3,3来说为0）</li>
<li>左方数字+1（对于3,3格来说为2）</li>
<li>上方数字+1（对于3,3格来说为2）  </li>
</ul>
<p>因此为格3,3为0:<br><img src="/2017/09/18/js增量更新算法研究/10.png" alt="10.png" title=""><br>循环操作，推出下表：<br><img src="/2017/09/18/js增量更新算法研究/11.png" alt="11.png" title=""><br>取右下角，得编辑距离为3。   </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;serviceWorker-方案-js增量更新算法研究&quot;&gt;&lt;a href=&quot;#serviceWorker-方案-js增量更新算法研究&quot; class=&quot;headerlink&quot; title=&quot;serviceWorker 方案 - js增量更新算法研究&quot;&gt;&lt;/a&gt;serviceWorker 方案 - js增量更新算法研究&lt;/h1&gt;&lt;h2 id=&quot;调研背景&quot;&gt;&lt;a href=&quot;#调研背景&quot; class=&quot;headerlink&quot; title=&quot;调研背景&quot;&gt;&lt;/a&gt;调研背景&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;根据之前 serviceWorker 的调研，当服务端文件更新后，serviceWorker 会做对比，并请求这些新的文件。所有发生变化的文件都会被更新。现在 new-mini 内嵌页面，js 都被压缩成了一个文件。这样每次很小的文件改动，都会导致客户端需要下载整个js文件，这样会造成流量的浪费，同时也对服务器造成过大的流量压力。为此我们需要减少更新文件的体积，来更好的完成 serviceWorker 的架构。  &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[译] 使用Web Speech API和Node.js构建简单的AI Chatbot</title>
    <link href="http://yoursite.com/2017/09/02/%E8%AF%91-%E4%BD%BF%E7%94%A8WebSpeechAPI/"/>
    <id>http://yoursite.com/2017/09/02/译-使用WebSpeechAPI/</id>
    <published>2017-09-02T11:55:05.000Z</published>
    <updated>2017-09-22T07:09:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>随着语音技术的普及，越来越多的手机用户开始使用Siri和Cortana等语音助理软件。Amazon Echo和Google Home等语音软件同样走入了我们的日常生活。这些系统基于语音识别软件构建允许用户直接通过语音下达命令。现在，浏览器也已经支持了Web Speech API，它允许用户在web应用程序中集成语音数据。<br>基于现在的web应用程序，我们可以使用多种UI元素来和用户交互。使用Web Speech API，我们可以开发更加自然地小巧的web可视化界面。这样我们就能开发更丰富的web应用程序。此外，该API也可以帮助身体或认知障碍的人更好的访问web信息。<br><a id="more"></a>   </p>
<blockquote>
<p>增强用户体验<br>Web Speeh API可以使网站和Web app不仅仅可以交谈还可以聆听。这里有一些关于猪呢个条用户体验的很好的例子。<a href="https://www.smashingmagazine.com/2014/12/enhancing-ux-with-the-web-speech-api/" target="_blank" rel="external">阅读更多</a>  </p>
</blockquote>
<p>在本教程中，我们将使用API在浏览器中创建人工智能（AI）语音聊天界面。该应用将听取用户的声音并以合成语音回复。因为Web Speech API依然是实现性的，所以目前仅能支持在有限的浏览器中。本文使用的语音识别和语音合成功能目前仅基于Chromium浏览器，包括Chrome 25+和Opera 27+，而Firefox，Edge和Safari目前仅支持语音合成。    </p>
<img src="/2017/09/02/译-使用WebSpeechAPI/1.png" alt="1.png" title="">  
<img src="/2017/09/02/译-使用WebSpeechAPI/2.png" alt="2.png" title="">  
<p>要构建该程序，我们主要采取三个步骤：    </p>
<ol>
<li>使用Web Speech API的SpeechRecognition接口来聆听用户的语音  </li>
<li>将用户消息作为字符串文本发送给商业的自然语言处理API</li>
<li>一旦API.AI返回响应文本，我们就利用SpeechSynthesis接口返回给用户一个合成声音    </li>
</ol>
<img src="/2017/09/02/译-使用WebSpeechAPI/3.png" alt="3.png" title="">
<p>本教程使用的<a href="https://github.com/girliemac/web-speech-ai" target="_blank" rel="external">完整的源代码</a>在GitHub上。  </p>
<h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><p>本教程依赖于Node.js,你需要对JavaScript和Node.js有一定的了解并确保您的电脑上已经安装了Noded.js。  </p>
<h2 id="构建你的Node-js应用"><a href="#构建你的Node-js应用" class="headerlink" title="构建你的Node.js应用"></a>构建你的Node.js应用</h2><p>首先，让我们搭建一个Node.js的应用框架。创建你的应用目录，并设置如下的目录结构：   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">├── index.js</div><div class="line">├── public</div><div class="line">│   ├── css</div><div class="line">│   │   └── style.css</div><div class="line">│   └── js</div><div class="line">│       └── script.js</div><div class="line">└── views</div><div class="line">    └── index.html</div></pre></td></tr></table></figure>
<p>之后利用如下命令来初始化你的Node.js应用：  </p>
<blockquote>
<p>npm init -f    </p>
</blockquote>
<p>我们将使用Express(一个Node.js Web应用框架)来搭建本地服务。为了实现服务器和浏览器之间的双向通信，我们将使用Socket.IO。同时，我们还将使用自然语言处理工具API.AI，来构建可以人工交谈的AI聊天工具。<br>Socket.IO，能够让我们更方便的使用WebSocket。通过在客户端和服务端建立socket连接。当Web Speech API或API.AI 返回文本数据的时候，我们能将聊天信息在浏览器和服务器之间传递。<br>首先，我们创建index.js文件并实例化Express作为服务器：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</div><div class="line"><span class="keyword">const</span> app = express();</div><div class="line"></div><div class="line">app.use(express.static(__dirname + <span class="string">'/views'</span>)); <span class="comment">// html</span></div><div class="line">app.use(express.static(__dirname + <span class="string">'/public'</span>)); <span class="comment">// js, css, images</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> server = app.listen(<span class="number">5000</span>);</div><div class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</div><div class="line">  res.sendFile(<span class="string">'index.html'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>下一步，我们将Web Speech API集成到前端代码。  </p>
<h2 id="利用-SpeechRecognition-接口接收语音"><a href="#利用-SpeechRecognition-接口接收语音" class="headerlink" title="利用 SpeechRecognition 接口接收语音"></a>利用 SpeechRecognition 接口接收语音</h2><p>Web Speech API具有名为SpeechRecognition的接口，用来从麦克风中获取用户们的讲话并了解他们在说什么。 </p>
<h3 id="创建用户界面"><a href="#创建用户界面" class="headerlink" title="创建用户界面"></a>创建用户界面</h3><p>该程序的UI界面很简单，仅有一个按钮来触发语音识别。让我们创建一个index.html文件，其中包含js文件和Socket.IO，稍后我们将用它启动实时通讯：  </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span>…<span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    …</div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.0.1/socket.io.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/script.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>然后，在页面中加入按钮接口：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>Talk<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div></pre></td></tr></table></figure>
<p>要想查看按钮的样式，你何以查看<a href="https://github.com/girliemac/web-speech-ai" target="_blank" rel="external">源代码</a>中的style.css文件。  </p>
<h3 id="使用JavaScript捕获语音"><a href="#使用JavaScript捕获语音" class="headerlink" title="使用JavaScript捕获语音"></a>使用JavaScript捕获语音</h3><p>在script.js中，创建SpeechRecognition实例来识别语音： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> SpeechRecognition = <span class="built_in">window</span>.SpeechRecognition || <span class="built_in">window</span>.webkitSpeechRecognition;</div><div class="line"><span class="keyword">const</span> recognition = <span class="keyword">new</span> SpeechRecognition();</div></pre></td></tr></table></figure>
<p>我们使用了带有前缀和不带的两个对象做判断，因为Chrome当前支持带有前缀的API。<br>同时，我们在本教程中使用了一些ES6语法，包括const，箭头函数等等，他们都可以在支持语音接口的浏览器中使用。<br>你可以设置各种属性，来自定义语音识别：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">recognition.lang = <span class="string">'en-US'</span>;</div><div class="line">recognition.interimResults = <span class="literal">false</span>;</div></pre></td></tr></table></figure>
<p>之后，监听button UI的DOM节点的点击事件来启动语音识别：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.querySelector(<span class="string">'button'</span>).addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</div><div class="line">    recognition.start();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>一旦语音开始，我们就调用result事件，来获取语音文本：   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">recognition.addEventListener(<span class="string">'result'</span>, (e) =&gt; &#123;</div><div class="line">  <span class="keyword">let</span> last = e.results.length - <span class="number">1</span>;</div><div class="line">  <span class="keyword">let</span> text = e.results[last][<span class="number">0</span>].transcript;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Confidence: '</span> + e.results[<span class="number">0</span>][<span class="number">0</span>].confidence);</div><div class="line">  <span class="comment">// We will use the Socket.IO here later…</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这将返回一个包含结果的SpeechRecognitionResultList兑现，你可以在数组中检索文字信息。接下来我们使用Socket.IO来传递数据额给我们的服务器。</p>
<h2 id="Socket-IO做实时通讯"><a href="#Socket-IO做实时通讯" class="headerlink" title="Socket.IO做实时通讯"></a>Socket.IO做实时通讯</h2><p>Socket.IO是一个做实时通讯web应用的库。他可以实现web客户端和服务端之间的双向通讯。我们将使用它将语音结果传递给Node.js，将相应信息传回浏览器。<br>你也许会有疑虑为什么我们不使用简单的HTTP协议或者AJAX。你可以发送POST请求来传奇数据。但是我们通过Socket.IO来创建webscoket，是因为这是最好的实现双向通讯的解决方案。特别是服务器向浏览器发送数据，如果采用AJAX来实现我们就不得不再用轮训的方式： </p>
<img src="/2017/09/02/译-使用WebSpeechAPI/4.png" alt="4.png" title=""> 
<p>在script.js中实例化Socket.IO：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> socket = io();</div></pre></td></tr></table></figure>
<p>然后将下面这段代码加入到监听reuslt事件的回调函数中：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">socket.emit(<span class="string">'chat message'</span>, text);</div></pre></td></tr></table></figure>
<p>我们回到Node.js代码中，来接受这些文本并使用API来回复用户的消息。  </p>
<h2 id="从AI中获取回复"><a href="#从AI中获取回复" class="headerlink" title="从AI中获取回复"></a>从AI中获取回复</h2><p>许多平台提供的服务可以将带有自然语言处理的AI系统结合到项目中，包括IBM的Watson，微软的LUIS和Wit.ai。为了快速构建一个会话接口，我们使用API.AI。因为它提供了免费的开发者帐户，并允许我们使用其Web界面和Node.js库快速设置一个小型的系统。  </p>
<h3 id="设置API-AI"><a href="#设置API-AI" class="headerlink" title="设置API.AI"></a>设置API.AI</h3><p>首先创建一个账户和代理。更多内容可以参考<a href="https://docs.api.ai/docs/get-started" target="_blank" rel="external">入门指南</a>中的第一步。<br>然后，创建entities和intents。点击左侧菜单中的”Small Talk”，然后切换开关即可开启服务。  </p>
<img src="/2017/09/02/译-使用WebSpeechAPI/5.png" alt="5.png" title="">
<p>根据你的喜好，自定义API.AI接口的代理。  </p>
<h3 id="使用API-AI的Node-js-SDK"><a href="#使用API-AI的Node-js-SDK" class="headerlink" title="使用API.AI的Node.js SDK"></a>使用API.AI的Node.js SDK</h3><p>我们利用Node.js SDK来链接Node.js应用和API.AI。回到你的index.js文件中，利用你的access token来初始化API.AI：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> apiai = <span class="built_in">require</span>(<span class="string">'apiai'</span>)(APIAI_TOKEN);</div></pre></td></tr></table></figure>
<p>如果您只想在本地运行代码，可以在此处对API密钥进行编码。这里有多种方式来设置环境变量，我通常使用设置 .env 文件来包含变量信息。在GitHub源码中，我将包含凭证的信息文件添加到了.gitignroe中，你可以查看 <a href="https://github.com/girliemac/web-speech-ai/blob/master/.env_test" target="_blank" rel="external">.env-test</a> 文件来查看他是如何设置的。  </p>
<p>现在我么能使用服务端的Socket.IO来获取浏览器的结果。<br>一旦接收到消息，我们就用API.AI的API来检索并回复用户信息：    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">io.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">socket</span>) </span>&#123;</div><div class="line">    socket.on(<span class="string">'chat message'</span>, (text) =&gt; &#123;</div><div class="line">        <span class="comment">// Get a reply from API.AI</span></div><div class="line">        <span class="keyword">let</span> apiaiReq = apiai.textRequest(text, &#123;</div><div class="line">            sessionId: APIAI_SESSION_ID</div><div class="line">        &#125;);</div><div class="line">        apiaiReq.on(<span class="string">'response'</span>, (response) =&gt; &#123;</div><div class="line">            <span class="keyword">let</span> aiText = response.result.fulfillment.speech;</div><div class="line">            socket.emit(<span class="string">'bot reply'</span>, aiText); <span class="comment">// Send the result back to the browser!</span></div><div class="line">        &#125;);</div><div class="line">        apiaiReq.on(<span class="string">'error'</span>, (error) =&gt; &#123;</div><div class="line">            <span class="built_in">console</span>.log(error);</div><div class="line">        &#125;);</div><div class="line">        apiaiReq.end();</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>当API.AI返回结果时，使用Socket.IO socket.emit()将其发送回浏览器。  </p>
<h2 id="利用SpeechSynthesis接口来合成语音"><a href="#利用SpeechSynthesis接口来合成语音" class="headerlink" title="利用SpeechSynthesis接口来合成语音"></a>利用SpeechSynthesis接口来合成语音</h2><p>然我们再次回到script.js中，完成我们的应用！<br>创建一个语音合成器，这次我们使用SpeechSynthesis接口。该函数将接受字符串作为参数，并使浏览器能够说出文本：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">synthVoice</span>(<span class="params">text</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> synth = <span class="built_in">window</span>.speechSynthesis;</div><div class="line">    <span class="keyword">const</span> utterance = <span class="keyword">new</span> SpeechSynthesisUtterance();</div><div class="line">    utterance.text = text;</div><div class="line">    synth.speak(utterance);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该函数中，我们首先创建了一个API入口对象，window.speechSynthesis。这次我们没有在使用前缀，该API的支持度更高，许多浏览器已经移除了该前缀。<br>然后，我们创建一个SpeechSynthesisUtterance实例，并设置要合成语音的文本。你也可以设置其他属性，例如voice类型和操作系统支持的语音类型。<br>最后，我们使用SpeechSynthesis.speak()来是浏览器说话。现在，再次从Socket.IO获取服务器的响应。一旦接收到消息，请调用该功能。    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">socket.on(<span class="string">'bot reply'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">replyText</span>) </span>&#123;</div><div class="line">  synthVoice(replyText);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>至此我们完成了全部功能，你可以试试:  </p>
<img src="/2017/09/02/译-使用WebSpeechAPI/6.gif" alt="6.gif" title="">
<p>请注意，浏览器在首次的时候会询问你是否使用麦克风。像其他Web API（如Geolocation API和Notification API）一样，除非你授予它，否则浏览器将永远不会访问您的敏感信息，因此你的声音不会在不知情的情况下被秘密记录。<br>API.AI是可配置和可训练的。阅读API.AI文档，使其更加智能。   </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>本教程仅涵盖了API的核心功能，但该API实际上是非常灵活和可自定义的。您可以改变识别语言，合成语音，包括口音（如美国或英国英语），语音音调和语速。你可以在这里了解有关API的更多信息：   </p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Speech_API" target="_blank" rel="external">Web Speech API</a> Mozilla Developer Network</li>
<li><a href="https://dvcs.w3.org/hg/speech-api/raw-file/tip/speechapi.html" target="_blank" rel="external">Web Speech API Specification</a> W3C</li>
<li><a href="https://docs.microsoft.com/en-us/microsoft-edge/dev-guide/multimedia/web-speech-api" target="_blank" rel="external">Web Speech API: Speech Synthesis</a> (Microsoft Edge documentation) Microsoft  </li>
</ul>
<p>自然语言处理工具你可以参考如下：  </p>
<ul>
<li><a href="https://api.ai/" target="_blank" rel="external">API.AI</a> Google</li>
<li><a href="https://wit.ai/" target="_blank" rel="external">Wit.ai</a> Facebook</li>
<li><a href="https://www.luis.ai/" target="_blank" rel="external">LUIS</a> Microsoft</li>
<li><a href="https://www.ibm.com/watson/" target="_blank" rel="external">Watson</a> IBM</li>
<li><a href="https://aws.amazon.com/cn/lex/" target="_blank" rel="external">Lex</a> Amazon</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着语音技术的普及，越来越多的手机用户开始使用Siri和Cortana等语音助理软件。Amazon Echo和Google Home等语音软件同样走入了我们的日常生活。这些系统基于语音识别软件构建允许用户直接通过语音下达命令。现在，浏览器也已经支持了Web Speech API，它允许用户在web应用程序中集成语音数据。&lt;br&gt;基于现在的web应用程序，我们可以使用多种UI元素来和用户交互。使用Web Speech API，我们可以开发更加自然地小巧的web可视化界面。这样我们就能开发更丰富的web应用程序。此外，该API也可以帮助身体或认知障碍的人更好的访问web信息。&lt;br&gt;
    
    </summary>
    
      <category term="翻译文章" scheme="http://yoursite.com/categories/%E7%BF%BB%E8%AF%91%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>图片惰性加载 IntersectionObserver</title>
    <link href="http://yoursite.com/2017/08/28/%E5%9B%BE%E7%89%87%E6%83%B0%E6%80%A7%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2017/08/28/图片惰性加载的实现/</id>
    <published>2017-08-28T12:41:11.000Z</published>
    <updated>2017-09-22T07:14:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于惰性加载"><a href="#关于惰性加载" class="headerlink" title="关于惰性加载"></a>关于惰性加载</h2><p>惰性加载又称为延迟加载、懒加载等，’lazyload’，即在长网页中延迟加载图像。当图片未到达可视区域时，不加载图片。如下图所示：  </p>
<img src="/2017/08/28/图片惰性加载的实现/1.gif" alt="1.gif" title="">  
<p>优点：提升用户的体验，如果图片数量较大，打开页面的时候要将将页面上所有的图片全部获取加载，很可能会出现卡顿现象，影响用户体验。因此，有选择性地请求图片，这样能明显减少了服务器的压力和流量，也能够减小浏览器的负担。<br><a id="more"></a>  </p>
<h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><p>惰性加载可以说在很久之前就已经出现了，实现方案也很简单。  </p>
<ul>
<li>在 HTML 文件中将需要惰性加载的图片的 src 属性置为一个相同的地址（一般设置为一张 loading 图），这样这张图只会加载一次（第二次即会读取缓存），或者干脆置为空（用户体验不好），将真实的图片地址存储在别的属性中（比如 data-src 属性)  </li>
<li>监听事件（比如 scroll 事件），判断需要惰性加载的图片是否已经在可视区域，如果是，则将 src 属性替换成 data-src 属性值  </li>
</ul>
<p>方案中，我们主要实现的功能有：判断图片和视口的位置关系，主要判断函数如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 比较元素位置 d2, 在d1中</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">_compareOffset</span>(<span class="params">d1, d2</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> left = d2.right &gt; d1.left &amp;&amp; d2.left &lt; d1.right;</div><div class="line">    <span class="keyword">let</span> top = d2.bottom &gt; d1.top &amp;&amp; d2.top &lt; d1.bottom;</div><div class="line">    <span class="keyword">return</span> left &amp;&amp; top;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>图片的坐标大小信息我们可以通过 <code>getBoundingClientRect</code> 来获得，浏览器窗口信息则为：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> w = &#123;</div><div class="line">    t = <span class="number">0</span>,</div><div class="line">    l = <span class="number">0</span>,</div><div class="line">    r = l + <span class="built_in">window</span>.innerWidth,</div><div class="line">    b = t + <span class="built_in">window</span>.innerHeight</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>剩下的只要监听 <code>scroll</code> 事件，对所有的 img.lazy-load 元素判断就好了。  </p>
<h2 id="监听-scroll-存在的性能问题"><a href="#监听-scroll-存在的性能问题" class="headerlink" title="监听 scroll 存在的性能问题"></a>监听 scroll 存在的性能问题</h2><p>当我们监听 scroll 事件的时候，页面滚动会导致该事件频繁出发，这对浏览器的性能产生很大的影响。为此我们可以加入函数节流(throttle)或函数去抖(debounce)来处理  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> _throttle = <span class="function">(<span class="params">func, wait, mustRunDelay = <span class="literal">Infinity</span></span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> timeout = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">let</span> start_time;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">let</span> context = <span class="keyword">this</span>,</div><div class="line">            args = <span class="built_in">arguments</span>,</div><div class="line">            curr_time = +<span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">        clearTimeout(timeout);</div><div class="line">        <span class="keyword">if</span>(!start_time) &#123;</div><div class="line">            start_time = curr_time;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(curr_time - start_time &gt;= mustRunDelay) &#123;</div><div class="line">            func.apply(context, args);</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                func.apply(context, args);</div><div class="line">            &#125;, wait);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>wait</code> 即判断的间隔事件，我们通常设置成 100ms 就可以不影响用户的体验。如果你想进一步提升图片加载性能我们也可以指定的将某些图片，base64 后存入 <code>localStorage</code> 中，等以后打开的时候，首先判断 <code>localStorage</code> 中是否有图片缓存，没有则去请求。这样就可以进一步加快图片的载入速度。  </p>
<p>完整的代码，可以查看 <a href="https://github.com/T-phantom/si-img" target="_blank" rel="external">si-img 图片优化组件</a>  </p>
<h2 id="IntersectionObserver-API"><a href="#IntersectionObserver-API" class="headerlink" title="IntersectionObserver API"></a>IntersectionObserver API</h2><p>虽然我们使用了函数节流来降低 scroll 的频率，但是检测函数触发的频率依然很高，这之中的大多数检测都是没有意义的(并没有新的图片进入)。为了更好的解决这类问题，浏览器也提供了 <code>IntersectionObserver</code> API 来帮助我们判断元素是否进入可是区域。</p>
<p>由于可见（visible）的本质是，目标元素与视口产生一个交叉区，所以这个 API 叫做”交叉观察器”。</p>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>使用方式十分简单：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> io = <span class="keyword">new</span> IntersectionObserver(callback, option);</div></pre></td></tr></table></figure>
<p>上面代码中，IntersectionObserver是浏览器原生提供的构造函数，接受两个参数：callback是可见性变化时的回调函数，option是配置对象（该参数可选）。<br>构造函数的返回值是一个观察器实例。实例的observe方法可以指定观察哪个 DOM 节点。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 开始观察</span></div><div class="line">io.observe(<span class="built_in">document</span>.getElementById(<span class="string">'example'</span>));</div><div class="line"></div><div class="line"><span class="comment">// 停止观察</span></div><div class="line">io.unobserve(element);</div><div class="line"></div><div class="line"><span class="comment">// 关闭观察器</span></div><div class="line">io.disconnect();</div></pre></td></tr></table></figure>
<p>上面代码中，observe的参数是一个 DOM 节点对象。如果要观察多个节点，就要多次调用这个方法。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">io.observe(elementA);</div><div class="line">io.observe(elementB);</div></pre></td></tr></table></figure>
<h3 id="callback"><a href="#callback" class="headerlink" title="callback"></a>callback</h3><p>目标元素的可见性变化时，就会调用观察器的回调函数callback。<br>callback一般会触发两次。一次是目标元素刚刚进入视口（开始可见），另一次是完全离开视口（开始不可见）。    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> io = <span class="keyword">new</span> IntersectionObserver(</div><div class="line">  entries =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(entries);</div><div class="line">  &#125;</div><div class="line">);</div></pre></td></tr></table></figure>
<p>callback函数的参数（entries）是一个数组，每个成员都是一个IntersectionObserverEntry对象。如果同时有两个被观察的对象的可见性发生变化，entries数组就会有两个成员。  </p>
<h3 id="IntersectionObserverEntry-对象"><a href="#IntersectionObserverEntry-对象" class="headerlink" title="IntersectionObserverEntry 对象"></a>IntersectionObserverEntry 对象</h3><p>IntersectionObserverEntry对象提供目标元素的信息，一共有六个属性：  </p>
<ul>
<li>time：可见性发生变化的时间ms</li>
<li>target：被观察的目标元素，是一个 DOM 节点对象</li>
<li>rootBounds：根元素的矩形区域的信息，getBoundingClientRect()方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回null</li>
<li>boundingClientRect：目标元素的矩形区域的信息</li>
<li>intersectionRect：目标元素与视口（或根元素）的交叉区域的信息</li>
<li>intersectionRatio：目标元素的可见比例，即intersectionRect占boundingClientRect的比例，完全可见时为1，完全不可见时小于等于0     </li>
</ul>
<h3 id="options-参数"><a href="#options-参数" class="headerlink" title="options 参数"></a>options 参数</h3><p>其中，options 整个参数对象以及它的三个属性都是可选的：</p>
<h4 id="root-属性"><a href="#root-属性" class="headerlink" title="root 属性"></a>root 属性</h4><p>IntersectionObserver API 的适用场景主要是这样的：一个可以滚动的元素，我们叫它根元素，它有很多后代元素，想要做的就是判断它的某个后代元素是否滚动进了自己的可视区域范围。这个 root 参数就是用来指定根元素的，默认值是 null。<br>如果它的值是 null，根元素就不是个真正意义上的元素了，而是这个浏览器窗口了，可以理解成 window。  </p>
<h4 id="threshold-属性"><a href="#threshold-属性" class="headerlink" title="threshold 属性"></a>threshold 属性</h4><p>当目标元素和根元素相交时，用相交的面积除以目标元素的面积会得到一个 0 到 1（0% 到 100%）的数值：<br>IntersectionObserver API 的基本工作原理就是：当目标元素和根元素相交的面积占目标元素面积的百分比到达或跨过某些指定的临界值时就会触发回调函数。threshold 参数就是用来指定那个临界值的，默认值是 0，表示俩元素刚刚挨上就触发回调。可以指定多个临界值，用数组形式，比如 [0, 0.5, 1]，表示在两个矩形开始相交，相交一半，完全相交这三个时刻都要触发一次回调函数。  </p>
<h4 id="rootMagin-属性"><a href="#rootMagin-属性" class="headerlink" title="rootMagin 属性"></a>rootMagin 属性</h4><p>rootMargin 可以给根元素添加一个假想的 margin，从而对真实的根元素区域进行缩放。比如当 root 为 null 时设置 rootMargin: “100px”，实际的根元素矩形四条边都会被放大 100px。</p>
<h2 id="利用-IntersectionObserver-实现高效的图片惰性加载"><a href="#利用-IntersectionObserver-实现高效的图片惰性加载" class="headerlink" title="利用 IntersectionObserver 实现高效的图片惰性加载"></a>利用 IntersectionObserver 实现高效的图片惰性加载</h2><p>首先获取哪儿些图片需要被IntersectionObserver 观测，这里我们认为带有 <code>.lazy-load</code> 类的图片：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取所有要观测的图片</span></div><div class="line"><span class="keyword">const</span> images = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.lazy-load'</span>);</div><div class="line"><span class="keyword">const</span> config = &#123;</div><div class="line">   <span class="comment">// 如果图像在Y轴上的50像素内，则开始下载。</span></div><div class="line">    rootMargin: <span class="string">'50px 0px'</span>,</div><div class="line">    threshold: <span class="number">0.01</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 观察图片</span></div><div class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> IntersectionObserver(onIntersection, config);</div><div class="line">    images.forEach(<span class="function"><span class="params">image</span> =&gt;</span> &#123;</div><div class="line">        observer.observe(image);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"><span class="string">``</span><span class="string">`  </span></div><div class="line"><span class="string">之后我们在 `</span>onIntersection<span class="string">` 中处理图片加载逻辑：  </span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">`</span><span class="string">``</span>javascript    </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onIntersection</span>(<span class="params">entries</span>) </span>&#123;</div><div class="line">    <span class="comment">// 查看所有观察的图片</span></div><div class="line">    entries.forEach(<span class="function"><span class="params">entry</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">if</span> (entry.intersectionRatio &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// 停止观察，并加载图片</span></div><div class="line">            observer.unobserve(entry.target);</div><div class="line">            preloadImage(entry.target);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样重写后的惰性加载插件性能将大大的提升，而且逻辑也变得十分简单。  </p>
<h2 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h2><p>下图为该API的支持情况：<br><img src="/2017/08/28/图片惰性加载的实现/2.png" alt="2.png" title=""><br>很遗憾safari还不支持该属性，你可以利用下面代码来简单实现降级方案：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!(<span class="string">'IntersectionObserver'</span> <span class="keyword">in</span> <span class="built_in">window</span>)) &#123;</div><div class="line">    <span class="comment">// 如果不支持，则立刻加载所有图片</span></div><div class="line">    <span class="built_in">Array</span>.from(images).forEach(<span class="function"><span class="params">image</span> =&gt;</span> preloadImage(image));</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    observer = <span class="keyword">new</span> IntersectionObserver(onIntersection, config);</div><div class="line">    images.forEach(<span class="function"><span class="params">image</span> =&gt;</span> &#123;</div><div class="line">        observer.observe(image);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果，你真的想在不支持的浏览器下体验该属性，你可以下载下面这个 polyfill。<a href="https://github.com/w3c/IntersectionObserver/tree/gh-pages/polyfill" target="_blank" rel="external">w3c/IntersectionObserver</a>  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于惰性加载&quot;&gt;&lt;a href=&quot;#关于惰性加载&quot; class=&quot;headerlink&quot; title=&quot;关于惰性加载&quot;&gt;&lt;/a&gt;关于惰性加载&lt;/h2&gt;&lt;p&gt;惰性加载又称为延迟加载、懒加载等，’lazyload’，即在长网页中延迟加载图像。当图片未到达可视区域时，不加载图片。如下图所示：  &lt;/p&gt;
&lt;img src=&quot;/2017/08/28/图片惰性加载的实现/1.gif&quot; alt=&quot;1.gif&quot; title=&quot;&quot;&gt;  
&lt;p&gt;优点：提升用户的体验，如果图片数量较大，打开页面的时候要将将页面上所有的图片全部获取加载，很可能会出现卡顿现象，影响用户体验。因此，有选择性地请求图片，这样能明显减少了服务器的压力和流量，也能够减小浏览器的负担。&lt;br&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
</feed>

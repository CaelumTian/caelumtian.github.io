<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CaelumTian的博客</title>
  <subtitle>你若盛开，清风自来，心若沉浮 浅笑安然</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-11-21T06:38:53.629Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>CaelumTian</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>单页应用代码分割</title>
    <link href="http://yoursite.com/2018/11/19/%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2/"/>
    <id>http://yoursite.com/2018/11/19/单页应用代码分割/</id>
    <published>2018-11-19T13:52:17.000Z</published>
    <updated>2018-11-21T06:38:53.629Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单页面代码分割"><a href="#单页面代码分割" class="headerlink" title="单页面代码分割"></a>单页面代码分割</h2><p>目前单页应用的 bundle.js 一般都会很大，这样的话会对启动时间造成影响。为此我们需要合理拆分 js 文件，然后在需要使用的时候才动态记在。<br>拆分 js 文件，我们通常会采用手段： </p>
<ul>
<li>基于业务逻辑和依赖库分割</li>
<li>基于路由分割  </li>
<li>基于组件分割  </li>
</ul>
<a id="more"></a>

<p>左图所示是基于路由进行分割，有图为基于组件进行分割。基于路由分割的力度比较大，一个路由里会嵌套很多组件。每个路由 react 组件还是有很多，但并不是每个组件都会被立刻使用。同时，多个路由之间还有可能会产生很多重复的组件代码。这显然不如基于组件进行分割效果较好。  </p>
<h2 id="代码分割案例"><a href="#代码分割案例" class="headerlink" title="代码分割案例"></a>代码分割案例</h2><p>假如，我们有个页面，页面的额外信息 extra 组件是不需要的，只有点击查看额外信息按钮后才会出现。我们对 extra 进行惰性加载。代码如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(prop) &#123;</div><div class="line">        <span class="keyword">super</span>(prop);</div><div class="line">        <span class="keyword">this</span>.state = &#123;</div><div class="line">            showExtra: <span class="literal">false</span>,</div><div class="line">            CExtra: &#123;&#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    handleOpenExtra() &#123;</div><div class="line">        <span class="keyword">import</span>(<span class="string">'./components/extra'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</div><div class="line">            <span class="keyword">this</span>.setState(&#123;</div><div class="line">                showExtra: <span class="literal">true</span>,</div><div class="line">                CExtra: res.default</div><div class="line">            &#125;)</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;React.Fragment&gt;</div><div class="line">                &#123;<span class="keyword">this</span>.state.showExtra ? &lt;this.state.CExtra /&gt; : null&#125;</div><div class="line">                &lt;div&gt;...&lt;/div&gt;</div><div class="line">                &lt;div onClick=&#123;this.handleOpenExtra.bind(this)&#125;&gt;点击查看额外信息&lt;/div&gt;</div><div class="line">            &lt;/React.Fragment&gt;</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">export default App;</div></pre></td></tr></table></figure>
<p>demo 中我们利用了 webpack 分包加载功能，当点击按钮时利用 import 来加载 extra 组件，而不是在开头直接引入。  </p>
<h3 id="动态导入-dynamic-imports"><a href="#动态导入-dynamic-imports" class="headerlink" title="动态导入(dynamic imports)"></a>动态导入(dynamic imports)</h3><p>上述案例，我们借助 import 函数来引入 extra 包。webpack 在打包的时候会自动检测这样的 import 引入的文件，为其单独生成一个打包 js 文件。如图所示：  </p>
  
<p>当我们点击加载按钮后，红线处的 js 包会被异步载入   </p>
 
<p>webpack 实现动态导如的代码如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">__webpack_require__.e = <span class="function"><span class="keyword">function</span> <span class="title">requireEnsure</span>(<span class="params">chunkId</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> promises = [];</div><div class="line">	<span class="comment">// JSONP chunk loading for javascript</span></div><div class="line">	<span class="keyword">var</span> installedChunkData = installedChunks[chunkId];</div><div class="line">	<span class="keyword">if</span>(installedChunkData !== <span class="number">0</span>) &#123; <span class="comment">// 0 means "already installed".</span></div><div class="line">		<span class="comment">// a Promise means "currently loading".</span></div><div class="line">		<span class="keyword">if</span>(installedChunkData) &#123;</div><div class="line">			promises.push(installedChunkData[<span class="number">2</span>]);</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="comment">// 每次需要进行异步加载chunk时，会将这个chunk的加载状态进行初始化为一个数组,并以key/value的形式保存在installedChunks里</span></div><div class="line">			<span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">				installedChunkData = installedChunks[chunkId] = [resolve, reject];</div><div class="line">			&#125;);</div><div class="line">			promises.push(installedChunkData[<span class="number">2</span>] = promise);</div><div class="line">			<span class="comment">// 开始异步 chunk 加载</span></div><div class="line">			<span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>];</div><div class="line">			<span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</div><div class="line">			<span class="keyword">var</span> onScriptComplete;</div><div class="line">			script.charset = <span class="string">'utf-8'</span>;</div><div class="line">			script.timeout = <span class="number">120</span>;</div><div class="line">			<span class="keyword">if</span> (__webpack_require__.nc) &#123;</div><div class="line">				script.setAttribute(<span class="string">"nonce"</span>, __webpack_require__.nc);</div><div class="line">			&#125;</div><div class="line">			script.src = jsonpScriptSrc(chunkId);   <span class="comment">// js 文件名</span></div><div class="line">			onScriptComplete = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;   <span class="comment">// 加载完毕回调</span></div><div class="line">				<span class="comment">// avoid mem leaks in IE.</span></div><div class="line">				script.onerror = script.onload = <span class="literal">null</span>;</div><div class="line">				clearTimeout(timeout);</div><div class="line">				<span class="keyword">var</span> chunk = installedChunks[chunkId];</div><div class="line">				<span class="keyword">if</span>(chunk !== <span class="number">0</span>) &#123;</div><div class="line">					<span class="keyword">if</span>(chunk) &#123;</div><div class="line">						<span class="keyword">var</span> errorType = event &amp;&amp; (event.type === <span class="string">'load'</span> ? <span class="string">'missing'</span> : event.type);</div><div class="line">						<span class="keyword">var</span> realSrc = event &amp;&amp; event.target &amp;&amp; event.target.src;</div><div class="line">						<span class="keyword">var</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Loading chunk '</span> + chunkId + <span class="string">' failed.\n('</span> + errorType + <span class="string">': '</span> + realSrc + <span class="string">')'</span>);</div><div class="line">						error.type = errorType;</div><div class="line">						error.request = realSrc;</div><div class="line">						chunk[<span class="number">1</span>](error);</div><div class="line">					&#125;</div><div class="line">					installedChunks[chunkId] = <span class="literal">undefined</span>;</div><div class="line">				&#125;</div><div class="line">			&#125;;</div><div class="line">			<span class="keyword">var</span> timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">				onScriptComplete(&#123; <span class="attr">type</span>: <span class="string">'timeout'</span>, <span class="attr">target</span>: script &#125;);</div><div class="line">			&#125;, <span class="number">120000</span>);</div><div class="line">			script.onerror = script.onload = onScriptComplete;</div><div class="line">			head.appendChild(script);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="built_in">Promise</span>.all(promises);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>注意，使用 import 导入这种形式的话，我们需要使用 dynamic-import 包：  </p>
<blockquote>
<p>npm install –save-dev @babel/plugin-syntax-dynamic-import  </p>
</blockquote>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"plugins"</span>: [<span class="string">"@babel/plugin-syntax-dynamic-import"</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或者你也可以使用 webpack 提供的 require.ensure 来代替。</p>
<h2 id="react-loadable"><a href="#react-loadable" class="headerlink" title="react-loadable"></a>react-loadable</h2><p>上述代码，我们粗略的实现了一个分包加载的demo，业务上我们还要有很多问题来处理。比如：import 失败怎么办？加载前需要 loading 占位怎么做？服务端渲染怎么做？<br>这里介绍一个库 react-loadable。他会把我们要异步加载的组件封装成一个高阶组件供我们使用<br>例如，我们异步加载 extra 组件，并且引入一个 loading 作为加载占位，代码如下： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> LoadableComponent = Loadable(&#123;</div><div class="line">     loader: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./components/extra'</span>),</div><div class="line">     loading: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;div&gt;组件加载中&lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">        );</span></div><div class="line"><span class="regexp">     &#125;</span></div><div class="line"><span class="regexp">&#125;);</span></div></pre></td></tr></table></figure>
<p>使用的时候我们直接在恰当的时机渲染 LoadableComponent 组件即可。<br>除此之外，react-loadable 还提供了预加载，服务端渲染等功能。这里就不详细介绍使用了，主要我们看一下源码实现的过程。</p>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><h4 id="函数入口"><a href="#函数入口" class="headerlink" title="函数入口"></a>函数入口</h4><p><code>react-loadable</code> 本质上就是一个高阶组件封装的过程。代码入口如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Loadable</span>(<span class="params">opts</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> createLoadableComponent(load, opts);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Loadable 接受我们传入的参数 opts, 再调用了createLoadableComponent函数，传入了 <code>load</code> 函数和 opts。 </p>
<h4 id="load-函数"><a href="#load-函数" class="headerlink" title="load 函数"></a>load 函数</h4><p>这里我们先来看一下 <code>load</code> 函数：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params">loader</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> promise = loader();</div><div class="line">    <span class="keyword">let</span> state = &#123;</div><div class="line">        loading: <span class="literal">true</span>,</div><div class="line">        loaded: <span class="literal">null</span>,    <span class="comment">// 组件实例</span></div><div class="line">        error: <span class="literal">null</span></div><div class="line">    &#125;;</div><div class="line">    state.promise = promise</div><div class="line">        .then(<span class="function"><span class="params">loaded</span> =&gt;</span> &#123;</div><div class="line">            state.loading = <span class="literal">false</span>;</div><div class="line">            state.loaded = loaded;</div><div class="line">            <span class="keyword">return</span> loaded;</div><div class="line">        &#125;)</div><div class="line">        .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</div><div class="line">            state.loading = <span class="literal">false</span>;</div><div class="line">            state.error = err;</div><div class="line">            <span class="keyword">throw</span> err;</div><div class="line">        &#125;);</div><div class="line">    <span class="keyword">return</span> state;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>load</code> 函数里初始化了一个state对象，执行 loader 方法(即我们传入的 loader 参数 (import(…))) 来加载异步组件。之后将返回结果保存在 state 的 loaded 属性中，加载状态保存在其他属性上。返回这个 state 供后续使用。 </p>
<h4 id="createLoadableComponent"><a href="#createLoadableComponent" class="headerlink" title="createLoadableComponent"></a>createLoadableComponent</h4><p>接下来，开始分析整个代码的主体部分 <code>createLoadableComponent</code> 函数。其作用就是包装加载后的异步组件，返回一个高阶组件供我们使用。代码如下：</p>

<p>首先检测必须含有 loading 组件，给参数添加默认值等。然后初始化一个 init 方法，用于执行上文的 <code>load</code> 函数以加载异步组件，并记录状态给 res 变量。之后就是返回 LoadableComponent 组件的过程。<br>在 LoadableComponent 中，发生如下情况：</p>
<ol>
<li><code>constructor</code> 阶段：调用 init 方法，保存状态到 state 上</li>
<li><code>componentWillMount</code> 阶段：<ul>
<li>设置 this._mounted 状态默认为 ture 表示加载完成</li>
<li>进行一些判断，如果 res.loading 为 false，说明之前的 init 执行出错，直接return</li>
<li>如果opts.delay 和 opts.timeout有值，且为number属性的话，就加个定时器用来延迟显示 loading 组件（避免闪烁）</li>
<li>声明 update 函数，用来根据异步组件加载的结果更新 state 值</li>
<li>如果 this.state.loading 或者 this.state.error 为 true，就是整体状态是正在加载或者出错了，就用 React.createElement 生成出loading的过渡组件</li>
<li>如果 this.state.loaded 有值了，说明传入的loader的promise异步操作执行完成，就开始渲染真正的组件，调用opts.render方法</li>
</ul>
</li>
</ol>
<p>大致过程就是这样，不贴代码了。还有一些细节，对 webpack 等处理，preload 静态方法等，也就一两句话，看看就知道了。</p>
<h2 id="异步加载时机"><a href="#异步加载时机" class="headerlink" title="异步加载时机"></a>异步加载时机</h2><p>想这么一个问题，如果 extra 包很大，我们点击打开 open 按钮后，要花很长一段时间才能看到组件内容。这样同样也不是什么好的体验。甚至，如果我们加载的包里面逻辑复杂，js 运行时间过长会阻塞掉用户的交互。这样要如何处理呢？</p>
<h3 id="Idle-Until-Urgent-（空闲等待-amp-紧急优先）"><a href="#Idle-Until-Urgent-（空闲等待-amp-紧急优先）" class="headerlink" title="Idle Until Urgent （空闲等待 &amp; 紧急优先）"></a>Idle Until Urgent （空闲等待 &amp; 紧急优先）</h3><p>点击 extra 肯定是延后操作，我们希望在主要任务都完成后，如果浏览器有空闲时间就来预加载组件(空闲等待)。如果我们点击打开按钮，这时候组件还没有加载完毕，那么我们就立刻加载组件(紧急优先)。<br>实现该操作，我们可以借助 requestIdleCallback 函数。改造代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"></div><div class="line"><span class="keyword">let</span> rIc = <span class="built_in">window</span>.requestIdleCallback;</div><div class="line"><span class="keyword">let</span> cIc = <span class="built_in">window</span>.cancelIdleCallback;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(prop) &#123;</div><div class="line">        <span class="keyword">super</span>(prop);</div><div class="line">        <span class="keyword">this</span>.state = &#123;</div><div class="line">            showExtra: <span class="literal">false</span></div><div class="line">        &#125;;</div><div class="line">        <span class="comment">// 开始空闲加载</span></div><div class="line">        <span class="keyword">this</span>.idleHandle = rIC(<span class="keyword">this</span>.loadComponent.bind(<span class="keyword">this</span>));</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 打开 extra 列表</span></div><div class="line">    <span class="keyword">async</span> handleOpenExtra() &#123;</div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.CExtra) &#123;</div><div class="line">            <span class="comment">// 如果没有加载好，则取消空闲加载，直接进入加载阶段</span></div><div class="line">            cIC(<span class="keyword">this</span>.idleHandle);</div><div class="line">            <span class="keyword">await</span> <span class="keyword">this</span>.loadComponent();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.setState(&#123;</div><div class="line">            showExtra: <span class="literal">true</span>;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 异步加载内容</span></div><div class="line">    <span class="keyword">async</span> loadComponent() &#123;</div><div class="line">        <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">'./components/extra'</span>).then();</div><div class="line">        <span class="keyword">this</span>.CExtra = result;</div><div class="line">    &#125;</div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;React.Fragment&gt;</div><div class="line">                &#123;<span class="keyword">this</span>.state.showExtra ? &lt;this.CExtra.default /&gt; : null&#125;</div><div class="line">                &lt;div&gt;...&lt;/div&gt;</div><div class="line">                &lt;div onClick=&#123;this.handleOpenExtra.bind(this)&#125;&gt;点击查看额外信息&lt;/div&gt;</div><div class="line">            &lt;/React.Fragment&gt;</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">export default App;</div></pre></td></tr></table></figure>
<p>当然，你也可以用 react-loadable 来实现该例子，简要改动如下： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> LoadableMyComponent = Loadable(&#123;</div><div class="line">    loader: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./components/extra'</span>),</div><div class="line">    ...</div><div class="line">&#125;)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="comment">//...</span></div><div class="line">        <span class="keyword">this</span>.idleHandle = rIC(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">            LoadableMyComponent.preload()</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种空闲执行的方案，同样使用于执行那些不是很紧急但是耗时很长的函数。例如处理大量数据集，localStorage 中获取数据等等。合理利用 requestIdleCallback 可以减少网页的阻塞，提高效果。</p>
<h4 id="空闲任务队列"><a href="#空闲任务队列" class="headerlink" title="空闲任务队列"></a>空闲任务队列</h4><p>上面技术适用于可以通过单个函数计算出来的属性，但在某些情况下，逻辑可能无法写到单个函数里，或者，即使技术上可行，您仍然希望将其拆分为更小的一些函数，以免其长时间阻塞主线程。 这里提供一个 <a href="https://github.com/GoogleChromeLabs/idlize" target="_blank" rel="external">IdleQueue</a> 你可以在里面找到利用 requestIdleCallback 的姿势。</p>
<h2 id="mobx-是否需要拆分"><a href="#mobx-是否需要拆分" class="headerlink" title="mobx 是否需要拆分"></a>mobx 是否需要拆分</h2><p>通常我们在写业务的时候，会把 store 写在 <code>&lt;Provider&gt;</code> 上直直接注入。那我们需要对 mobx 的 store 也异步加载呢？理论上没有这个必要，因为 store 里面的内容确实一般不会很大并不是造成包体积过大的原因。优化效果不太明显。<br>当然如果非要异步加载的话，我这里有个想法，我们将 store 和 action 拆分出来。store 里面只包含数据：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexStore</span> </span>&#123;</div><div class="line">    @observable list = [];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtraStore</span> </span>&#123;</div><div class="line">    @observable extra = [];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>store 依然在全局在 Provider 注入，每个业务的 action 单独抽离成一个文件： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexAction</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(store) &#123;</div><div class="line">        <span class="keyword">this</span>.store = store;</div><div class="line">    &#125;</div><div class="line">    @action getList() &#123;</div><div class="line">        <span class="keyword">this</span>.store.list = [</div><div class="line">            <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span></div><div class="line">        ];</div><div class="line">    &#125;</div><div class="line">    @action addItem() &#123;</div><div class="line">        <span class="keyword">this</span>.store.list.push(<span class="keyword">this</span>.list.length + <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>action 们单独在一个全局变量中维护，需要异步加载的时候如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// actions 为一个全局变量</span></div><div class="line"><span class="keyword">import</span>(<span class="string">'../../actions/extra'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> ExtraAction = res &amp;&amp; res.__esModule ? res.default : res;</div><div class="line">    actions.extra = <span class="keyword">new</span> ExtraAction(self.props.rootStore.extraStore);</div><div class="line">    <span class="comment">// ....</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://webpack.docschina.org/guides/code-splitting/#%E5%8A%A8%E6%80%81%E5%AF%BC%E5%85%A5-dynamic-imports-" target="_blank" rel="external">webpack 动态导入</a></li>
<li><a href="https://juejin.im/post/5bdec712e51d4505525b0fba" target="_blank" rel="external">[译] Google 工程师提升网页性能的新策略：空闲执行，紧急优先</a></li>
<li><a href="https://book.douban.com/subject/30290509/" target="_blank" rel="external">React状态管理与同构实战</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;单页面代码分割&quot;&gt;&lt;a href=&quot;#单页面代码分割&quot; class=&quot;headerlink&quot; title=&quot;单页面代码分割&quot;&gt;&lt;/a&gt;单页面代码分割&lt;/h2&gt;&lt;p&gt;目前单页应用的 bundle.js 一般都会很大，这样的话会对启动时间造成影响。为此我们需要合理拆分 js 文件，然后在需要使用的时候才动态记在。&lt;br&gt;拆分 js 文件，我们通常会采用手段： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于业务逻辑和依赖库分割&lt;/li&gt;
&lt;li&gt;基于路由分割  &lt;/li&gt;
&lt;li&gt;基于组件分割  &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>从 javascript 角度看 Dart【三】</title>
    <link href="http://yoursite.com/2018/09/19/%E4%BB%8Ejs%E8%A7%92%E5%BA%A6%E7%9C%8Bdart3/"/>
    <id>http://yoursite.com/2018/09/19/从js角度看dart3/</id>
    <published>2018-09-19T06:06:54.000Z</published>
    <updated>2018-09-19T07:55:43.953Z</updated>
    
    <content type="html"><![CDATA[<p>前两篇文章，已经介绍了 Dart 的基础语法部分，并适当的结合 js 来进行对比。总的来看，Dart 设计的还是和 JS 很像的。本文，是最后一篇介绍 Dart 语言的。本文将着重介绍一下，Dart 的一些基础库。  </p>
<a id="more"></a>
<h2 id="库"><a href="#库" class="headerlink" title="库"></a>库</h2><p>使用import 和 library 机制可以方便的创建一个模块或分享代码。一个Dart 库不仅能够提供相应的API，还可以包含一些以_开头的变量用于在库内部使用。</p>
<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>用 <code>import</code> 来引入一个定义好的库。例如：  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">'dart:html'</span>;</div></pre></td></tr></table></figure>
<p>在import语句后面需要接上库文件的 URI。</p>
<ul>
<li>对Dart 语言提供的库文件以dart:xx 格式</li>
<li>其它第三方的库文件使用package:xx格式</li>
</ul>
<h4 id="设置库的前缀"><a href="#设置库的前缀" class="headerlink" title="设置库的前缀"></a>设置库的前缀</h4><p>如果两个库具有同样的标识符，则会出现命名冲突，可以用库前缀解决命名冲突。  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">'package:lib1/lib1.dart'</span>;</div><div class="line"><span class="keyword">import</span> <span class="string">'package:lib2/lib2.dart'</span> <span class="keyword">as</span> lib2;</div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">var</span> element1 = <span class="keyword">new</span> <span class="built_in">Element</span>();      <span class="comment">// 用 lib1 的 Element</span></div><div class="line"><span class="keyword">var</span> element2 = <span class="keyword">new</span> lib2.<span class="built_in">Element</span>(); <span class="comment">// 用 lib2 的 Element</span></div></pre></td></tr></table></figure>
<h4 id="只导入库的一部分"><a href="#只导入库的一部分" class="headerlink" title="只导入库的一部分"></a>只导入库的一部分</h4><p>如果你只使用库的一部分，可以导入只使用的功能 <code>show</code>, <code>hide</code>  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">'package:lib1/lib1.dart'</span> show foo; <span class="comment">// 仅导入 foo</span></div><div class="line"><span class="keyword">import</span> <span class="string">'package:lib2/lib2.dart'</span> hide foo; <span class="comment">// 除了 foo 外都导出</span></div></pre></td></tr></table></figure>
<h4 id="延迟加载库"><a href="#延迟加载库" class="headerlink" title="延迟加载库"></a>延迟加载库</h4><p>延迟加载机制，可以在需要使用的时候再加载库。关键字 <code>deferred as</code>  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">'package:deferred/hello.dart'</span> deferred <span class="keyword">as</span> hello;</div></pre></td></tr></table></figure>
<p>然后在需要使用的时候调用loadLibrary()方法。  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hello.loadLibrary();</div></pre></td></tr></table></figure>
<p>可以在代码中多次调用loadLibrary()方法。但是实际上它只会被执行一次。</p>
<h3 id="实现一个库"><a href="#实现一个库" class="headerlink" title="实现一个库"></a>实现一个库</h3><p>使用 <code>library</code> 加上一个标示符定义当前库的名字:  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span> point; <span class="comment">// 定义这个库的名字是 point</span></div></pre></td></tr></table></figure>
<h4 id="part-amp-part-of"><a href="#part-amp-part-of" class="headerlink" title="part &amp; part of"></a>part &amp; part of</h4><p>如果一个库的所有代码都写在一个文件中，会导致文件太大不好维护。Dart 允许你把代码写在多个文件中，并使用类似 include 的机制把多个文件包含到库的主文件中。库的主文件就是定义 library 语句所在的文件，在这个文件中可以使用 part 语句包含其它文件。part 语句的语法是 part 加上字符串形式的 fileUri 。与 part 语句相对应的是 part of 语句，需要在被包含的文件的顶部使用 part of 语句声明这个文件属于哪个库。  </p>
<p>library 语句所在的主文件中可以使用 import 和 part 语句，但 part of 所在的实现文件中不能使用任何 import、library 和 part 语句。库使用的所有 import 和 part 语句都必需放在主文件中声明。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 主文件 定义一个 math 库。它由 base，random 两部分组成</span></div><div class="line"><span class="keyword">library</span> math;</div><div class="line"><span class="keyword">part</span> <span class="string">'base.dart'</span>;</div><div class="line"><span class="keyword">part</span> <span class="string">'random.dart'</span>;</div></pre></td></tr></table></figure>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在 base.dart 文件的开头</span></div><div class="line"><span class="keyword">part</span> of math</div></pre></td></tr></table></figure>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在 random.dart 文件的开头</span></div><div class="line"><span class="keyword">part</span> of math;</div></pre></td></tr></table></figure>
<h4 id="export"><a href="#export" class="headerlink" title="export"></a>export</h4><p>你可以使用 export 语句重新导出库，比如：把多个较小的库组合为一个较大的库或者重新导出库的一部分作为一个新的库。既可以导出库的全部，也可以导出库的一部分（使用 show 和 hide）。</p>
<h2 id="dart-async-异步编程"><a href="#dart-async-异步编程" class="headerlink" title="dart:async - 异步编程"></a>dart:async - 异步编程</h2><h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>Future 通常座位异步函数得返回值出现，一个 Future 对象保证在未来的某个时间返回一个结果， 当一个 future 完成的时候，返回的值就可以使用了。这个东西，类似于 js 中的 Promise。利用 Dart 异步读取文件如下：  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">File f = <span class="keyword">new</span> File(<span class="string">"..."</span>);</div><div class="line">f.readAsString().then((<span class="built_in">String</span> str) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;).catchError((e) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>对比一下 js 的 Promise  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">path</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">        fs.readFile(path, (err, data) =&gt; &#123;</div><div class="line">            <span class="keyword">if</span>(err) &#123;</div><div class="line">                reject(err);</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                resolve(err);</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">readFile(<span class="string">'...'</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>可以看到，Future 和 Promise 本质是一个概念的。<br>使用 Future.wait() 静态函数来管理多个 Future 并等待所有 Future 一起完成。这一点类似 Promis.all。 </p>
<h3 id="async-amp-await"><a href="#async-amp-await" class="headerlink" title="async &amp; await"></a>async &amp; await</h3><p>和 js 一样， Dart 中 async 与 await 都是用来生命异步功能的，且 Dart 和 js 中关于这部分的用法几乎一样。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> readAllFile() <span class="keyword">async</span> &#123;</div><div class="line">    File f1 = <span class="keyword">new</span> File(<span class="string">"..."</span>);</div><div class="line">    File f2 = <span class="keyword">new</span> File(<span class="string">"..."</span>);</div><div class="line">    <span class="built_in">String</span> str1 = <span class="keyword">await</span> f1.readAsString();</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="built_in">String</span> str2 = <span class="keyword">await</span> f2.readAsString();</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line">readAllFile();</div></pre></td></tr></table></figure>
<h2 id="dart-convert-编解码"><a href="#dart-convert-编解码" class="headerlink" title="dart:convert 编解码"></a>dart:convert 编解码</h2><p>dart:convert 库 提供了 JSON 和 UTF-8 编码的转换器，还支持创建自定义转换器。 JSON 是一个用来表达结构化对象和集合的文本格式。 UTF-8 是一个常用的 Unicode 字符编码。<br>web 应用和命令行应用都可以使用 dart:convert 库。 import dart:convert 即可使用。</p>
<ul>
<li>编解码JSON：JSON.decode(), JSON.encode()</li>
<li>编解码UTF-8： UTF8.decode(),  UTF8.encode() </li>
</ul>
<p>其他的还有类似操作 dom 的 <code>dart:html</code> 库，命令行应用的 I/O 操作 <code>dart:io</code>，数学库 <code>dart:math</code> 等。就不多介绍了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两篇文章，已经介绍了 Dart 的基础语法部分，并适当的结合 js 来进行对比。总的来看，Dart 设计的还是和 JS 很像的。本文，是最后一篇介绍 Dart 语言的。本文将着重介绍一下，Dart 的一些基础库。  &lt;/p&gt;
    
    </summary>
    
      <category term="Flutter" scheme="http://yoursite.com/categories/Flutter/"/>
    
    
      <category term="Dart 语言" scheme="http://yoursite.com/tags/Dart-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="移动开发" scheme="http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>从 javascript 角度看 Dart【二】</title>
    <link href="http://yoursite.com/2018/09/13/%E4%BB%8Ejs%E8%A7%92%E5%BA%A6%E7%9C%8Bdart2/"/>
    <id>http://yoursite.com/2018/09/13/从js角度看dart2/</id>
    <published>2018-09-13T03:12:32.000Z</published>
    <updated>2018-09-17T11:19:04.349Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章，主要介绍了 Dart 的基本语法（数据类型，函数等），并与 js 进行了简单的对比，方便大家从 js 的角度来快速理解 Dart。本文主要介绍 Dart 中类的使用，总的来看差别不大，在构造函数上我们需要格外注意即可。还有几个 Dart 特有的内容也简单介绍下。    </p>
<a id="more"></a> 
<h2 id="新的运算符"><a href="#新的运算符" class="headerlink" title="新的运算符"></a>新的运算符</h2><p>在 Dart 中多出了一个类型测试操作符，具体如下：  </p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>类型转换</th>
</tr>
</thead>
<tbody>
<tr>
<td>as</td>
<td>类型转换</td>
</tr>
<tr>
<td>is</td>
<td>如果 对象是该类型 则返回 true</td>
</tr>
<tr>
<td>is!</td>
<td>如果 对象是该类型 则返回 false</td>
</tr>
</tbody>
</table>
<p>如果obj 实现了T 所定义的借口，那么obj is T 将返回 true。比如， obj is Object 必然返回 true。使用as 操作符可以把一个对象转换为特定类型。一般来说，如果在is 测试之后还有一些关于对象的表达式。 </p>
<h2 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h2><p>首先我们看下 js 简单声明一个类：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> id = <span class="string">"Point Map"</span>;</div><div class="line">	_prop = <span class="string">"prototype"</span>;</div><div class="line">	<span class="keyword">constructor</span>(x, y) &#123;</div><div class="line">    	<span class="keyword">this</span>.x = x;</div><div class="line">      	<span class="keyword">this</span>.y = y;</div><div class="line">    &#125;;</div><div class="line">	get prop() &#123;</div><div class="line">    	<span class="keyword">return</span> <span class="keyword">this</span>._prop;</div><div class="line">    &#125;</div><div class="line">    set prop(prop) &#123;</div><div class="line">    	<span class="keyword">this</span>._prop = prop + <span class="string">"test"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而用 Dart 翻译上面的 js 代码为：  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="built_in">double</span> y;</div><div class="line">    <span class="built_in">double</span> x;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">String</span> id = <span class="string">"Point Map"</span>;</div><div class="line">    <span class="built_in">String</span> _prop = <span class="string">"prototype"</span>;</div><div class="line">    Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</div><div class="line">    <span class="built_in">String</span> <span class="keyword">get</span> prop =&gt; <span class="keyword">this</span>._prop + <span class="string">"test"</span>;</div><div class="line">    <span class="keyword">void</span> <span class="keyword">set</span> prop(<span class="built_in">String</span> prop) =&gt; <span class="keyword">this</span>._prop = prop;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>Dart 的构造函数的名字和类名一样，其中 this 关键字引用当前实例。和 js 不同的是，Dart 提供了一个语法糖来方便我们赋值：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  num x;</div><div class="line">  num y;</div><div class="line">  <span class="comment">// 在构造函数体执行之前设置实例变量的语法糖</span></div><div class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="构造函数规则"><a href="#构造函数规则" class="headerlink" title="构造函数规则"></a>构造函数规则</h4><p>这一部分，完全和 js 的规则不一样， Dart 对构造函数有如下限制：</p>
<h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4><p>如果没有定义构造函数，则会生成一个默认构造函数。 默认构造函数没有参数，并调用没有参数的 superclass（父类） 构造函数。</p>
<h4 id="命名构造函数"><a href="#命名构造函数" class="headerlink" title="命名构造函数"></a>命名构造函数</h4><p>对于 Dart 语言，同样不支持函数重载。那么如果我想要我的类有多个构造方法该如何呢？Dart 使用命名构造来提供多个构造函数：  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="built_in">num</span> x;</div><div class="line">    <span class="built_in">num</span> y;</div><div class="line">    Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</div><div class="line">    <span class="comment">// 命名构造函数</span></div><div class="line">    Point.fromJson(<span class="built_in">Map</span> json) &#123;</div><div class="line">        x = json[<span class="string">'x'</span>];</div><div class="line">        y = json[<span class="string">'y'</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Point p = <span class="keyword">new</span> Point.fromJson(&#123;&#125;);</div></pre></td></tr></table></figure>
<h4 id="构造函数不支持继承"><a href="#构造函数不支持继承" class="headerlink" title="构造函数不支持继承"></a>构造函数不支持继承</h4><p>任何类型的构造函数都不支持继承。 如果你想让子类也能用父类的构造函数，则你必需在子类中定义并实现该构造函数。默认情况下，子类的构造函数，会调用父类无名无参数的默认构造函数。但是大多数情况下，我们的父类肯定有自己实现的构造函数。这样父类就不会有默认构造函数了，因此我们必须为子类的构造函数手工调用一个父类的构造函数。在冒号 (:) 后面和构造函数体之前指定要调用的父类构造函数。  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="built_in">double</span> x;</div><div class="line">    <span class="built_in">double</span> y;</div><div class="line">    Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</div><div class="line">    Point.fromJson(<span class="built_in">Map</span> data) &#123;</div><div class="line">        <span class="keyword">this</span>.x = data[<span class="string">'x'</span>];</div><div class="line">        <span class="keyword">this</span>.y = data[<span class="string">'y'</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3D</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="built_in">double</span> z;</div><div class="line">    Point3D(x, y, <span class="keyword">this</span>.z): <span class="keyword">super</span>(x, y);</div><div class="line">    Point3D.fromJson(<span class="built_in">Map</span> data): <span class="keyword">super</span>.fromJson(data) &#123;</div><div class="line">        <span class="comment">// 这里如果 this.z = data.z 就会报错</span></div><div class="line">        <span class="keyword">this</span>.z = data[<span class="string">"z"</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="常量构造函数"><a href="#常量构造函数" class="headerlink" title="常量构造函数"></a>常量构造函数</h4><p>如果你的类生成从来不改变的对象，则可以把这些对象定义为编译期常量。 用一个 const 构造函数并把实例变量设置为 final 来实现该功能。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImmutablePoint</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="built_in">num</span> x;</div><div class="line">    <span class="keyword">final</span> <span class="built_in">num</span> y;</div><div class="line">    <span class="keyword">const</span> ImmutablePoint(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ImmutablePoint origin = <span class="keyword">const</span> ImmutablePoint(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="工厂构造函数"><a href="#工厂构造函数" class="headerlink" title="工厂构造函数"></a>工厂构造函数</h4><p>如果一个构造函数并不总是创建一个新的对象，则可以用 factory 关键字来实现构造函数。 例如，一个工厂构造函数可以从缓存中返回一个实例，也可以返回一个子类型的实例。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="built_in">String</span> name;</div><div class="line">    <span class="built_in">bool</span> mute = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">// _cache is library-private, thanks to the _ in front of its name.</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Logger&gt; _cache = &lt;<span class="built_in">String</span>, Logger&gt;&#123;&#125;;</div><div class="line">  </div><div class="line">    <span class="keyword">factory</span> Logger(<span class="built_in">String</span> name) &#123;</div><div class="line">        <span class="keyword">if</span> (_cache.containsKey(name)) &#123;</div><div class="line">            <span class="keyword">return</span> _cache[name];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">final</span> logger = <span class="keyword">new</span> Logger._internal(name);</div><div class="line">            _cache[name] = logger;</div><div class="line">            <span class="keyword">return</span> logger;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    Logger._internal(<span class="keyword">this</span>.name);</div><div class="line">  </div><div class="line">    <span class="keyword">void</span> log(<span class="built_in">String</span> msg) &#123;</div><div class="line">        <span class="keyword">if</span> (!mute) &#123;</div><div class="line">            <span class="built_in">print</span>(msg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>工厂构造函数无法访问 this</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>Dart 为我们提供了 abstract 抽象类  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 该类为 abstract 的，所以无法实例化</span></div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractContainer</span> </span>&#123;</div><div class="line">    <span class="comment">// ...Define constructors, fields, methods...</span></div><div class="line">    <span class="keyword">void</span> updateChildren(); <span class="comment">// 抽象函数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="隐式接口"><a href="#隐式接口" class="headerlink" title="隐式接口"></a>隐式接口</h3><p>每个类都隐式的定义了一个包含所有实例变量和所实现所有接口的接口。 如果你想创建一个类 A 支持 类 B 的 API，但是又不想继承类 B 的实现，则类 A 可以实现 类 B 的隐式接口。<br>类通过 implements 语句来定义其实现的其他类的接口， 并实现需要的 API。 例如：  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 一个  person 类， 隐式接口包含  greet().</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> _name;          <span class="comment">// 该变量在隐式接口中，但是是库返回可见的</span></div><div class="line">    Person(<span class="keyword">this</span>._name);   <span class="comment">// 这是个构造函数，不在隐式接口中</span></div><div class="line">    <span class="built_in">String</span> greet(who) =&gt; <span class="string">'Hello, $who. I am $_name.'</span>; <span class="comment">// 在隐式接口中</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 实现 Person 的隐式接口。</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Imposter</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> _name = <span class="string">""</span>;      <span class="comment">// We have to define this, but we don't use it.</span></div><div class="line">    <span class="built_in">String</span> greet(who) =&gt; <span class="string">'Hi $who. Do you know who I am?'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>关键字 <code>extends</code> 和 js 继承没有太大区别，唯一需要注意的就是构造函数，之前已经说过了。另外在 Dart 中提供了注解功能。我们可以用 @override 来表明正在重写的函数或者变量。这一点有点类似 java。  </p>
<h3 id="类（静态）变量和函数"><a href="#类（静态）变量和函数" class="headerlink" title="类（静态）变量和函数"></a>类（静态）变量和函数</h3><p>关键字 <code>static</code> 和 js 没有太大区别。</p>
<h3 id="Typedefs"><a href="#Typedefs" class="headerlink" title="Typedefs"></a>Typedefs</h3><p>在 js 里面，我们很容易的就可以将函数作为参数进行传递。在 Dart 中我们也可以像 js 一样方便的传递函数。但是这样，有时候我们需要指明函数的类型，比如有多少个参数啊，返回值之类的，从而方便类型检查。<br>在 Dart 中函数也是对象。我们可以用 <code>typedef</code> 来定义一个名称来指明函数名字, 并且定义参数和返回值。  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">int</span> CalFunc(<span class="built_in">int</span> num1, <span class="built_in">int</span> num2);</div><div class="line">main() &#123;</div><div class="line">    <span class="built_in">int</span> num1 = <span class="number">1</span>;</div><div class="line">    <span class="built_in">int</span> num2 = <span class="number">2</span>;</div><div class="line">    <span class="built_in">int</span> calculate(CalFunc func) &#123;</div><div class="line">        <span class="keyword">return</span> func(num1, num2);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="built_in">int</span> result = calculate((<span class="built_in">int</span> num1, <span class="built_in">int</span> num2) &#123;</div><div class="line">        <span class="keyword">return</span> num1 - num2;</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">print</span>(result);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>（思考了下，java 能不能将函数作为参数直接传递？不能直接简单的传递，我们可以利用 interface 继承的方式；在 java8 中我们还可以用 lambada 表达式。）   </p>
<h3 id="Metadata（元数据）"><a href="#Metadata（元数据）" class="headerlink" title="Metadata（元数据）"></a>Metadata（元数据）</h3><p>用元数据给你的代码提供额外的信息。元数据注解 使用 @ 字符开头，后面跟着一个引用合作 编译期常量（例如 deprecated）或者调用一个 常量构造函数。<br>下面三个注解，所有的 Dart 代码都可以使用： @deprecated、 @override、 和 @proxy。<br>Metadata 可以出现在 library、 class、 typedef、 type parameter、 constructor、factory、 function、 field、 parameter、或者 variable declaration 、import 或者 export 之前。 以后，可以通过反射来获取元数据信息。 </p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型，由于 js 是动态类型的语言，因此没有泛型的概念。Dart 中我们可以使用泛型，也可以不适用。个人倾向于应该主动使用泛型，来帮助我们更好的表达意图。也方便 IDE 对代码的错误的检查，提高效率。具体内容比较杂，就不对比了。  </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Dart 语言的基础到这里就介绍的差不多了，总的来看还算简单。我觉得从 js 的角度 和 java 的角度综合分析下，还是蛮好玩的。下篇文章主要介绍下 Dart 常用库。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文章，主要介绍了 Dart 的基本语法（数据类型，函数等），并与 js 进行了简单的对比，方便大家从 js 的角度来快速理解 Dart。本文主要介绍 Dart 中类的使用，总的来看差别不大，在构造函数上我们需要格外注意即可。还有几个 Dart 特有的内容也简单介绍下。    &lt;/p&gt;
    
    </summary>
    
      <category term="Flutter" scheme="http://yoursite.com/categories/Flutter/"/>
    
    
      <category term="Dart 语言" scheme="http://yoursite.com/tags/Dart-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="移动开发" scheme="http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>从 javascript 角度看 Dart【一】</title>
    <link href="http://yoursite.com/2018/09/10/%E4%BB%8Ejs%E8%A7%92%E5%BA%A6%E7%9C%8Bdart/"/>
    <id>http://yoursite.com/2018/09/10/从js角度看dart/</id>
    <published>2018-09-10T04:09:50.000Z</published>
    <updated>2018-09-17T07:34:36.805Z</updated>
    
    <content type="html"><![CDATA[<p>最近准备尝试下谷歌的 Flutter 开发，因此需要学习一下 dart 语言。本文主要将 javascript 和 dart 进行对比，从而帮助我们快速入门 dart 语言。  </p>
<h2 id="Dart-简介"><a href="#Dart-简介" class="headerlink" title="Dart 简介"></a>Dart 简介</h2><blockquote>
<p>Dart是谷歌开发的计算机编程语言，后来被Ecma (ECMA-408)认定为标准。它被用于web、服务器、移动应用和物联网等领域的开发。它是宽松开源许可证（修改的BSD证书）下的开源软件。Dart是面向对象的、类定义的、单继承的语言。它的语法类似C语言，可以转译为JavaScript，支持接口(interfaces)、混入(mixins)、抽象类(abstract classes)、具体化泛型(reified generics)、可选类型(optional typing)和 sound type system。     </p>
</blockquote>
<a id="more"></a> 
<h3 id="Dart-应用"><a href="#Dart-应用" class="headerlink" title="Dart 应用"></a>Dart 应用</h3><p>Dart 语言最早提出的目的就是来做为浏览器开发语言， Google 本来打算将 Dart 的虚拟机放入浏览器中。后来没有实现，目前 Dart 可以被看做类似 typescript 一样。<br>在移动开发中，Google 开发的移动端 UI 框架 Flutter 采用的就是 Dart 语言。  </p>
<h2 id="Dart-语法"><a href="#Dart-语法" class="headerlink" title="Dart 语法"></a>Dart 语法</h2><h3 id="Dart-的几个基本概念"><a href="#Dart-的几个基本概念" class="headerlink" title="Dart 的几个基本概念"></a>Dart 的几个基本概念</h3><p>关于 Dart 语法有下面几个概念需要注意：  </p>
<ul>
<li>每个变量都是一个对象，。甚至数字，函数，和null都是对象。所有对象都继承自Object 类。这一点和 js 保持一致。  </li>
<li>Dart 的变量可以指定静态类型，也可以不指定，这里建议所有变量都要指明其类型。  </li>
<li>Dart 支持顶级方法（例如 main()），也支持实例函数和类函数（静态函数）。 你还可以在一个方法内创建另外一个方法（nested（嵌入方法） 或者 local functions（本地方法））。</li>
<li>同样，Dart 也支持顶级 变量，也支持实例变量和类变量（静态变量）。 实例变量有时候被称之为 值域或者属性（fields 或者 properties）。 </li>
<li>Dart 有两种 运行模式： 生产模式和检测模式（ production and checked）。生产模式效率高，但是测试模式可以在开发的时候帮助调试代码。</li>
</ul>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>对比如下：  </p>
<img src="/2018/09/10/从js角度看dart/a.png" alt="a.png" title="">     
<p>总的来说 Numbers, String 差异不多，这里仅仅列出一些不同点。  </p>
<p>在 dart 定义常量用关键字: <code>final</code>, <code>const</code> 两个，区别在于：  </p>
<ol>
<li>final 要求变量只能初始化一次，并不要求赋的值一定是编译时常量，可以是常量也可以不是。而 const 要求在声明时初始化，并且赋值必需为编译时常量。</li>
<li>final 是惰性初始化，即在运行时第一次使用前才初始化。而 const 是在编译时就确定值了。<br>(<code>编译时常量</code>指的是：字面量（如数字、bool、字符串、List的字面量形式）、其它常量 或者 常量的算术运算，也可以是这些的组合形式（递归要求），简单地说常量就是可以在编译时确定的值)</li>
</ol>
<p>注意： </p>
<ul>
<li>字符串的其他操作也和 js 一致(dart 中字符串没有 slice 方法)。 </li>
<li>在 dart 中字符串模板使用的是 单引号 ‘ ，而不是反引号 ` </li>
<li>我们可以用（’’’）来包含换行文本内容   </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String str = &apos;&apos;&apos;</div><div class="line">换行文本内容&apos;&apos;&apos;;</div></pre></td></tr></table></figure>
<p>对于 List 和 Maps 上的操作，不同的地方如下。  </p>
<h4 id="List-的差别"><a href="#List-的差别" class="headerlink" title="List 的差别"></a>List 的差别</h4><h5 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h5><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="comment">// 添加一个元素，类似 arr.push(5)</span></div><div class="line">arr.add(<span class="number">5</span>);  </div><div class="line"><span class="comment">// 一次添加多项, 类似 arr.concat(5, 6, 7, 8)</span></div><div class="line">arr.addAll([<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]);</div><div class="line"><span class="comment">// 指定位置添加元素, 类似 arr.splice(0, 0, 0);</span></div><div class="line">arr.insert(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line"><span class="comment">// 指定位置添加多个元素，类似 arr.splice(0, 0, -1, -2);</span></div><div class="line">arr.insertAll(<span class="number">0</span>, [<span class="number">-1</span>, <span class="number">-2</span>])</div></pre></td></tr></table></figure>
<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 删除第一个匹配到的元素  </span></div><div class="line">arr.remove(<span class="number">3</span>);</div><div class="line"><span class="comment">// 删除第几个元素，类似 arr.splice(1, 1);</span></div><div class="line">arr.removeAt(<span class="number">1</span>);</div><div class="line"><span class="comment">// 删除所有元素  </span></div><div class="line">arr.clear(); </div><div class="line"><span class="comment">// 移除开始下标（包括）至结束下标（不包括）内的元素  </span></div><div class="line">arr.removeRange(<span class="number">1</span>, <span class="number">4</span>);</div><div class="line"><span class="comment">// 移除并替换开始下标（包括）至结束下标（不包括）内的元素  </span></div><div class="line">arr.replaceRange(<span class="number">1</span>, <span class="number">4</span>, [<span class="number">6</span>, <span class="number">7</span>]);</div></pre></td></tr></table></figure>
<h5 id="查询-amp-排序"><a href="#查询-amp-排序" class="headerlink" title="查询 &amp; 排序"></a>查询 &amp; 排序</h5><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回从开始下标（包括）到结束下标（不包括）元素的列表; 类似： arr.slice(1, 3)  </span></div><div class="line">arr.sublist(<span class="number">1</span>, <span class="number">2</span>);  </div><div class="line"><span class="comment">// 数组随机排序  </span></div><div class="line">arr.shuffle();</div></pre></td></tr></table></figure>
<p>List 的操作 和 Set 操作几乎一致，这里就不在列出 Set 了。 </p>
<h4 id="Maps-的差别"><a href="#Maps-的差别" class="headerlink" title="Maps 的差别"></a>Maps 的差别</h4><p>map 通常被称之为 dictionary 或者 hash， map 是一个无序的 key-value（键-值） 对。 map 中每个值都有一个对应的键便于访问。和 JavaScript 不同， Dart 对象不是 map。    </p>
<h5 id="所有属性"><a href="#所有属性" class="headerlink" title="所有属性"></a>所有属性</h5><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">int</span>&gt; map = &#123;<span class="string">"a"</span>:<span class="number">1</span>, <span class="string">"b"</span>:<span class="number">2</span>, <span class="string">"c"</span>:<span class="number">3</span>&#125;;</div><div class="line"><span class="comment">// 返回映射的哈希码</span></div><div class="line">map.hashCode  </div><div class="line"><span class="comment">// 映射上是否没有键值对  </span></div><div class="line">map.isEmpty</div><div class="line"><span class="comment">// 映射上是否有键值对  </span></div><div class="line">map.isNotEmpty  </div><div class="line"><span class="comment">// 返回映射的所有键, 类似 Object.keys(map)</span></div><div class="line">map.keys    </div><div class="line"><span class="comment">// 返回对象运行时的类型  </span></div><div class="line">map.runtimeType</div></pre></td></tr></table></figure>
<p>注意：这里的 Map 并不像是简单的 js 的对象。如果你想访问属性建议使用 <code>[]</code> 的方式，例如：<code>map[&quot;a&quot;]</code>。不要使用 <code>.</code> 的方式 (在 Map 作为参数的时候会报错);</p>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 按顺序迭代映射    </span></div><div class="line">map.forEach((key, value)&#123;</div><div class="line">    <span class="built_in">print</span>(key + <span class="string">" : "</span> + value.toString());</div><div class="line">&#125;);  </div><div class="line"><span class="comment">// 添加其他键值对到映射中  </span></div><div class="line">map.addAll(&#123;<span class="string">"d"</span>:<span class="number">4</span>, <span class="string">"e"</span>:<span class="number">5</span>&#125;);  </div><div class="line"><span class="comment">// 映射是否包含指定键  </span></div><div class="line">map.containsKey(<span class="string">"d"</span>);  </div><div class="line"><span class="comment">// 映射是否包含指定值  </span></div><div class="line">map.containsValue(<span class="number">5</span>);  </div><div class="line"><span class="comment">// 删除指定键值对  </span></div><div class="line">map.remove(<span class="string">"a"</span>);</div><div class="line"><span class="comment">// 删除所有键值对</span></div><div class="line">map.clear();  </div><div class="line"><span class="comment">// 如果想在 key 不存在的时候 才设置该值，则可以用 putIfAbsent() 函数。该函数 的参数为返回设置的值的方法  </span></div><div class="line">m.putIfAbsent(<span class="string">"d"</span>, () =&gt; <span class="number">4</span>);</div></pre></td></tr></table></figure>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>在 Dart 中函数的基本语法和 JavaScript 类似，但是不需要输入 function 关键字，定义一个函数：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> printNumber(<span class="built_in">int</span> <span class="built_in">num</span>) &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="built_in">num</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><p>在 dart 中，比 js 多一个 可选参数的概念；可选参数可以是 <code>命名参数</code> 或者 <code>位置参数</code>，但是不能同时使用两种类型。</p>
<h5 id="可选-命名参数"><a href="#可选-命名参数" class="headerlink" title="可选 - 命名参数"></a>可选 - 命名参数</h5><p>用 {param1, param2, …} 来定义方法的 命名参数：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> text(&#123;<span class="built_in">int</span> a, <span class="built_in">int</span> b&#125;) &#123;</div><div class="line">    <span class="built_in">print</span>(a);</div><div class="line">    <span class="built_in">print</span>(b);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>注意</code>：对于这种方式如果想要设置参数默认值，需要用 <code>:</code> ; 其他的情况，我们可以采用 <code>=</code> 来设置默认值。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> text(&#123;<span class="built_in">int</span> a: <span class="number">1</span>, <span class="built_in">int</span> b&#125;) &#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当我们想给参数 b 设置内容的时候，调用如下： </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">text(b: <span class="number">5</span>);    <span class="comment">// 输出 null, 5</span></div></pre></td></tr></table></figure>
<h5 id="可选-位置参数"><a href="#可选-位置参数" class="headerlink" title="可选 - 位置参数"></a>可选 - 位置参数</h5><p>位于 [] 中间的参数为可选位置 参数：  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> setPersonInfo(<span class="built_in">String</span> name, <span class="built_in">int</span> age, [<span class="built_in">String</span> addr]) &#123;</div><div class="line">    <span class="comment">//....</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="main-函数"><a href="#main-函数" class="headerlink" title="main 函数"></a>main 函数</h4><p>每一个应用都必须有一个顶级函数main() ，这个函数就是整个应用的入口函数。main() 函数返回值类型为 void 并且有一个可选参数List<string> ，这点也是和 js 完全不同的。  </string></p>
<h4 id="语法作用域"><a href="#语法作用域" class="headerlink" title="语法作用域"></a>语法作用域</h4><p>Dart 是一种语法作用域语言，也就是说 变量的作用域 是根据代码布局静态判断的。 可以根据“变量位于花括号内外”来判断一个变量是否在作用域中。  </p>
<h4 id="语法闭包"><a href="#语法闭包" class="headerlink" title="语法闭包"></a>语法闭包</h4><p>一个 closure（闭包） 是一个可以 访问位于其语法作用域内变量的方法对象，即时该方法用在其定义的作用域之外，也可以访问这些变量。方法可以覆盖定义在附近作用域的变量。</p>
<h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><p>对于只有一个表达式的方法，你可以用缩写形式：<br>printNumber(number) =&gt; print(‘The number is $number.’);  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">printNumber(<span class="built_in">num</span> number) =&gt; <span class="built_in">print</span>(<span class="string">'The number is $number.'</span>);</div></pre></td></tr></table></figure>
<p>但是请注意，和 js 不同，dart 只有简写的时候 <code>=&gt;</code> 才是函数，如果不是简写，不能用这个 <code>=&gt;</code> 来表示一个函数。在 Dart 中，匿名函数是没有 <code>=&gt;</code> 的形式。 例如，匿名函数:  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// IIFE </span></div><div class="line"><span class="comment">// 在 javascript 这是正确的  </span></div><div class="line">(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</div><div class="line">&#125;)()  </div><div class="line"></div><div class="line"><span class="comment">// 在 Dart 中  </span></div><div class="line"></div><div class="line">() &#123;</div><div class="line">    print(<span class="number">1</span>);</div><div class="line">&#125;();</div><div class="line"></div><div class="line">lists.forEach((item) &#123;</div><div class="line">    <span class="comment">//....</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了，Dart 的基础语法部分。对于运算符，循环，判断等就不介绍了，因为和 js 一样。总的来看，Dart 和 js 语法相似度还是很高的。下篇，讲介绍 类与泛型。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近准备尝试下谷歌的 Flutter 开发，因此需要学习一下 dart 语言。本文主要将 javascript 和 dart 进行对比，从而帮助我们快速入门 dart 语言。  &lt;/p&gt;
&lt;h2 id=&quot;Dart-简介&quot;&gt;&lt;a href=&quot;#Dart-简介&quot; class=&quot;headerlink&quot; title=&quot;Dart 简介&quot;&gt;&lt;/a&gt;Dart 简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Dart是谷歌开发的计算机编程语言，后来被Ecma (ECMA-408)认定为标准。它被用于web、服务器、移动应用和物联网等领域的开发。它是宽松开源许可证（修改的BSD证书）下的开源软件。Dart是面向对象的、类定义的、单继承的语言。它的语法类似C语言，可以转译为JavaScript，支持接口(interfaces)、混入(mixins)、抽象类(abstract classes)、具体化泛型(reified generics)、可选类型(optional typing)和 sound type system。     &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Flutter" scheme="http://yoursite.com/categories/Flutter/"/>
    
    
      <category term="Dart 语言" scheme="http://yoursite.com/tags/Dart-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="移动开发" scheme="http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序架构原理</title>
    <link href="http://yoursite.com/2018/09/03/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/09/03/微信小程序架构原理/</id>
    <published>2018-09-03T07:09:20.000Z</published>
    <updated>2018-09-12T08:25:22.827Z</updated>
    
    <content type="html"><![CDATA[<p>好久没有整理文章了，懒了啊，补一个最近工作中调研的内容吧。本文主要从源码方面介绍微信小程序的架构原理，并简单总结下这么做的好处。</p>
<h2 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h2><p>微信小程序包含下面四种文件：  </p>
<ul>
<li>js </li>
<li>json    配置文件</li>
<li>wxml  小程序专用 xml 文件</li>
<li>wxss   小程序专用 css 文件     </li>
</ul>
<a id="more"></a>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">"window"</span>&gt;</span>&#123;&#123; text &#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Page(&#123;</div><div class="line">  data:&#123;</div><div class="line">    text:<span class="string">"这是一个页面"</span></div><div class="line">  &#125;,</div><div class="line">  onLoad:<span class="function"><span class="keyword">function</span>(<span class="params">options</span>)</span>&#123;</div><div class="line">    <span class="comment">// 页面初始化 options为页面跳转所带来的参数</span></div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// ........</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>微信小程序只能通过其 mvvm 的模板语法来动态改变页面，本身 js 并不支持 BOM 和 DOM 操作。  </p>
<h2 id="从开发工具看微信小程序架构"><a href="#从开发工具看微信小程序架构" class="headerlink" title="从开发工具看微信小程序架构"></a>从开发工具看微信小程序架构</h2><p> 在 mac 端直接解压应用 发现 app.nw 文件夹，即开发工具源码。可以知道该项目由 nw.js 编写；<br> 在 package.json 文件下找到应用入口：<code>app/html/index.html</code>。入口 js 为 <code>dist/app.js</code> 我们可以看到整个编辑器的大致逻辑。<br> 但我们关心的是构建过程，在 weapp 文件夹下存在 build.js 文件。没有找到有用的信息，只看到了 <code>upload</code> 模块，包括对大小限制，上传包命名。<br>为此怀疑，微信小程序本身和 RN 类似。是在服务端打包成 native 语言的。但是通过 android 边框测试发现，微信小程序根本不是 native 原生内容。<br>原生界面效果<br><img src="/2018/09/03/微信小程序架构原理/tgy-wx-a.jpg" alt="tgy-wx-a.jpg" title=""> </p>
<h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p>继续在 trans 文件夹下发现了编译模板。  </p>
<ul>
<li>transWxmlToJs     wxml 转 js</li>
<li>transWxssToCss    wxss 转 css</li>
<li>transConfigToPf   模板页配置</li>
<li>transWxmlToHtml   wxml 转 html</li>
<li>transManager      管理器  </li>
</ul>
<p>用到的内容：  </p>
<ul>
<li>发现用到了一个模板：<code>app.nw/app/dist/weapp/tpl/pageFrameTpl.js</code>, <code>app.mw/app.dist.weapp/tpl/appserviceTpl.js</code>  </li>
<li>wcc 可执行程序，wcc 用于转换 wxml 中的自定义 tag 为 virtual_dom</li>
<li>wcsc 可执行程序，用于将 wxss 转为 view 模块使用的 css 代码，使用方式为 wcsc xxx.wxss</li>
</ul>
<p>在模板中，我们发现使用了 <code>WAWebview.js</code> 文件，<code>WAService.js</code>文件。<br>在 transWxmlToJs 中我们发现一段 generateFuncReady 事件的函数。对比注册该事件的函数在 <code>WAWebview.js</code> 中。<br>我们尝试使用 wcc 对input.xml 文件进行编译。</p>
<blockquote>
<p>wcc -d input.xml  </p>
</blockquote>
<p>生成了一段脚本：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.__wcc_version__ = <span class="string">'v0.6vv_20161230_fbi'</span></div><div class="line"><span class="keyword">var</span> $gwxc</div><div class="line"><span class="keyword">var</span> $gaic = &#123;&#125;</div><div class="line">$gwx = <span class="function"><span class="keyword">function</span> (<span class="params">path, global</span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">        b &amp;&amp; a.children.push(b);</div><div class="line">    &#125;</div><div class="line">    ....</div></pre></td></tr></table></figure>
<p>通过代码我们发现，调用 $gwx 函数会再生成一个有返回值的函数(前提是 path 填写正确)；于是我们执行如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$gwx(<span class="string">"input.xml"</span>)(<span class="string">"test"</span>)</div></pre></td></tr></table></figure>
<p>得出如下内容：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"tag"</span>: <span class="string">"wx-page"</span>,</div><div class="line">    <span class="string">"children"</span>: [</div><div class="line">        &#123;</div><div class="line">            <span class="string">"tag"</span>: <span class="string">"wx-view"</span>,</div><div class="line">            <span class="string">"attr"</span>: &#123;</div><div class="line">                <span class="string">"class"</span>: <span class="string">"section"</span></div><div class="line">            &#125;,</div><div class="line">            <span class="string">"children"</span>: [</div><div class="line">                &#123;</div><div class="line">                    <span class="string">"tag"</span>: <span class="string">"wx-input"</span>,</div><div class="line">                    <span class="string">"attr"</span>: &#123;</div><div class="line">                        <span class="string">"autoFocus"</span>: <span class="literal">true</span>,</div><div class="line">                        <span class="string">"placeholder"</span>: <span class="string">"这是一个可以自动聚焦的input"</span></div><div class="line">                    &#125;,</div><div class="line">                    <span class="string">"children"</span>: []</div><div class="line">                &#125;</div><div class="line">            ]</div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这应该是一个类似 Virtual dom 的对象，交给了 WAWebivew.js 来渲染，标签名为 <code>wx-view</code>, <code>wx-input</code>。  </p>
<h4 id="WAWebview-js"><a href="#WAWebview-js" class="headerlink" title="WAWebview.js"></a>WAWebview.js</h4><ol>
<li><p>代码在最一开始提供的是兼容性工具，还有一个 WeixinJSBridge 引入。</p>
</li>
<li><p>接下来是一个 Reporter 对象，它的作用就是发送错误和性能统计数据给后台。</p>
<img src="/2018/09/03/微信小程序架构原理/tgy-wx-b.jpg" alt="tgy-wx-b.jpg" title="">  
</li>
<li><p>wx 核心对象，包含了 wx 对象下的 api。但是这里的 api 数量远远少于官方的 api 文档数量。</p>
  
<p>我们可以在代码里面发现，wx 下注册的 api 最终都会调用 WeixinJSBridge 方法，这个方法。应该是在打包的时候端上注入的。然而，我们也可以在 WAServeice.js 中找到该方法的定义。  </p>
<img src="/2018/09/03/微信小程序架构原理/tgy-wx-d.jpg" alt="tgy-wx-d.jpg" title="">    
<p>所以我们得到了一个结论，WAService.js 是编辑器用来接受 wx 方法回调的代码。</p>
</li>
<li>wxparser 对象，提供 dom 到 wx element 对象之间的映射操作，提供元素操作管理和事件管理功能。</li>
<li><p>之后代码是对 exparser 对象的处理，包括注册 WeixinJSBridge 全局事件，Virtual dom 算法实现，样式注入等。介绍几个组件重要的内容  </p>
<ul>
<li><p>exparser.registerBehavior 注册组件基础行为，供组件继承。</p>
<img src="/2018/09/03/微信小程序架构原理/tgy-wx-e.jpg" alt="tgy-wx-e.jpg" title="">      
</li>
<li><p>exparser.registerElement 为各种内置组件，注册模板，行为，属性，监听器等内容</p>
</li>
</ul>
</li>
</ol>
 
<p>这里我们观察到，组件：<code>wx-video</code>, <code>wx-canvas</code>, <code>wx-contact-button</code>, <code>wx-map</code>, <code>wx-textarea</code> 等 behaviors 都含有 “wx-native” 属性。这是不是意味着，这类组件都是 native 原生实现的呢。我们打开边框检查，发现这类组件确实都是原生的组件。<br><img src="/2018/09/03/微信小程序架构原理/tgy-wx-g.jpg" alt="tgy-wx-g.jpg" title="">   </p>
<img src="/2018/09/03/微信小程序架构原理/tgy-wx-h.jpg" alt="tgy-wx-h.jpg" title="">   
<p>综上，微信小程序的界面有部分组件使用原生方式实现的，native 组件层在 WebView 层之上。大部分还是用前端实现的，这样解释了微信小程序的一个bug。</p>
<blockquote>
<p>微信官方文档：<br><img src="/2018/09/03/微信小程序架构原理/tgy-wx-i.jpg" alt="tgy-wx-i.jpg" title="">  </p>
</blockquote>
<p>因为 scroll-view 是前端实现，在里面使用 native 组件，这样就无法监听滚动了。  </p>
<h4 id="WeixinJSBridge"><a href="#WeixinJSBridge" class="headerlink" title="WeixinJSBridge"></a>WeixinJSBridge</h4><p>组件是需要数据来渲染的，查看文档我们知道发送请求的 api 为 <code>wx.request</code>;通过上面分析，我么你知道 wx.request 实际调用的是 <code>WeixinJSBridge</code>。现在我们看看 <code>WeixinJSBridge</code><br><img src="/2018/09/03/微信小程序架构原理/tgy-wx-j.jpg" alt="tgy-wx-j.jpg" title=""><br>WeixinJSBridge 真正发送处理数据请求的是这端代码；如果当前环境是 ios, 那么调用 WKWebview的 window.webkit.messageHandlers.invokeHandler.postMessage。如果所处环境是 android 则调用 WeixinJSCore.invokeHandler(调用的时候，默认会带上当前webviewID)。  </p>
<h4 id="WAService-js"><a href="#WAService-js" class="headerlink" title="WAService.js"></a>WAService.js</h4><p>在对 WeixinJSBridge.js 分析中，我们并没有发现前端的通讯功能，路由能力，数据绑定等内容。进一步查看找到了一个 <code>WAService.js</code> 文件。<br>查看 <code>WAService.js</code> 文件源码：  </p>
<ol>
<li>在代码最开始，跟 WAWebview.js 一样的 WeixinJSBridge 兼容模块</li>
<li>然后是跟 WAWebview.js 一样的 Reporter 模块。</li>
<li>比 WAWebview.js 中 wx 功能更为丰富 wx 接口模块。(剩余的那部分 wx api 都在这里)</li>
<li>appServiceEngine 模块，提供 Page，App，GetApp 接口</li>
<li>为 window 对象添加 AMD 接口 require define  </li>
</ol>
<p>综上，WAService.js 主要实现的功能：  </p>
<ul>
<li>App() 小程序的入口；Page( ) 页面的入口</li>
<li>wx API;</li>
<li>页面有的作用域，提供模块化能力</li>
<li>数据绑定、事件分发、生命周期管理、路由管理</li>
</ul>
<p>到这里我们得出结论，小程序的架构方案：<br>   </p>
<p>整个小程序由两个 webview 组成，代码分为 UI 层和逻辑层。UI 层运行在第一个 WebView 当中，执行 DOM 操作和交互事件的响应，里面是 WAWebview.js 代码及编译后的内容。逻辑层执行在（第二个webview 中）独立的 JS 引擎中（iOS：JavaScriptCore, android：X5 JS解析器；统称 JSCore；开发工具中，nwjs Chrome 内核），WAService.js 代码和业务逻辑。</p>
<p>当我们对 view 层进行事件操作后，会通过 WeixinJSBridge 将数据传递到 Native 系统层。Native 系统层决定是否要用 native 处理，然后丢给 逻辑层进行用户的逻辑代码处理。逻辑层处理完毕后会将数据通过 WeixinJSBridge 返给 View 层。View 渲染更新视图。</p>
<h2 id="架构的讨论"><a href="#架构的讨论" class="headerlink" title="架构的讨论"></a>架构的讨论</h2><p>微信的这种架构，对逻辑和UI进行了完全隔离，小程序逻辑和UI完全运行在2个独立的Webview里面来处理。那么这么做的好处是啥？总感觉更加麻烦了。除了小程序外，还有人采用这种架构设计么？<br>在网上搜索了一下，目前使用这种架构的项目还真有一个：<a href="http://ued.qunar.com/yis/index.html" target="_blank" rel="external">去哪儿最新的 YIS 框架</a>   </p>
<blockquote>
<p>YIS 采取了类似小程序的架构，分为逻辑层和UI层。UI 层运行在 WebView 中，而逻辑层运行在独立的 JS 引擎中。相应地，整个应用的代码，也分为两个大的部分，一部分运行在 WebView 中，一部分运行在JS引擎中。JS引擎计算DOM结构输出给WebView，WebView转发用户的点击事件给JS引擎。</p>
</blockquote>
<p>该项目做法和小程序十分类似，唯一缺少的就是没有 native 的组件吧。然而官方文档上也没有任何介绍，为什么要这么做，只是说更流畅了。  </p>
<h3 id="一些看法"><a href="#一些看法" class="headerlink" title="一些看法"></a>一些看法</h3><p>传统 web 页面显示需要经历一下几个步骤:  </p>
<ol>
<li>webview 初始化</li>
<li>加载 HTML, CSS, JS</li>
<li>编译 JS</li>
<li>Render 计算</li>
<li>DOM Path</li>
</ol>
<p>而利用小程序架构后，我们就可以将上述过程拆解成两部分并行执行：<br>webview 部分：</p>
<ol>
<li>webview 初始化</li>
<li>加载HTML，CSS, JS (经过拆分后，体积大幅度减小)</li>
<li>编译JS</li>
<li>等待页面需要的数据</li>
<li>反序列化数据</li>
<li>执行Patch</li>
<li>渲染页面</li>
<li>等待更多消息</li>
</ol>
<p>jscore 部分：</p>
<ol>
<li>初始化</li>
<li>加载框架 js 代码</li>
<li>编译 js</li>
<li>加载业务逻辑 js 代码</li>
<li>编译 js</li>
<li>计算首屏虚拟 DOM 结构</li>
<li>序列化数据，传输</li>
<li>等待 webview 消息，或者 Native 消息  </li>
</ol>
<p>这样渲染进程和逻辑进程分离，并行处理：加速首屏渲染速度；避免单线程模型下，js 运算时间过长，UI 出现卡顿。<br>完全采用数据驱动的方式，不能直接操作 DOM，避免低质量的代码。</p>
<p>当然这种架构方案也有这一定的缺点：  </p>
<ol>
<li>不能灵活操作 DOM，无法实现较为复杂的效果。</li>
<li>部分和NA相关的视图有使用限制，如微信的 scrollView 内不能有 textarea。</li>
<li>页面大小、打开页面数量都受到限制。</li>
<li>需要单独开发适配，不能复用现有代码资源。</li>
<li>在 jscore 中JS 体积比较大的情况下，其初始化时间会产生影响。</li>
<li>传输数据中，序列化和反序列化耗时需要考虑</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.zhihu.com/question/50920642" target="_blank" rel="external">微信小程序底层的实现原理是怎样的</a></li>
<li><a href="http://www.bbs0101.com/archives/1495.html" target="_blank" rel="external">微信小程序架构解析，工作原理解析</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/22754296" target="_blank" rel="external">微信小程序架构分析</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久没有整理文章了，懒了啊，补一个最近工作中调研的内容吧。本文主要从源码方面介绍微信小程序的架构原理，并简单总结下这么做的好处。&lt;/p&gt;
&lt;h2 id=&quot;微信小程序&quot;&gt;&lt;a href=&quot;#微信小程序&quot; class=&quot;headerlink&quot; title=&quot;微信小程序&quot;&gt;&lt;/a&gt;微信小程序&lt;/h2&gt;&lt;p&gt;微信小程序包含下面四种文件：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;js &lt;/li&gt;
&lt;li&gt;json    配置文件&lt;/li&gt;
&lt;li&gt;wxml  小程序专用 xml 文件&lt;/li&gt;
&lt;li&gt;wxss   小程序专用 css 文件     &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Hybrid 开发" scheme="http://yoursite.com/categories/Hybrid-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="架构设计" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Hybird 开发" scheme="http://yoursite.com/tags/Hybird-%E5%BC%80%E5%8F%91/"/>
    
      <category term="微信小程序" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>immer.js 源码分析</title>
    <link href="http://yoursite.com/2018/08/16/immer-js%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/08/16/immer-js源码分析/</id>
    <published>2018-08-16T09:28:12.000Z</published>
    <updated>2018-08-16T09:28:20.674Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Riot.js 源码解析 【二】 组件详解</title>
    <link href="http://yoursite.com/2017/10/18/riot-js%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%902/"/>
    <id>http://yoursite.com/2017/10/18/riot-js源码解析2/</id>
    <published>2017-10-18T06:24:12.000Z</published>
    <updated>2017-11-22T02:54:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="riot-组件"><a href="#riot-组件" class="headerlink" title="riot 组件"></a>riot 组件</h1><p>使用 riot 编写组件是以 .tag 后缀结尾的文件，我们的 html, css, js 都可以放在里面。这些文件在编译阶段会被编译成对应的js代码(见<a href="">Riot.js 源码解析 【一】 基础内容</a>)。每个组件都是一个 Tag 对象(代码在 /tag/tag.js 里面)，里面包含了对象的各种属性和方法。本文主要介绍，riot 组件的生命周期，更新原理(一个粗粒度的 virtual dom)以及简单更新优化手段。<br><a id="more"></a>     </p>
<h1 id="Tag-对象"><a href="#Tag-对象" class="headerlink" title="Tag 对象"></a>Tag 对象</h1><p>每一个 riot.js 组件其实就是一个 Tag 对象。Tag 类被定义在 /tag/tag.js 文件下面。Tag 类基本内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// impl 包含组件的模板，逻辑等属性  </span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Tag</span>(<span class="params">impl = &#123;&#125;, conf = &#123;&#125;, innerHTML</span>) </span>&#123;</div><div class="line">    ...各种属性初始化</div><div class="line">    defineProperty(<span class="keyword">this</span>, <span class="string">'__'</span>, &#123;...&#125;)</div><div class="line">    defineProperty(<span class="keyword">this</span>, <span class="string">'_riot_id'</span>, ++__uid)</div><div class="line">    defineProperty(<span class="keyword">this</span>, <span class="string">'refs'</span>, &#123;&#125;)</div><div class="line">    ...</div><div class="line">    <span class="comment">// 定义组件更新方法</span></div><div class="line">    defineProperty(<span class="keyword">this</span>, <span class="string">'update'</span>, <span class="function"><span class="keyword">function</span> <span class="title">tagUpdate</span>(<span class="params">data</span>)</span>&#123;...&#125;.bind(<span class="keyword">this</span>))</div><div class="line">    <span class="comment">// 定义组件 mixin 方法</span></div><div class="line">    defineProperty(<span class="keyword">this</span>, <span class="string">'update'</span>, <span class="function"><span class="keyword">function</span> <span class="title">tagMixin</span>(<span class="params">data</span>)</span>&#123;...&#125;.bind(<span class="keyword">this</span>))</div><div class="line">    <span class="comment">// 定义组件加载方法</span></div><div class="line">    defineProperty(<span class="keyword">this</span>, <span class="string">'mount'</span>, <span class="function"><span class="keyword">function</span> <span class="title">tagMount</span>(<span class="params">data</span>)</span>&#123;...&#125;.bind(<span class="keyword">this</span>))</div><div class="line">    <span class="comment">// 定义组件卸载方法</span></div><div class="line">    defineProperty(<span class="keyword">this</span>, <span class="string">'mount'</span>, <span class="function"><span class="keyword">function</span> <span class="title">tagUnmount</span>(<span class="params">data</span>)</span>&#123;...&#125;.bind(<span class="keyword">this</span>))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="riot-生命周期"><a href="#riot-生命周期" class="headerlink" title="riot 生命周期"></a>riot 生命周期</h1><p>riot 组件状态分为以下几个部分：  </p>
<ul>
<li>before-mount：标签被加载之前</li>
<li>mount：标签实例被加载到页面上以后</li>
<li>update：允许在更新之前重新计算上下文数据</li>
<li>updated：标签模板更新后</li>
<li>before-unmount：标签实例被卸载之前</li>
<li>unmount：标签实例被从页面上卸载后    </li>
</ul>
<p>riot.js 采用事件驱动的方式来进行通讯，我们可以采用如下函数来监听上面的事件，例如处理 update 事件：  </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">riot-demo</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript">        <span class="keyword">this</span>.on(<span class="string">'update'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></div><div class="line"><span class="javascript">            <span class="comment">// 标签更新后的处理</span></span></div><div class="line"><span class="undefined">        &#125;)</span></div><div class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">riot-demo</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="组件状态触发时机"><a href="#组件状态触发时机" class="headerlink" title="组件状态触发时机"></a>组件状态触发时机</h2><p>当我们调用 <code>riot.mount()</code> 渲染指定组件的时候，riot 会从 <code>__TAG_IMPL</code> 中获取相对应的已经注册好的模板内容，并生成相应的 <code>Tag</code> 实例对象。并且触发其上的 <code>Tag.mount()</code> 函数，最后将 <code>Tag</code> 对象缓存到 <code>__TAGS_CACHE</code> 中。代码如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountTo</span>(<span class="params">root, tagName, opts, ctx</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> impl = __TAG_IMPL[tagName],   <span class="comment">// 获取 html 模板</span></div><div class="line">        implClass = __TAG_IMPL[tagName].class, <span class="comment">// ?</span></div><div class="line">        tag = ctx || (implClass ? <span class="built_in">Object</span>.create(implClass.prototype) : &#123;&#125;),</div><div class="line">        innerHTML = root._innerHTML = root._innerHTML || root.innerHTML</div><div class="line">    <span class="keyword">var</span> conf = extend(&#123;</div><div class="line">        root: root,</div><div class="line">        opts: opts</div><div class="line">    &#125;, &#123;</div><div class="line">        parent: opts ? opts.parent : <span class="literal">null</span></div><div class="line">    &#125;)</div><div class="line">    <span class="keyword">if</span> (impl &amp;&amp; root) Tag.apply(tag, [impl, conf, innerHTML]);</div><div class="line">    <span class="keyword">if</span> (tag &amp;&amp; tag.mount) &#123;</div><div class="line">        tag.mount(<span class="literal">true</span>)</div><div class="line">        <span class="comment">// add this tag to the virtualDom variable</span></div><div class="line">        <span class="keyword">if</span> (!contains(__TAGS_CACHE, tag)) __TAGS_CACHE.push(tag)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> tag</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Tag.mount()</code> 函数流程如下：      </p>
<img src="/2017/10/18/riot-js源码解析2/a.png" alt="a.png" title="">  
<p>组件加载阶段，首先会整理标签上所有的 attribute 的内容，区分普通属性，和带有表达式 expr 的属性。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">defineProperty(<span class="keyword">this</span>, <span class="string">'mount'</span>, <span class="function"><span class="keyword">function</span> <span class="title">tagMount</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    ...</div><div class="line"></div><div class="line">    parseAttributes.apply(parent, [root, root.attributes, (attr, expr) =&gt; &#123;</div><div class="line">        <span class="comment">// 检测 expr 是否在 RefExpr 的原型链中</span></div><div class="line">        <span class="keyword">if</span> (!isAnonymous &amp;&amp; RefExpr.isPrototypeOf(expr)) expr.tag = <span class="keyword">this</span>;</div><div class="line">        <span class="comment">// 挂载在 root.attributs 上面 root 为组件所在的 dom 对象</span></div><div class="line">        attr.expr = expr</div><div class="line">        instAttrs.push(attr)</div><div class="line">    &#125;])   </div><div class="line"></div><div class="line">    <span class="comment">// impl 对象包含组件上的各种属性，包括模板，逻辑等内容</span></div><div class="line">    implAttrs = []</div><div class="line">    walkAttrs(impl.attrs, (k, v) =&gt; &#123;</div><div class="line">        implAttrs.push(&#123;</div><div class="line">            name: k,</div><div class="line">            value: v</div><div class="line">        &#125;)</div><div class="line">    &#125;)</div><div class="line">    <span class="comment">// 检查的是 implAttrs</span></div><div class="line">    parseAttributes.apply(<span class="keyword">this</span>, [root, implAttrs, (attr, expr) =&gt; &#123;</div><div class="line">        <span class="keyword">if</span> (expr) expressions.push(expr)   <span class="comment">//插入表达式</span></div><div class="line">        <span class="keyword">else</span> setAttr(root, attr.name, attr.value)</div><div class="line">    &#125;])</div><div class="line"></div><div class="line">    ... </div><div class="line">&#125;).bind(<span class="keyword">this</span>)</div></pre></td></tr></table></figure>
<p>初始化这些表达式内容，然后为组件添加全局注册的mixin 内容。接下来，会执行我们为组件添加的函数内容，此时触发 <code>before-mount</code> 事件。触发完毕后，解析标签上的表达式，比如 if each 等内容，然后执行组件的 <code>update()</code> 函数。    </p>
<p>在 <code>update()</code> 函数中，首先会检查用户是否定义了组件的 <code>shouldUpdate()</code> 函数，如果有定义则传入两个参数，第一个是想要更新的内容(即调用this.update() 时传入的参数)。第二个为接收的父组件更新的 opts 内容。若该函数返回值为 true 则更新渲染，否则放弃。  (这里需要注意，<code>Tag.mount()</code> 阶段由于组件尚未处于记载完毕状态，因此不会触发 shouldUpdate() 函数)。    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">defineProperty(<span class="keyword">this</span>, <span class="string">'update'</span>, <span class="function"><span class="keyword">function</span> <span class="title">tagUpdate</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">// shouldUpdate 返回值检测</span></div><div class="line">    <span class="keyword">if</span> (canTrigger &amp;&amp; <span class="keyword">this</span>.isMounted &amp;&amp; isFunction(<span class="keyword">this</span>.shouldUpdate) &amp;&amp; !<span class="keyword">this</span>.shouldUpdate(data, nextOpts)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span></div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">    <span class="comment">// 扩展opts</span></div><div class="line">    extend(opts, nextOpts)</div><div class="line">    <span class="keyword">if</span> (canTrigger) <span class="keyword">this</span>.trigger(<span class="string">'update'</span>, data)</div><div class="line">    update.call(<span class="keyword">this</span>, expressions)</div><div class="line">    <span class="keyword">if</span> (canTrigger) <span class="keyword">this</span>.trigger(<span class="string">'updated'</span>)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span></div><div class="line">&#125;).bind(<span class="keyword">this</span>);</div></pre></td></tr></table></figure>
<p>之后会触发 <code>update</code> 事件，开始渲染新的组件。渲染完毕后触发 <code>updated</code> 事件。   </p>
<p>加载完毕后，修改组件状态 <code>defineProperty(this, &#39;isMounted&#39;, true)</code>。如果渲染的组件不是作为子组件的话，我们就触发自身的 <code>mount</code> 事件。否则的话，需要等到父组件加载完毕后，或者更新完毕后(已经加载过了)，再触发。    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">defineProperty(<span class="keyword">this</span>, <span class="string">'mount'</span>, <span class="function"><span class="keyword">function</span> <span class="title">tagMount</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    ...</div><div class="line">    defineProperty(<span class="keyword">this</span>, <span class="string">'root'</span>, root)</div><div class="line">    defineProperty(<span class="keyword">this</span>, <span class="string">'isMounted'</span>, <span class="literal">true</span>)</div><div class="line">    <span class="keyword">if</span> (skipAnonymous) <span class="keyword">return</span></div><div class="line">    <span class="comment">// 如果不是子组件则触发</span></div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.parent) &#123;</div><div class="line">        <span class="keyword">this</span>.trigger(<span class="string">'mount'</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 否则需要等待父组件的状态渲染状态</span></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">const</span> p = getImmediateCustomParentTag(<span class="keyword">this</span>.parent)</div><div class="line">        p.one(!p.isMounted ? <span class="string">'mount'</span> : <span class="string">'updated'</span>, () =&gt; &#123;</div><div class="line">            <span class="keyword">this</span>.trigger(<span class="string">'mount'</span>)</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span></div><div class="line">&#125;).bind(<span class="keyword">this</span>)</div></pre></td></tr></table></figure>
<p>当我们调用 <code>tag.unmount</code> 卸载组件的时候，首先会触发 <code>before-unmount</code> 事件。再接下来清除所有的属性和事件监听等内容后，触发 ‘unmount’ 事件。  </p>
<h2 id="update-问题"><a href="#update-问题" class="headerlink" title="update 问题"></a>update 问题</h2><p>我们知道除了手动调用 <code>tag.update</code>的方式更新组件，我们通过绑定 dom 事件也能自动触发。这主要是因为在 riot 组件中绑定事件，默认会追加调用 update 的方法。相关代码如下：   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleEvent</span>(<span class="params">dom, handler, e</span>) </span>&#123;</div><div class="line">    <span class="comment">// 执行事件回调</span></div><div class="line">    handle.call(<span class="keyword">this</span>, e);</div><div class="line">    ...</div><div class="line">    <span class="comment">// 阻止 自动 update</span></div><div class="line">    <span class="keyword">if</span> (!settings.autoUpdate) <span class="keyword">return</span>  </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样的话，任何事件操作即使没有引起UI重新渲染，也会触发 update, updated 阶段。我们可以通过设置 <code>riot.settings.autoUpdate (default true)</code> 来更改这种行为。  </p>
<h1 id="更新原理"><a href="#更新原理" class="headerlink" title="更新原理"></a>更新原理</h1><p>在 riot.js 中，想要更新组件我们必须手动调用 <code>tag.update()</code> 方法才可以或者通过绑定 dom 事件触发(通过模板绑定的事件，会在回调执行完毕后自动触发 tag.update )，并不能做到实时的更新处理。例如：    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;riot-demo&gt;</div><div class="line">    &lt;h1&gt;&#123; title &#125;&lt;<span class="regexp">/h1&gt;</span></div><div class="line"><span class="regexp">    &lt;button click=&#123; handleClick &#125;&gt;修改内容&lt;/</span>button&gt;</div><div class="line">    &lt;script&gt;</div><div class="line">        <span class="keyword">this</span>.title = <span class="string">"标题"</span></div><div class="line">        handleClick() &#123;</div><div class="line">            <span class="keyword">this</span>.title = <span class="string">"新标题"</span>;</div><div class="line">            <span class="keyword">this</span>.update();   <span class="comment">// 调用 update 方法才能重新渲染组件</span></div><div class="line">        &#125;</div><div class="line">    &lt;<span class="regexp">/script&gt;</span></div><div class="line"><span class="regexp">&lt;/</span>riot-demo&gt;</div></pre></td></tr></table></figure>
<p>riot.js 并没有提供 virtual dom 的功能，而是实现了一个粗粒度的 virtual dom。riot.js 为每个组件创建的 tag 对象中都保存一个 expressions 数组，更新的时候遍历 expressions 数组，对比旧值，如果有变化就更新DOM。这种更新机制类似angular的脏检查，但是仅有一轮检查（单项数据流）。更新处理依照模板类型来处理：  </p>
<ul>
<li>文本内容的，直接： dom.nodeValue = value</li>
<li>值为空，而且关联的 DOM 属性是 checked/selected 等这种没有属性值的，移除对应的属性</li>
<li>值为函数的，则进行事件绑定</li>
<li>属性名为 if，则做条件判断处理</li>
<li>做了 show/hide 的语法糖处理：   </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">toggleVisibility</span>(<span class="params">dom, show</span>) </span>&#123;</div><div class="line">    dom.style.display = show ? <span class="string">''</span> : <span class="string">'none'</span></div><div class="line">    dom[<span class="string">'hidden'</span>] = show ? <span class="literal">false</span> : <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>普通属性的，直接设置其值</li>
</ul>
<p>riot.js 和 react 一样也有 props(静态，riot 中为 opts) 和本身数据(动态)，具有和 react 一样的输入。但是输出的时候，由于没有 virtual dom UI的更新并没有集中处理，是分散的。<br>riot.js 采用的这种方式，代码量上大大的减少，但是也带来了比较严重的性能问题。  </p>
<h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><p>首先我们来看一段 vue 代码：    </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span>&gt;</span></div><div class="line">            &#123;&#123; item.name &#125;&#125; --- &#123;&#123; item.age &#125;&#125;</div><div class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"handleClick"</span>&gt;</span>更新列表项<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> demo = <span class="keyword">new</span> Vue(&#123;</div><div class="line">    el: <span class="string">'#demo'</span>,</div><div class="line">    data: &#123;</div><div class="line">        items: [</div><div class="line">          &#123; <span class="attr">name</span>: <span class="string">'tgy'</span>, <span class="attr">age</span>: <span class="number">23</span>&#125;,</div><div class="line">        ]</div><div class="line">    &#125;,</div><div class="line">    methods: &#123;</div><div class="line">        handleClick: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.items = [</div><div class="line">                &#123; <span class="attr">name</span>: <span class="string">'tgy'</span>, <span class="attr">age</span>: <span class="number">23</span>&#125;,</div><div class="line">                &#123; <span class="attr">name</span>: <span class="string">'hy'</span>, <span class="attr">age</span>: <span class="number">22</span>&#125;,</div><div class="line">            ]</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    mounted: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">         <span class="built_in">console</span>.log(<span class="string">"组件挂载完毕"</span>);</div><div class="line">         <span class="built_in">document</span>.querySelector(<span class="string">"li"</span>).extraType = <span class="string">"origin"</span>;</div><div class="line">    &#125;,</div><div class="line">    updated: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">         <span class="built_in">console</span>.log(<span class="string">"组件更新完毕"</span>);</div><div class="line">         <span class="built_in">console</span>.log(<span class="built_in">document</span>.querySelector(<span class="string">"li"</span>).extraType);</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>代码很简单，单击按钮，为列表添加一条新数据。在组件挂载完毕后，为第一个 li 的 property 上面添加了 extraType 属性。列表更新后，再去访问这个 li 的 extraType 属性。运行结果如下：  </p>
<img src="/2017/10/18/riot-js源码解析2/b.png" alt="b.png" title="">  
<p>不出意料，可以正常访问到 li 的type属性。这说明了，在更新过程中，第一个 li 节点仅仅是 textContent 发生了改变而不是重新创建的。这样的结果得益于 virtual dom 算法，保证更新最小变动。同样的我们用 riot 来重写上面的代码。      </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">content-demo</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">each</span>=<span class="string">&#123;</span> <span class="attr">items</span> &#125;&gt;</span>&#123; name &#125; -- &#123; age &#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn"</span> <span class="attr">click</span>=<span class="string">&#123;</span> <span class="attr">handleClick</span> &#125;&gt;</span>订阅内容<span class="tag">&lt;/<span class="name">button</span>&gt;</span>  </div><div class="line">   <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript">        <span class="keyword">let</span> self = <span class="keyword">this</span>;</span></div><div class="line"><span class="javascript">        <span class="keyword">this</span>.items = [</span></div><div class="line"><span class="javascript">            &#123;<span class="string">"name"</span>: <span class="string">"tgy"</span>, <span class="attr">age</span>: <span class="number">23</span>&#125;</span></div><div class="line"><span class="undefined">        ];</span></div><div class="line"><span class="undefined">        handleClick() &#123;</span></div><div class="line"><span class="javascript">            <span class="keyword">this</span>.items = [</span></div><div class="line"><span class="javascript">                &#123;<span class="string">"name"</span>: <span class="string">"tgy"</span>, <span class="attr">age</span>: <span class="number">23</span>&#125;,</span></div><div class="line"><span class="javascript">                &#123;<span class="string">"name"</span>: <span class="string">"hy"</span>, <span class="attr">age</span>: <span class="number">22</span>&#125;</span></div><div class="line"><span class="undefined">            ]</span></div><div class="line"><span class="undefined">        &#125;</span></div><div class="line"><span class="javascript">        <span class="keyword">this</span>.on(<span class="string">'mount'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></div><div class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"组件加载完毕"</span>);</span></div><div class="line"><span class="javascript">            <span class="built_in">document</span>.querySelector(<span class="string">"li"</span>).extraType = <span class="string">"origin"</span>;</span></div><div class="line"><span class="undefined">        &#125;)</span></div><div class="line"><span class="javascript">        <span class="keyword">this</span>.on(<span class="string">'updated'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></div><div class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"组件更新完毕"</span>);</span></div><div class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="built_in">document</span>.querySelector(<span class="string">"li"</span>).extraType);</span></div><div class="line"><span class="undefined">        &#125;)</span></div><div class="line"><span class="undefined">   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">content-demo</span>&gt;</span></div></pre></td></tr></table></figure>
<p>查看运行结果：  </p>
<img src="/2017/10/18/riot-js源码解析2/c.png" alt="c.png" title="">
<p>extraType 找不到了，所有的 li 节点都被重新构建了。这里面发生了什么，查看源码 /tag/each.js。渲染逻辑代码如下：     </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">_each</span>(<span class="params">dom, parent, expr</span>) </span>&#123;</div><div class="line">    ...</div><div class="line">    expr.update = <span class="function"><span class="keyword">function</span> <span class="title">updateEach</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        ...</div><div class="line">        each(items, <span class="function"><span class="keyword">function</span> (<span class="params">item, i</span>) </span>&#123;</div><div class="line">            <span class="comment">// 仅仅记录 items 是对象的</span></div><div class="line">            <span class="keyword">var</span></div><div class="line">                doReorder = mustReorder &amp;&amp; <span class="keyword">typeof</span> item === T_OBJECT &amp;&amp; !hasKeys,</div><div class="line">                <span class="comment">// 旧数据</span></div><div class="line">                oldPos = oldItems.indexOf(item),</div><div class="line">                <span class="comment">// 是新的</span></div><div class="line">                isNew = oldPos === <span class="number">-1</span>,</div><div class="line">                pos = !isNew &amp;&amp; doReorder ? oldPos : i,</div><div class="line">                tag = tags[pos],</div><div class="line">                <span class="comment">// 必须追加</span></div><div class="line">                mustAppend = i &gt;= oldItems.length,</div><div class="line">                <span class="comment">// 必须创建 isNew</span></div><div class="line">                mustCreate = doReorder &amp;&amp; isNew || !doReorder &amp;&amp; !tag</div><div class="line">                <span class="comment">// 有key值得时候需要 mkitem</span></div><div class="line">            item = !hasKeys &amp;&amp; expr.key ? mkitem(expr, item, i) : item</div><div class="line">            <span class="comment">// 必须创建一个新 tag </span></div><div class="line">            <span class="keyword">if</span> (mustCreate) &#123;</div><div class="line">                tag = <span class="keyword">new</span> Tag(impl, &#123;</div><div class="line">                    parent,</div><div class="line">                    isLoop,</div><div class="line">                    isAnonymous,</div><div class="line">                    tagName,</div><div class="line">                    root: dom.cloneNode(isAnonymous),</div><div class="line">                    item,</div><div class="line">                    index: i,</div><div class="line">                &#125;, dom.innerHTML)</div><div class="line"></div><div class="line">                <span class="comment">// mount the tag</span></div><div class="line">                tag.mount()</div><div class="line">                <span class="keyword">if</span> (mustAppend)</div><div class="line">                    append.apply(tag, [frag || root, isVirtual])</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    insert.apply(tag, [root, tags[i], isVirtual])</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (!mustAppend) oldItems.splice(i, <span class="number">0</span>, item)</div><div class="line">                tags.splice(i, <span class="number">0</span>, tag)</div><div class="line">                <span class="keyword">if</span> (child) arrayishAdd(parent.tags, tagName, tag, <span class="literal">true</span>)</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pos !== i &amp;&amp; doReorder) &#123;</div><div class="line">                <span class="comment">// move</span></div><div class="line">                <span class="comment">// 移动</span></div><div class="line">                <span class="keyword">if</span> (contains(items, oldItems[pos])) &#123;</div><div class="line">                    move.apply(tag, [root, tags[i], isVirtual])</div><div class="line">                    <span class="comment">// move the old tag instance</span></div><div class="line">                    tags.splice(i, <span class="number">0</span>, tags.splice(pos, <span class="number">1</span>)[<span class="number">0</span>])</div><div class="line">                    <span class="comment">// move the old item</span></div><div class="line">                    oldItems.splice(i, <span class="number">0</span>, oldItems.splice(pos, <span class="number">1</span>)[<span class="number">0</span>])</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (expr.pos) tag[expr.pos] = i</div><div class="line">                <span class="keyword">if</span> (!child &amp;&amp; tag.tags) moveNestedTags.call(tag, i)</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 缓存原始数据到节点上</span></div><div class="line">            tag.__.item = item</div><div class="line">            tag.__.index = i</div><div class="line">            tag.__.parent = parent;</div><div class="line">            <span class="comment">// 如果不是创建的，我们需要更新节点内容。</span></div><div class="line">            <span class="keyword">if</span> (!mustCreate) tag.update(item)</div><div class="line">        &#125;)</div><div class="line">        <span class="comment">// remove the redundant tags</span></div><div class="line">        <span class="comment">// 删除多余的标签</span></div><div class="line">        unmountRedundant(items, tags)</div><div class="line">        <span class="comment">// 记录旧的数据</span></div><div class="line">        <span class="comment">// clone the items array</span></div><div class="line">        oldItems = items.slice()</div><div class="line">        <span class="comment">// dom 插入节点</span></div><div class="line">        root.insertBefore(frag, placeholder)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段为列表渲染逻辑，遍历新的数据items中的每一下 item。在原始数据 oldItems 中去查找(oldItems.indexOf(itemId))，是否存在 item 项。如果不存在，则标记 isNews 为 true。之后走到 if 的 mustCreaete 为 true 的分支，去创建一个新的 tag(将 li 节点看成是一个tag)。以此类推，当全部创建完毕后，删除旧的节点(unmountRedundant(items, tags))。在断点下，可以清楚看到节点的变化情况：   </p>
<img src="/2017/10/18/riot-js源码解析2/d.gif" alt="d.gif" title="">    
<h2 id="优化手段"><a href="#优化手段" class="headerlink" title="优化手段"></a>优化手段</h2><p>综上所述，riot.js 的更新逻辑仅仅是判断新旧数据项是否为同一对象。为此，为了减少 DOM 的变动，降低渲染逻辑。我们修改<code>handleClick</code>函数：   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">handleClick() &#123;</div><div class="line">    <span class="keyword">this</span>.items.push(&#123;<span class="string">"name"</span>: <span class="string">"hy"</span>, <span class="attr">age</span>: <span class="number">22</span>&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样输出结果就会和 vue 的保持一致，并没有创建新的 tag，而是利用了已经存在的内容。源码中，这种情况下 isNews 为 false，从而避开了 创建标签。而仅仅是通过 <code>tags.splice(i, 0, tags.splice(pos, 1)[0]);</code> 来移动位置，<code>if (!mustCreate) { tag.update(item); }</code> 更新节点内容。<br>保证数据项对象地址不变，仅仅是修改上面的不可变对象的值，将大大的提高 riot.js 的渲染效率。     </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 更新第一个li内容  </span></div><div class="line"></div><div class="line"><span class="comment">// 不推荐写法，对象发生变化；</span></div><div class="line"><span class="keyword">this</span>.items[<span class="number">0</span>] = &#123;<span class="string">"name"</span>: <span class="string">"hy"</span>, <span class="attr">age</span>: <span class="number">23</span>&#125;;   </div><div class="line"></div><div class="line"><span class="comment">// 推荐写法，仅仅是修改对象中的值</span></div><div class="line"><span class="keyword">this</span>.items[<span class="number">0</span>].name = <span class="string">"hy"</span>;</div><div class="line"><span class="keyword">this</span>.items[<span class="number">0</span>].age = <span class="number">22</span>;</div></pre></td></tr></table></figure>
<h2 id="数据处理插件"><a href="#数据处理插件" class="headerlink" title="数据处理插件"></a>数据处理插件</h2><p>实际阶段，我们就需要有一个插件，能够帮我们在处理数据项变动的时候，尽量保证大部分数据项地址不发生变化，从而提高 riot 的渲染性能。曾经考虑过使用 Immutable.js 来处理，但是需要修改 riot.js 代码才能实现。所以觉得自己弄个，开发中….  </p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://techblog.toutiao.com/2016/12/13/riotjs/" target="_blank" rel="external">头条PC站基于RIOT的组件化开发实践</a>  </li>
<li><a href="http://imweb.io/topic/573e766f1156025b1dce9404" target="_blank" rel="external">深入探讨前端UI框架</a>  </li>
<li><a href="https://gist.github.com/teabyii/7f6bddf5934915081c5d" target="_blank" rel="external">Riot 源码阅读笔记</a>  </li>
<li><a href="https://github.com/riot/riot/blob/7fe907d161731568c4d7755ab05493ddec12c6fd/lib/browser/tag" target="_blank" rel="external">Riot.js 源代码</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" target="_blank" rel="external">MVC，MVP 和 MVVM 的图示</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;riot-组件&quot;&gt;&lt;a href=&quot;#riot-组件&quot; class=&quot;headerlink&quot; title=&quot;riot 组件&quot;&gt;&lt;/a&gt;riot 组件&lt;/h1&gt;&lt;p&gt;使用 riot 编写组件是以 .tag 后缀结尾的文件，我们的 html, css, js 都可以放在里面。这些文件在编译阶段会被编译成对应的js代码(见&lt;a href=&quot;&quot;&gt;Riot.js 源码解析 【一】 基础内容&lt;/a&gt;)。每个组件都是一个 Tag 对象(代码在 /tag/tag.js 里面)，里面包含了对象的各种属性和方法。本文主要介绍，riot 组件的生命周期，更新原理(一个粗粒度的 virtual dom)以及简单更新优化手段。&lt;br&gt;
    
    </summary>
    
      <category term="前端源码解析" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="前端源码解析" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Riot.js" scheme="http://yoursite.com/tags/Riot-js/"/>
    
  </entry>
  
  <entry>
    <title>Riot.js 源码解析 【一】 基础内容</title>
    <link href="http://yoursite.com/2017/09/21/riot-js-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%901/"/>
    <id>http://yoursite.com/2017/09/21/riot-js-源码解析1/</id>
    <published>2017-09-21T14:36:37.000Z</published>
    <updated>2017-10-18T07:14:27.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Simple and elegant component-based UI library (Riot.js)    </p>
</blockquote>
<p>riot.js 是一个简单优雅的 js UI框架。具有自定义标签，简单语法，API简单，体积小，学习成本低等特点。riot.js 使用Model-View-Presenter (MVP)设计模式来组织代码，这样它能够更模块化、更具可测试性且易于理解。riot.js 仅仅提供了帮助UI渲染相关的基础功能，并不具备其它复杂的功能，因此其体积很小，压缩后仅有 10.39KB (react.min.js 大约 47.6KB )，很适合组件类的业务开发。<br>目前今日头条PC站，百度Hi的JS组件部分都是基于riot.js来开发的。<br>本系列文章，将会在介绍 riot.js 的使用方法的同时，解析其对应的源码内容，riot.js 版本为3.6.1。<br><a id="more"></a></p>
<h1 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h1><p>来一个简单的例子，基于 webpack 构建，依赖 riotjs-loader。<br>自定义标签代码，content-demo.tag   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> riot <span class="keyword">from</span> <span class="string">'riot'</span>;</div><div class="line">&lt;content-demo&gt; </div><div class="line">    &lt;style&gt;</div><div class="line">        h1 &#123;</div><div class="line">            color: pink;</div><div class="line">        &#125;</div><div class="line">    &lt;<span class="regexp">/style&gt;</span></div><div class="line"><span class="regexp">    &lt;h1&gt;&#123; message &#125;&lt;/</span>h1&gt;</div><div class="line">    &lt;ul&gt;</div><div class="line">        &lt;li each=&#123; lists &#125;&gt;&#123; name &#125;&lt;<span class="regexp">/li&gt;</span></div><div class="line"><span class="regexp">        &lt;script&gt;</span></div><div class="line"><span class="regexp">            this.message = 'hello world';</span></div><div class="line"><span class="regexp">            this.lists = [</span></div><div class="line"><span class="regexp">                &#123;</span></div><div class="line"><span class="regexp">                    'name': 'caelumtian'</span></div><div class="line"><span class="regexp">                &#125;,</span></div><div class="line"><span class="regexp">                &#123;</span></div><div class="line"><span class="regexp">                    'name': 'hyang'</span></div><div class="line"><span class="regexp">                &#125;</span></div><div class="line"><span class="regexp">            ]</span></div><div class="line"><span class="regexp">        &lt;/</span>script&gt;</div><div class="line">    &lt;<span class="regexp">/ul&gt;</span></div><div class="line"><span class="regexp">&lt;/</span>content-demo&gt;</div></pre></td></tr></table></figure>
<p>html 页面代码如下：  </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">content-demo</span>&gt;</span><span class="tag">&lt;/<span class="name">content-demo</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./dist/bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure>
<p>webpack 入口js文件    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> riot <span class="keyword">from</span> <span class="string">'riot'</span>;</div><div class="line"><span class="keyword">import</span> <span class="string">'./tags/content-demo.tag'</span>;</div><div class="line">riot.mount(<span class="string">'*'</span>);</div></pre></td></tr></table></figure>
<p>总体来说，riot.js 采用自定义标签的方式来书写UI组件，组件的生命周期仅有 update,updated,mount,unmount 四个。我们通过调用 riot.mount() 函数来决定页面加载哪些组件。  </p>
<h1 id="riot-js-运行流程"><a href="#riot-js-运行流程" class="headerlink" title="riot.js 运行流程"></a>riot.js 运行流程</h1><p>在上述 demo 中，我们将 <code>&lt;content-demo&gt;</code> 自定义标签写在了 *.tag 格式的文件中，作为一个组件。然后 webpack 打包时会利用 riot-compiler(官方编译工具)，将其编译成 js 代码 riot.tag2()，然后将其内容注册在<code>__TAG_IMPL</code>变量中。 最后用户调用 <code>riot.mount()</code> 函数来指定渲染哪个组件。运行流程，如下图所示：    </p>
<img src="/2017/09/21/riot-js-源码解析1/a.png" alt="a.png" title="">  
<h2 id="自定义标签命名"><a href="#自定义标签命名" class="headerlink" title="自定义标签命名"></a>自定义标签命名</h2><p>riot.js 对自定义标签的书写本身没有任何要求，但是 HTML5 引入了对自定义元素的标准 - <a href="https://w3c.github.io/webcomponents/spec/custom/#custom-elements" target="_blank" rel="external">Custom Elements 标准</a>。标准中对自定义元素名称有了限制：  </p>
<blockquote>
<p>“自定义元素的名字必须包含一个破折号（-）所以 <code>&lt;x-tags&gt;</code>、<code>&lt;my-element&gt;</code>和<code>&lt;my-awesome-app&gt;</code>都是正确的名字，而<tabs>和<foo_bar>是不正确的。这样的限制使得 HTML 解析器可以分辨那些是标准元素，哪些是自定义元素。”   </foo_bar></tabs></p>
</blockquote>
<p>距离来说，如果你的标签名称不带有破折号，那么浏览器会认为自定义元素是 <code>HTMLUnKnownElement</code>，如图所示：  </p>
<img src="/2017/09/21/riot-js-源码解析1/b.png" alt="b.png" title="">    
<p>所以，这里推荐在使用 riot.js 自定义标签的时候，遵守带有破折号的命名方式。  </p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>编译阶段的主要工作就是将riot语法写的<code>.tag</code>文件转换为可执行的.js文件，这部分主要靠编译器来完成。例子中，content-demo 最终会被编译成如下js代码：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">riot.tag2(<span class="string">'content-demo'</span>, <span class="string">'&lt;h1&gt;&#123;message&#125;&lt;/h1&gt; &lt;ul&gt; &lt;li each="&#123;lists&#125;"&gt;&#123;name&#125;&lt;/li&gt; &lt;/ul&gt;'</span>, <span class="string">'content-demo h1,[data-is="content-demo"] h1&#123; color: pink; &#125;'</span>, <span class="string">''</span>, <span class="function"><span class="keyword">function</span> (<span class="params">opts</span>) </span>&#123;</div><div class="line">	<span class="keyword">this</span>.message = <span class="string">'hello world'</span>;</div><div class="line">	<span class="keyword">this</span>.lists = [&#123;</div><div class="line">	    <span class="string">'name'</span>: <span class="string">'caelumtian'</span></div><div class="line">	&#125;, &#123;</div><div class="line">	    <span class="string">'name'</span>: <span class="string">'hyang'</span></div><div class="line">	&#125;];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>riot.tag2 函数在 riot.js 源码中的 core.js 文件中，代码如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">tag2</span>(<span class="params">name, tmpl, css, attrs, fn</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (css) styleManager.add(css, name)</div><div class="line">    <span class="comment">// tags implementation cache 标签接口缓存</span></div><div class="line">    __TAG_IMPL[name] = &#123;</div><div class="line">        name,</div><div class="line">        tmpl,</div><div class="line">        attrs,</div><div class="line">        fn</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> name</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参数含义如下：  </p>
<ul>
<li>name: riot 自定义标签的名称</li>
<li>tmpl: 标签的html内容</li>
<li>css: <code>&lt;style&gt;</code> 标签中的内容</li>
<li>attrs: riot 自定义标签的属性</li>
<li>fn: 用户自定义函数,即 <code>&lt;script&gt;</code> 标签中的内容  </li>
</ul>
<p><code>riot.tag2()</code> 函数将 riot tag 注册到了 <code>__TAG_IMP</code> 对象中，方便之后的使用，css部分则被添加到了 <code>byName</code> 变量中，用于之后统一添加到页面中。在源代码中，还有一个 <code>riot.tag()</code>函数，这个函数用于直接直接创建一个 riot tag 实例的接口，而 <code>riot.tag2()</code> 是暴露给编辑器的接口，本质上功能是一样的。</p>
<h2 id="加载-riot-mount"><a href="#加载-riot-mount" class="headerlink" title="加载 riot.mount()"></a>加载 riot.mount()</h2><p>组件被注册号以后，并没有被渲染，直到我们调用 <code>riot.mount()</code> 函数后，相应的组件才会渲染到页面上。riot.mount 主要用法如下：  </p>
<ul>
<li>riot.mount(‘*’, [opts]): 将注册好的所有 riot tag 都渲染到页面上</li>
<li>riot.mount(customTagSelector, [opts]): 根据标签选择器，渲染指定的 riot tag。 例如：上述示例中，我们也可以这样写 riot.mount(‘content-demo’)。  </li>
<li>riot.mount(selector, tagName, [opts]): 将 riot tag 渲染到指定的节点中。例如： riot.mount(“div#main”, “content-demo”, api)   将 <code>&lt;my-tag&gt;</code>挂载到 <code>div#main</code> 内。  </li>
</ul>
<p>这里面的 opts 为可选参数，是用户设置的标签的其他属性内容。这里就不过多介绍了，之后的文章会有解释。下面为 riot.mount 注释过的源码：      </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params">selector, tagName, opts</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> tags = []</div><div class="line">    <span class="keyword">let</span> elem, allTags</div><div class="line">    <span class="comment">// root &#123;HTMLElement&#125; riot-tag 标签节点</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">pushTagsTo</span>(<span class="params">root</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root.tagName) &#123;</div><div class="line">            <span class="keyword">let</span> riotTag = getAttr(root, IS_DIRECTIVE),    <span class="comment">// 要么 data-is 要么 root.tagName 本身</span></div><div class="line">                tag</div><div class="line">            <span class="comment">// ① 设置 data-is 属性指向</span></div><div class="line">            <span class="keyword">if</span> (tagName &amp;&amp; riotTag !== tagName) &#123;</div><div class="line">                riotTag = tagName</div><div class="line">                setAttr(root, IS_DIRECTIVE, tagName)</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// ② mountTo 创建一个新的 riot tag 实例</span></div><div class="line">            tag = mountTo(root, riotTag || root.tagName.toLowerCase(), opts)</div><div class="line">            <span class="keyword">if</span> (tag)</div><div class="line">                tags.push(tag)</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.length)</div><div class="line">            each(root, pushTagsTo)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// DOM 注入 style 标签</span></div><div class="line">    styleManager.inject()</div><div class="line">    <span class="keyword">if</span> (isObject(tagName)) &#123;</div><div class="line">        opts = tagName</div><div class="line">        tagName = <span class="number">0</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (isString(selector)) &#123;</div><div class="line">        selector = selector === <span class="string">'*'</span> ?</div><div class="line">            allTags = selectTags() :</div><div class="line">            selector + selectTags(selector.split(<span class="regexp">/, */</span>))</div><div class="line">        <span class="comment">// ③ 利用 $$ 来判断 这些 tag 是否已经挂载在 html 上面</span></div><div class="line">        elem = selector ? $$(selector) : []</div><div class="line">    &#125; <span class="keyword">else</span></div><div class="line">        elem = selector</div><div class="line">    <span class="comment">// 将所有元素挂载在根元素中</span></div><div class="line">    <span class="keyword">if</span> (tagName === <span class="string">'*'</span>) &#123;</div><div class="line">        tagName = allTags || selectTags()</div><div class="line">        <span class="keyword">if</span> (elem.tagName)</div><div class="line">            <span class="comment">// 查找elem下的 tagName</span></div><div class="line">            elem = $$(tagName, elem)</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 将查找到的所有节点都 放入 nodeList中</span></div><div class="line">            <span class="keyword">var</span> nodeList = []</div><div class="line">            each(elem, _el =&gt; nodeList.push($$(tagName, _el)))</div><div class="line">            elem = nodeList</div><div class="line">        &#125;</div><div class="line">        tagName = <span class="number">0</span></div><div class="line">    &#125;</div><div class="line">    pushTagsTo(elem)</div><div class="line">    <span class="keyword">return</span> tags</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当调用 riot.mount 后，通过 selector 参数来查找 html 页面上对应的节点。<code>不在 html 上的节点是不会被渲染的</code>。③处代码为查找过程，其中$$为 <code>document.querySelectAll</code>。之后调用 pushTagsTo 函数来渲染 riot tag。<br><code>IS_DIRECTIVE = &#39;data-is&#39;</code> 渲染前，要检查是否含有 tagName 参数，如果有的话即为 上述 riot.mount 的第三个用法。此时需要检测 root 的 data-is 属性值是否和 tagName 相等，如①处。不相等则将 root 设置其 data-is 为 tagName。即 riot.mount(‘div#main’, ‘content-demo’) 渲染出的节点为 :  </p>
<blockquote>
<p><code>&lt;div id=&quot;main&quot; data-is=&quot;content-demo&quot;&gt;&lt;content-demo&gt;...&lt;/content-demo&gt;&lt;/div&gt;</code> </p>
</blockquote>
<p>最后，通过 mountTo 函数渲染处理好的 riot tag，如②处。mountTo 函数后续会有详解。  </p>
<blockquote>
<p>代码中使用了 tagName 而不是 nodeName 原因如下：nodeName是node 接口上的property，而tagName是element 接口上的property，所有的节点（元素节点，属性节点，文本节点等12种）都继承了node接口，而只有元素节点才继承了element节点。  </p>
</blockquote>
<h2 id="取消注册-riot-unregister"><a href="#取消注册-riot-unregister" class="headerlink" title="取消注册 riot.unregister()"></a>取消注册 riot.unregister()</h2><p>riot 全局变量上还包含 riot.unregister(name) 函数用户取消注册过的内容，通常我们在测试程序的时候，创建同名标签使用。示例如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个测试标签</span></div><div class="line">riot.tag(<span class="string">'test-tag'</span>, <span class="string">'&lt;p&gt;&#123; message &#125;&lt;/p&gt;'</span>)</div><div class="line"><span class="comment">// 注册标签</span></div><div class="line"><span class="keyword">var</span> tag = riot.mount(<span class="built_in">document</span>.createElement(<span class="string">'div'</span>), <span class="string">'test-tag'</span>)[<span class="number">0</span>]</div><div class="line">expect(tag.root.querySelector(<span class="string">'p'</span>)).to.be.ok</div><div class="line"><span class="comment">// 取消注册</span></div><div class="line">riot.unregister(<span class="string">'test-tag'</span>)</div><div class="line"><span class="comment">// 重新创建一个同名，但是不一样的标签</span></div><div class="line">riot.tag(<span class="string">'test-tag'</span>, <span class="string">'&lt;div&gt;&#123; message &#125;&lt;/div&gt;'</span>)</div></pre></td></tr></table></figure>
<p>riot.unregister() 源码十分简单，如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">unregister</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    __TAG_IMPL[name] = <span class="literal">null</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>暴露在 riot 全局变量上的函数，还包括 <code>riot.update</code> 和 <code>riot.mixin</code> 两个，将在后面的内容介绍。  </p>
<h1 id="源码目录结构"><a href="#源码目录结构" class="headerlink" title="源码目录结构"></a>源码目录结构</h1><p>riot 3.6.1 的源码目录结构如下：</p>
<pre><code>|____browser
| |____common
| | |____global-variables.js // 使用到的常量
| | |____util                    
| | | |____check.js   // 变量类型，属性等检查
| | | |____dom.js     // dom 操作
| | | |____misc.js    // 用到的工具类函数
| | | |____tags.js    // riot tag 操作      
| |____compiler
| | |____index.js     // riot tag 模板解析
| |____tag
| | |____core.js      // riot 对外暴露函数接口
| | |____each.js      // riot tag each操作渲染
| | |____if.js        // riot tag if操作渲染
| | |____mkdom.js     // 创建 dom 节点
| | |____parse.js     // riot tag 解析
| | |____ref.js       // riot tag ref
| | |____setEventHandler.js  // riot tag 事件绑定
| | |____styleManager.js     // 样式管理
| | |____tag.js              // riot tag 标签类
|___|____update.js           // riot tag 更新操作
</code></pre><p>本文涉及到的源码，主要出自 <code>core.js</code> 和 <code>styleManager.js</code>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Simple and elegant component-based UI library (Riot.js)    &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;riot.js 是一个简单优雅的 js UI框架。具有自定义标签，简单语法，API简单，体积小，学习成本低等特点。riot.js 使用Model-View-Presenter (MVP)设计模式来组织代码，这样它能够更模块化、更具可测试性且易于理解。riot.js 仅仅提供了帮助UI渲染相关的基础功能，并不具备其它复杂的功能，因此其体积很小，压缩后仅有 10.39KB (react.min.js 大约 47.6KB )，很适合组件类的业务开发。&lt;br&gt;目前今日头条PC站，百度Hi的JS组件部分都是基于riot.js来开发的。&lt;br&gt;本系列文章，将会在介绍 riot.js 的使用方法的同时，解析其对应的源码内容，riot.js 版本为3.6.1。&lt;br&gt;
    
    </summary>
    
      <category term="前端源码解析" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="前端源码解析" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Riot.js" scheme="http://yoursite.com/tags/Riot-js/"/>
    
  </entry>
  
  <entry>
    <title>js增量更新算法研究</title>
    <link href="http://yoursite.com/2017/09/18/js%E5%A2%9E%E9%87%8F%E6%9B%B4%E6%96%B0%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6/"/>
    <id>http://yoursite.com/2017/09/18/js增量更新算法研究/</id>
    <published>2017-09-18T03:42:55.000Z</published>
    <updated>2017-09-28T08:21:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="serviceWorker-方案-js增量更新算法研究"><a href="#serviceWorker-方案-js增量更新算法研究" class="headerlink" title="serviceWorker 方案 - js增量更新算法研究"></a>serviceWorker 方案 - js增量更新算法研究</h1><h2 id="调研背景"><a href="#调研背景" class="headerlink" title="调研背景"></a>调研背景</h2><blockquote>
<p>根据之前 serviceWorker 的调研，当服务端文件更新后，serviceWorker 会做对比，并请求这些新的文件。所有发生变化的文件都会被更新。现在 new-mini 内嵌页面，js 都被压缩成了一个文件。这样每次很小的文件改动，都会导致客户端需要下载整个js文件，这样会造成流量的浪费，同时也对服务器造成过大的流量压力。为此我们需要减少更新文件的体积，来更好的完成 serviceWorker 的架构。  </p>
</blockquote>
<a id="more"></a>
<h2 id="js-增量更新算法"><a href="#js-增量更新算法" class="headerlink" title="js 增量更新算法"></a>js 增量更新算法</h2><p>利用增量更新算法，我们大大的降低每次文件变动后传输的大小。这里调研了4中常见的js 增量更新算法：  </p>
<h3 id="基于chunk的增量更新算法"><a href="#基于chunk的增量更新算法" class="headerlink" title="基于chunk的增量更新算法"></a>基于chunk的增量更新算法</h3><p>首先将旧的文件分成n块并并编号<br><img src="/2017/09/18/js增量更新算法研究/a.png" alt="a.png" title=""><br>然后在新文件上进行，滚动查找。如果找到匹配的则记录块号，如果没找到则块往前移动 1 个字符，并把上个字符压入新数据块,然后扫描下一块，最终得到一个新数据和数据块号的组合的增量文件（这一步可以用上线 JavaScript 时用的打包工具或者请求 JavaScript 服务器程序实时计算出来）。<br><img src="/2017/09/18/js增量更新算法研究/b.png" alt="b.png" title=""><br>最终得到的增量文件如下所示：  </p>
<blockquote>
<p>1, data1, 2, 3, data2, 4, 5, 6  </p>
</blockquote>
<p>进一步合并顺序快得到：  </p>
<blockquote>
<p>[1, 1], data1, [2, 2], data2, [4, 4]  </p>
</blockquote>
<p>客户端根据旧文件的 chunk 数据和增量更新数据，我们可以得出新版本数据由如下数据组成：  </p>
<blockquote>
<p>chunk0+data1+chunk1+chunk2+data2+chunk3+chunk4+chunk5  </p>
</blockquote>
<p>例如以 s = ‘‘1345678abcdefghijklmnopq’ 修改为 a = ‘‘13456<code>f</code>78abcd<code>2</code>efghijklmnopq’为例, 设块长度为4 则， 源文件分成：<br><br>通过滚动查找，得到新文件<br><br>最终增量文件表示如下数组: [“a=‘1”,2,”f”,3,”cd2ef”,5,6,7]。 进一步合并顺序块，可用一个js数组表示为： [“a=‘1”,[2,1],“f”,[3,1],“cd2ef”,[5,3]。<br>在 serviceWorker 客户端这边，调用如下函数，进行文件更新：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//source 是上一个版本内容，trunkSize 是块大小，checksumcode 是两个版本间的增量文件数组</span></div><div class="line"><span class="keyword">var</span> rsyncjs = <span class="function"><span class="keyword">function</span>(<span class="params">source,trunkSize,checksumcode</span>)</span>&#123;</div><div class="line">   <span class="keyword">var</span> strResult=<span class="string">""</span>;</div><div class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; checksumcode.length; i++)&#123;</div><div class="line">       <span class="keyword">var</span> code = checksumcode[i];</div><div class="line">       <span class="keyword">if</span>(<span class="keyword">typeof</span> code === <span class="string">'string'</span>)&#123;</div><div class="line">            strResult+=code;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">var</span> start = code[<span class="number">0</span>] * trunkSize;</div><div class="line">            <span class="keyword">var</span> len = code[<span class="number">1</span>] * trunkSize;</div><div class="line">            <span class="keyword">var</span> oldcode = source.substr(start, len);</div><div class="line">            strResult += oldcode;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> strResult;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法存在的问题为：增量更新的精确度依赖于chunk的大小，在实际使用中总是会有不少代码需要冗余下载。  </p>
<h3 id="Myer’s-diff-algorithm"><a href="#Myer’s-diff-algorithm" class="headerlink" title="Myer’s diff algorithm"></a>Myer’s diff algorithm</h3><p>Myer’s diff algorithm 首次出是在1986年一篇论文中<a href="https://neil.fraser.name/software/diff_match_patch/myers.pdf" target="_blank" rel="external">“An O(ND) Difference Algorithm and Its Variations”</a>, 在文中实现上介绍了两种此diff算法 的实现。两种实现的核心思想是一致的，只是在具体的实现过程中，为进一步提升算法的性能及空间利用率，采取了不一致的迭代方式。<br>算法原理比较复杂，github 上有根据该算法实现的 <a href="https://github.com/kpdecker/jsdiff" target="_blank" rel="external">jsdiff 插件</a><br>简单的演示如下：   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>(<span class="string">'colors'</span>);</div><div class="line"><span class="keyword">let</span> jsdiff = <span class="built_in">require</span>(<span class="string">'diff'</span>);</div><div class="line"><span class="keyword">let</span> oldStr = <span class="string">'bcdsgaff2 123'</span>;</div><div class="line"><span class="keyword">let</span> newStr = <span class="string">'accdgadff2 42356'</span>;</div><div class="line"><span class="keyword">let</span> diff = jsdiff.diffChars(oldStr, newStr);</div><div class="line"><span class="built_in">console</span>.log(diff);</div><div class="line">diff.forEach(<span class="function"><span class="params">part</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> color = part.added ? <span class="string">'green'</span> : part.removed ? <span class="string">'red'</span> : <span class="string">'gray'</span>;</div><div class="line">    process.stderr.write(part.value[color]); </div><div class="line">&#125;) </div><div class="line"><span class="string">``</span><span class="string">`    </span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">&#123;% asset_img 5.png %&#125;  </span></div><div class="line"><span class="string">可以清楚的看到差异信息，这里我们利用下面这个函数 简化一下jsdiff输出信息，方便传输。    </span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">`</span><span class="string">``</span>javascript  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">minimizeDiffInfo</span>(<span class="params">originalInfo</span>)</span>&#123;</div><div class="line">    <span class="keyword">let</span> result = originalInfo.map(<span class="function"><span class="params">info</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">if</span>(info.added)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">'+'</span> + info.value;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(info.removed)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">'-'</span> + info.count;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> info.count;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(result);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果为：<br><img src="/2017/09/18/js增量更新算法研究/6.png" alt="6.png" title=""><br>客户端，采用如下函数，更新 serviceWorker 中的资源：  </p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">mergeDiff</span>(<span class="params">oldString, diffInfo</span>)</span>{
    <span class="keyword">let</span> newString = <span class="string">''</span>;
    <span class="keyword">let</span> diffInfo = <span class="built_in">JSON</span>.parse(diffInfo);
    <span class="keyword">let</span> index = <span class="number">0</span>;
    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; diffInfo.length; i++){
        <span class="keyword">let</span> info = diffInfo[i];
        <span class="keyword">if</span>(<span class="keyword">typeof</span> info === <span class="string">'number'</span>){
            newString += oldString.slice(index, index + info);
            index += info;
            <span class="keyword">continue</span>;
        }
        <span class="keyword">if</span>(<span class="keyword">typeof</span> info === <span class="string">'string'</span>){
            <span class="keyword">if</span>(info[<span class="number">0</span>] === <span class="string">'+'</span>){
                <span class="keyword">let</span> addedString = info.slice(<span class="number">1</span>, info.length);
                newString += addedString;
            }
            <span class="keyword">if</span>(info[<span class="number">0</span>] === <span class="string">'-'</span>){
                <span class="keyword">let</span> removedCount = <span class="built_in">parseInt</span>(info.slice(<span class="number">1</span>, info.length));
                index += removedCount;
            }
        }
    }
    <span class="keyword">return</span> newString;
}
</code></pre>
<p>该方案，实际测试结果很糟糕，对于文件很大的内容比对时间都够我睡一觉了。    </p>
<h2 id="基于编辑距离的比对算法"><a href="#基于编辑距离的比对算法" class="headerlink" title="基于编辑距离的比对算法"></a>基于编辑距离的比对算法</h2><h3 id="什么是编辑距离"><a href="#什么是编辑距离" class="headerlink" title="什么是编辑距离"></a>什么是编辑距离</h3><blockquote>
<p>编辑距离是针对二个字符串（例如英文字）的差异程度的量化量测，量测方式是看至少需要多少次的处理才能将一个字符串变成另一个字符串。编辑距离可以用在自然语言处理中，例如拼写检查可以根据一个拼错的字和其他正确的字的编辑距离，判断哪一个（或哪几个）是比较可能的字。DNA也可以视为用A、C、G和T组成的字符串，因此编辑距离也用在生物信息学中，判断二个DNA的类似程度。Unix 下的 diff 及 patch 即是利用编辑距离来进行文本编辑对比的例子。  </p>
</blockquote>
<h4 id="求解算法"><a href="#求解算法" class="headerlink" title="求解算法"></a>求解算法</h4><p>比如要计算cafe和coffee的编辑距离。cafe→caffe→coffe→coffee。先创建一个6×8的表（cafe长度为4，coffee长度为6，各加2):<br><img src="/2017/09/18/js增量更新算法研究/8.png" alt="8.png" title=""><br>接着，在如下位置添加数字<br><img src="/2017/09/18/js增量更新算法研究/9.png" alt="9.png" title=""><br>从3,3格开始，开始计算。取以下三个值的最小值：    </p>
<ul>
<li>如果最上方的字符等于最左方的字符，则为左上方的数字。否则为左上方的数字+1。（对于3,3来说为0）</li>
<li>左方数字+1（对于3,3格来说为2）</li>
<li>上方数字+1（对于3,3格来说为2）  </li>
</ul>
<p>因此为格3,3为0:<br><img src="/2017/09/18/js增量更新算法研究/10.png" alt="10.png" title=""><br>循环操作，推出下表：<br><img src="/2017/09/18/js增量更新算法研究/11.png" alt="11.png" title=""><br>取右下角，得编辑距离为3。   </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;serviceWorker-方案-js增量更新算法研究&quot;&gt;&lt;a href=&quot;#serviceWorker-方案-js增量更新算法研究&quot; class=&quot;headerlink&quot; title=&quot;serviceWorker 方案 - js增量更新算法研究&quot;&gt;&lt;/a&gt;serviceWorker 方案 - js增量更新算法研究&lt;/h1&gt;&lt;h2 id=&quot;调研背景&quot;&gt;&lt;a href=&quot;#调研背景&quot; class=&quot;headerlink&quot; title=&quot;调研背景&quot;&gt;&lt;/a&gt;调研背景&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;根据之前 serviceWorker 的调研，当服务端文件更新后，serviceWorker 会做对比，并请求这些新的文件。所有发生变化的文件都会被更新。现在 new-mini 内嵌页面，js 都被压缩成了一个文件。这样每次很小的文件改动，都会导致客户端需要下载整个js文件，这样会造成流量的浪费，同时也对服务器造成过大的流量压力。为此我们需要减少更新文件的体积，来更好的完成 serviceWorker 的架构。  &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[译] 使用Web Speech API和Node.js构建简单的AI Chatbot</title>
    <link href="http://yoursite.com/2017/09/02/%E8%AF%91-%E4%BD%BF%E7%94%A8WebSpeechAPI/"/>
    <id>http://yoursite.com/2017/09/02/译-使用WebSpeechAPI/</id>
    <published>2017-09-02T11:55:05.000Z</published>
    <updated>2017-09-22T07:09:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>随着语音技术的普及，越来越多的手机用户开始使用Siri和Cortana等语音助理软件。Amazon Echo和Google Home等语音软件同样走入了我们的日常生活。这些系统基于语音识别软件构建允许用户直接通过语音下达命令。现在，浏览器也已经支持了Web Speech API，它允许用户在web应用程序中集成语音数据。<br>基于现在的web应用程序，我们可以使用多种UI元素来和用户交互。使用Web Speech API，我们可以开发更加自然地小巧的web可视化界面。这样我们就能开发更丰富的web应用程序。此外，该API也可以帮助身体或认知障碍的人更好的访问web信息。<br><a id="more"></a>   </p>
<blockquote>
<p>增强用户体验<br>Web Speeh API可以使网站和Web app不仅仅可以交谈还可以聆听。这里有一些关于猪呢个条用户体验的很好的例子。<a href="https://www.smashingmagazine.com/2014/12/enhancing-ux-with-the-web-speech-api/" target="_blank" rel="external">阅读更多</a>  </p>
</blockquote>
<p>在本教程中，我们将使用API在浏览器中创建人工智能（AI）语音聊天界面。该应用将听取用户的声音并以合成语音回复。因为Web Speech API依然是实现性的，所以目前仅能支持在有限的浏览器中。本文使用的语音识别和语音合成功能目前仅基于Chromium浏览器，包括Chrome 25+和Opera 27+，而Firefox，Edge和Safari目前仅支持语音合成。    </p>
<img src="/2017/09/02/译-使用WebSpeechAPI/1.png" alt="1.png" title="">  
<img src="/2017/09/02/译-使用WebSpeechAPI/2.png" alt="2.png" title="">  
<p>要构建该程序，我们主要采取三个步骤：    </p>
<ol>
<li>使用Web Speech API的SpeechRecognition接口来聆听用户的语音  </li>
<li>将用户消息作为字符串文本发送给商业的自然语言处理API</li>
<li>一旦API.AI返回响应文本，我们就利用SpeechSynthesis接口返回给用户一个合成声音    </li>
</ol>
<img src="/2017/09/02/译-使用WebSpeechAPI/3.png" alt="3.png" title="">
<p>本教程使用的<a href="https://github.com/girliemac/web-speech-ai" target="_blank" rel="external">完整的源代码</a>在GitHub上。  </p>
<h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><p>本教程依赖于Node.js,你需要对JavaScript和Node.js有一定的了解并确保您的电脑上已经安装了Noded.js。  </p>
<h2 id="构建你的Node-js应用"><a href="#构建你的Node-js应用" class="headerlink" title="构建你的Node.js应用"></a>构建你的Node.js应用</h2><p>首先，让我们搭建一个Node.js的应用框架。创建你的应用目录，并设置如下的目录结构：   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">├── index.js</div><div class="line">├── public</div><div class="line">│   ├── css</div><div class="line">│   │   └── style.css</div><div class="line">│   └── js</div><div class="line">│       └── script.js</div><div class="line">└── views</div><div class="line">    └── index.html</div></pre></td></tr></table></figure>
<p>之后利用如下命令来初始化你的Node.js应用：  </p>
<blockquote>
<p>npm init -f    </p>
</blockquote>
<p>我们将使用Express(一个Node.js Web应用框架)来搭建本地服务。为了实现服务器和浏览器之间的双向通信，我们将使用Socket.IO。同时，我们还将使用自然语言处理工具API.AI，来构建可以人工交谈的AI聊天工具。<br>Socket.IO，能够让我们更方便的使用WebSocket。通过在客户端和服务端建立socket连接。当Web Speech API或API.AI 返回文本数据的时候，我们能将聊天信息在浏览器和服务器之间传递。<br>首先，我们创建index.js文件并实例化Express作为服务器：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</div><div class="line"><span class="keyword">const</span> app = express();</div><div class="line"></div><div class="line">app.use(express.static(__dirname + <span class="string">'/views'</span>)); <span class="comment">// html</span></div><div class="line">app.use(express.static(__dirname + <span class="string">'/public'</span>)); <span class="comment">// js, css, images</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> server = app.listen(<span class="number">5000</span>);</div><div class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</div><div class="line">  res.sendFile(<span class="string">'index.html'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>下一步，我们将Web Speech API集成到前端代码。  </p>
<h2 id="利用-SpeechRecognition-接口接收语音"><a href="#利用-SpeechRecognition-接口接收语音" class="headerlink" title="利用 SpeechRecognition 接口接收语音"></a>利用 SpeechRecognition 接口接收语音</h2><p>Web Speech API具有名为SpeechRecognition的接口，用来从麦克风中获取用户们的讲话并了解他们在说什么。 </p>
<h3 id="创建用户界面"><a href="#创建用户界面" class="headerlink" title="创建用户界面"></a>创建用户界面</h3><p>该程序的UI界面很简单，仅有一个按钮来触发语音识别。让我们创建一个index.html文件，其中包含js文件和Socket.IO，稍后我们将用它启动实时通讯：  </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span>…<span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    …</div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.0.1/socket.io.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/script.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>然后，在页面中加入按钮接口：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>Talk<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div></pre></td></tr></table></figure>
<p>要想查看按钮的样式，你何以查看<a href="https://github.com/girliemac/web-speech-ai" target="_blank" rel="external">源代码</a>中的style.css文件。  </p>
<h3 id="使用JavaScript捕获语音"><a href="#使用JavaScript捕获语音" class="headerlink" title="使用JavaScript捕获语音"></a>使用JavaScript捕获语音</h3><p>在script.js中，创建SpeechRecognition实例来识别语音： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> SpeechRecognition = <span class="built_in">window</span>.SpeechRecognition || <span class="built_in">window</span>.webkitSpeechRecognition;</div><div class="line"><span class="keyword">const</span> recognition = <span class="keyword">new</span> SpeechRecognition();</div></pre></td></tr></table></figure>
<p>我们使用了带有前缀和不带的两个对象做判断，因为Chrome当前支持带有前缀的API。<br>同时，我们在本教程中使用了一些ES6语法，包括const，箭头函数等等，他们都可以在支持语音接口的浏览器中使用。<br>你可以设置各种属性，来自定义语音识别：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">recognition.lang = <span class="string">'en-US'</span>;</div><div class="line">recognition.interimResults = <span class="literal">false</span>;</div></pre></td></tr></table></figure>
<p>之后，监听button UI的DOM节点的点击事件来启动语音识别：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.querySelector(<span class="string">'button'</span>).addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</div><div class="line">    recognition.start();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>一旦语音开始，我们就调用result事件，来获取语音文本：   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">recognition.addEventListener(<span class="string">'result'</span>, (e) =&gt; &#123;</div><div class="line">  <span class="keyword">let</span> last = e.results.length - <span class="number">1</span>;</div><div class="line">  <span class="keyword">let</span> text = e.results[last][<span class="number">0</span>].transcript;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Confidence: '</span> + e.results[<span class="number">0</span>][<span class="number">0</span>].confidence);</div><div class="line">  <span class="comment">// We will use the Socket.IO here later…</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这将返回一个包含结果的SpeechRecognitionResultList兑现，你可以在数组中检索文字信息。接下来我们使用Socket.IO来传递数据额给我们的服务器。</p>
<h2 id="Socket-IO做实时通讯"><a href="#Socket-IO做实时通讯" class="headerlink" title="Socket.IO做实时通讯"></a>Socket.IO做实时通讯</h2><p>Socket.IO是一个做实时通讯web应用的库。他可以实现web客户端和服务端之间的双向通讯。我们将使用它将语音结果传递给Node.js，将相应信息传回浏览器。<br>你也许会有疑虑为什么我们不使用简单的HTTP协议或者AJAX。你可以发送POST请求来传奇数据。但是我们通过Socket.IO来创建webscoket，是因为这是最好的实现双向通讯的解决方案。特别是服务器向浏览器发送数据，如果采用AJAX来实现我们就不得不再用轮训的方式： </p>
<img src="/2017/09/02/译-使用WebSpeechAPI/4.png" alt="4.png" title=""> 
<p>在script.js中实例化Socket.IO：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> socket = io();</div></pre></td></tr></table></figure>
<p>然后将下面这段代码加入到监听reuslt事件的回调函数中：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">socket.emit(<span class="string">'chat message'</span>, text);</div></pre></td></tr></table></figure>
<p>我们回到Node.js代码中，来接受这些文本并使用API来回复用户的消息。  </p>
<h2 id="从AI中获取回复"><a href="#从AI中获取回复" class="headerlink" title="从AI中获取回复"></a>从AI中获取回复</h2><p>许多平台提供的服务可以将带有自然语言处理的AI系统结合到项目中，包括IBM的Watson，微软的LUIS和Wit.ai。为了快速构建一个会话接口，我们使用API.AI。因为它提供了免费的开发者帐户，并允许我们使用其Web界面和Node.js库快速设置一个小型的系统。  </p>
<h3 id="设置API-AI"><a href="#设置API-AI" class="headerlink" title="设置API.AI"></a>设置API.AI</h3><p>首先创建一个账户和代理。更多内容可以参考<a href="https://docs.api.ai/docs/get-started" target="_blank" rel="external">入门指南</a>中的第一步。<br>然后，创建entities和intents。点击左侧菜单中的”Small Talk”，然后切换开关即可开启服务。  </p>
<img src="/2017/09/02/译-使用WebSpeechAPI/5.png" alt="5.png" title="">
<p>根据你的喜好，自定义API.AI接口的代理。  </p>
<h3 id="使用API-AI的Node-js-SDK"><a href="#使用API-AI的Node-js-SDK" class="headerlink" title="使用API.AI的Node.js SDK"></a>使用API.AI的Node.js SDK</h3><p>我们利用Node.js SDK来链接Node.js应用和API.AI。回到你的index.js文件中，利用你的access token来初始化API.AI：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> apiai = <span class="built_in">require</span>(<span class="string">'apiai'</span>)(APIAI_TOKEN);</div></pre></td></tr></table></figure>
<p>如果您只想在本地运行代码，可以在此处对API密钥进行编码。这里有多种方式来设置环境变量，我通常使用设置 .env 文件来包含变量信息。在GitHub源码中，我将包含凭证的信息文件添加到了.gitignroe中，你可以查看 <a href="https://github.com/girliemac/web-speech-ai/blob/master/.env_test" target="_blank" rel="external">.env-test</a> 文件来查看他是如何设置的。  </p>
<p>现在我么能使用服务端的Socket.IO来获取浏览器的结果。<br>一旦接收到消息，我们就用API.AI的API来检索并回复用户信息：    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">io.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">socket</span>) </span>&#123;</div><div class="line">    socket.on(<span class="string">'chat message'</span>, (text) =&gt; &#123;</div><div class="line">        <span class="comment">// Get a reply from API.AI</span></div><div class="line">        <span class="keyword">let</span> apiaiReq = apiai.textRequest(text, &#123;</div><div class="line">            sessionId: APIAI_SESSION_ID</div><div class="line">        &#125;);</div><div class="line">        apiaiReq.on(<span class="string">'response'</span>, (response) =&gt; &#123;</div><div class="line">            <span class="keyword">let</span> aiText = response.result.fulfillment.speech;</div><div class="line">            socket.emit(<span class="string">'bot reply'</span>, aiText); <span class="comment">// Send the result back to the browser!</span></div><div class="line">        &#125;);</div><div class="line">        apiaiReq.on(<span class="string">'error'</span>, (error) =&gt; &#123;</div><div class="line">            <span class="built_in">console</span>.log(error);</div><div class="line">        &#125;);</div><div class="line">        apiaiReq.end();</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>当API.AI返回结果时，使用Socket.IO socket.emit()将其发送回浏览器。  </p>
<h2 id="利用SpeechSynthesis接口来合成语音"><a href="#利用SpeechSynthesis接口来合成语音" class="headerlink" title="利用SpeechSynthesis接口来合成语音"></a>利用SpeechSynthesis接口来合成语音</h2><p>然我们再次回到script.js中，完成我们的应用！<br>创建一个语音合成器，这次我们使用SpeechSynthesis接口。该函数将接受字符串作为参数，并使浏览器能够说出文本：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">synthVoice</span>(<span class="params">text</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> synth = <span class="built_in">window</span>.speechSynthesis;</div><div class="line">    <span class="keyword">const</span> utterance = <span class="keyword">new</span> SpeechSynthesisUtterance();</div><div class="line">    utterance.text = text;</div><div class="line">    synth.speak(utterance);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该函数中，我们首先创建了一个API入口对象，window.speechSynthesis。这次我们没有在使用前缀，该API的支持度更高，许多浏览器已经移除了该前缀。<br>然后，我们创建一个SpeechSynthesisUtterance实例，并设置要合成语音的文本。你也可以设置其他属性，例如voice类型和操作系统支持的语音类型。<br>最后，我们使用SpeechSynthesis.speak()来是浏览器说话。现在，再次从Socket.IO获取服务器的响应。一旦接收到消息，请调用该功能。    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">socket.on(<span class="string">'bot reply'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">replyText</span>) </span>&#123;</div><div class="line">  synthVoice(replyText);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>至此我们完成了全部功能，你可以试试:  </p>
<img src="/2017/09/02/译-使用WebSpeechAPI/6.gif" alt="6.gif" title="">
<p>请注意，浏览器在首次的时候会询问你是否使用麦克风。像其他Web API（如Geolocation API和Notification API）一样，除非你授予它，否则浏览器将永远不会访问您的敏感信息，因此你的声音不会在不知情的情况下被秘密记录。<br>API.AI是可配置和可训练的。阅读API.AI文档，使其更加智能。   </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>本教程仅涵盖了API的核心功能，但该API实际上是非常灵活和可自定义的。您可以改变识别语言，合成语音，包括口音（如美国或英国英语），语音音调和语速。你可以在这里了解有关API的更多信息：   </p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Speech_API" target="_blank" rel="external">Web Speech API</a> Mozilla Developer Network</li>
<li><a href="https://dvcs.w3.org/hg/speech-api/raw-file/tip/speechapi.html" target="_blank" rel="external">Web Speech API Specification</a> W3C</li>
<li><a href="https://docs.microsoft.com/en-us/microsoft-edge/dev-guide/multimedia/web-speech-api" target="_blank" rel="external">Web Speech API: Speech Synthesis</a> (Microsoft Edge documentation) Microsoft  </li>
</ul>
<p>自然语言处理工具你可以参考如下：  </p>
<ul>
<li><a href="https://api.ai/" target="_blank" rel="external">API.AI</a> Google</li>
<li><a href="https://wit.ai/" target="_blank" rel="external">Wit.ai</a> Facebook</li>
<li><a href="https://www.luis.ai/" target="_blank" rel="external">LUIS</a> Microsoft</li>
<li><a href="https://www.ibm.com/watson/" target="_blank" rel="external">Watson</a> IBM</li>
<li><a href="https://aws.amazon.com/cn/lex/" target="_blank" rel="external">Lex</a> Amazon</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着语音技术的普及，越来越多的手机用户开始使用Siri和Cortana等语音助理软件。Amazon Echo和Google Home等语音软件同样走入了我们的日常生活。这些系统基于语音识别软件构建允许用户直接通过语音下达命令。现在，浏览器也已经支持了Web Speech API，它允许用户在web应用程序中集成语音数据。&lt;br&gt;基于现在的web应用程序，我们可以使用多种UI元素来和用户交互。使用Web Speech API，我们可以开发更加自然地小巧的web可视化界面。这样我们就能开发更丰富的web应用程序。此外，该API也可以帮助身体或认知障碍的人更好的访问web信息。&lt;br&gt;
    
    </summary>
    
      <category term="翻译文章" scheme="http://yoursite.com/categories/%E7%BF%BB%E8%AF%91%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>图片惰性加载 IntersectionObserver</title>
    <link href="http://yoursite.com/2017/08/28/%E5%9B%BE%E7%89%87%E6%83%B0%E6%80%A7%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2017/08/28/图片惰性加载的实现/</id>
    <published>2017-08-28T12:41:11.000Z</published>
    <updated>2017-09-22T07:14:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于惰性加载"><a href="#关于惰性加载" class="headerlink" title="关于惰性加载"></a>关于惰性加载</h2><p>惰性加载又称为延迟加载、懒加载等，’lazyload’，即在长网页中延迟加载图像。当图片未到达可视区域时，不加载图片。如下图所示：  </p>
<img src="/2017/08/28/图片惰性加载的实现/1.gif" alt="1.gif" title="">  
<p>优点：提升用户的体验，如果图片数量较大，打开页面的时候要将将页面上所有的图片全部获取加载，很可能会出现卡顿现象，影响用户体验。因此，有选择性地请求图片，这样能明显减少了服务器的压力和流量，也能够减小浏览器的负担。<br><a id="more"></a>  </p>
<h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><p>惰性加载可以说在很久之前就已经出现了，实现方案也很简单。  </p>
<ul>
<li>在 HTML 文件中将需要惰性加载的图片的 src 属性置为一个相同的地址（一般设置为一张 loading 图），这样这张图只会加载一次（第二次即会读取缓存），或者干脆置为空（用户体验不好），将真实的图片地址存储在别的属性中（比如 data-src 属性)  </li>
<li>监听事件（比如 scroll 事件），判断需要惰性加载的图片是否已经在可视区域，如果是，则将 src 属性替换成 data-src 属性值  </li>
</ul>
<p>方案中，我们主要实现的功能有：判断图片和视口的位置关系，主要判断函数如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 比较元素位置 d2, 在d1中</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">_compareOffset</span>(<span class="params">d1, d2</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> left = d2.right &gt; d1.left &amp;&amp; d2.left &lt; d1.right;</div><div class="line">    <span class="keyword">let</span> top = d2.bottom &gt; d1.top &amp;&amp; d2.top &lt; d1.bottom;</div><div class="line">    <span class="keyword">return</span> left &amp;&amp; top;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>图片的坐标大小信息我们可以通过 <code>getBoundingClientRect</code> 来获得，浏览器窗口信息则为：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> w = &#123;</div><div class="line">    t = <span class="number">0</span>,</div><div class="line">    l = <span class="number">0</span>,</div><div class="line">    r = l + <span class="built_in">window</span>.innerWidth,</div><div class="line">    b = t + <span class="built_in">window</span>.innerHeight</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>剩下的只要监听 <code>scroll</code> 事件，对所有的 img.lazy-load 元素判断就好了。  </p>
<h2 id="监听-scroll-存在的性能问题"><a href="#监听-scroll-存在的性能问题" class="headerlink" title="监听 scroll 存在的性能问题"></a>监听 scroll 存在的性能问题</h2><p>当我们监听 scroll 事件的时候，页面滚动会导致该事件频繁出发，这对浏览器的性能产生很大的影响。为此我们可以加入函数节流(throttle)或函数去抖(debounce)来处理  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> _throttle = <span class="function">(<span class="params">func, wait, mustRunDelay = <span class="literal">Infinity</span></span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> timeout = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">let</span> start_time;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">let</span> context = <span class="keyword">this</span>,</div><div class="line">            args = <span class="built_in">arguments</span>,</div><div class="line">            curr_time = +<span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">        clearTimeout(timeout);</div><div class="line">        <span class="keyword">if</span>(!start_time) &#123;</div><div class="line">            start_time = curr_time;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(curr_time - start_time &gt;= mustRunDelay) &#123;</div><div class="line">            func.apply(context, args);</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                func.apply(context, args);</div><div class="line">            &#125;, wait);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>wait</code> 即判断的间隔事件，我们通常设置成 100ms 就可以不影响用户的体验。如果你想进一步提升图片加载性能我们也可以指定的将某些图片，base64 后存入 <code>localStorage</code> 中，等以后打开的时候，首先判断 <code>localStorage</code> 中是否有图片缓存，没有则去请求。这样就可以进一步加快图片的载入速度。  </p>
<p>完整的代码，可以查看 <a href="https://github.com/T-phantom/si-img" target="_blank" rel="external">si-img 图片优化组件</a>  </p>
<h2 id="IntersectionObserver-API"><a href="#IntersectionObserver-API" class="headerlink" title="IntersectionObserver API"></a>IntersectionObserver API</h2><p>虽然我们使用了函数节流来降低 scroll 的频率，但是检测函数触发的频率依然很高，这之中的大多数检测都是没有意义的(并没有新的图片进入)。为了更好的解决这类问题，浏览器也提供了 <code>IntersectionObserver</code> API 来帮助我们判断元素是否进入可是区域。</p>
<p>由于可见（visible）的本质是，目标元素与视口产生一个交叉区，所以这个 API 叫做”交叉观察器”。</p>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>使用方式十分简单：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> io = <span class="keyword">new</span> IntersectionObserver(callback, option);</div></pre></td></tr></table></figure>
<p>上面代码中，IntersectionObserver是浏览器原生提供的构造函数，接受两个参数：callback是可见性变化时的回调函数，option是配置对象（该参数可选）。<br>构造函数的返回值是一个观察器实例。实例的observe方法可以指定观察哪个 DOM 节点。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 开始观察</span></div><div class="line">io.observe(<span class="built_in">document</span>.getElementById(<span class="string">'example'</span>));</div><div class="line"></div><div class="line"><span class="comment">// 停止观察</span></div><div class="line">io.unobserve(element);</div><div class="line"></div><div class="line"><span class="comment">// 关闭观察器</span></div><div class="line">io.disconnect();</div></pre></td></tr></table></figure>
<p>上面代码中，observe的参数是一个 DOM 节点对象。如果要观察多个节点，就要多次调用这个方法。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">io.observe(elementA);</div><div class="line">io.observe(elementB);</div></pre></td></tr></table></figure>
<h3 id="callback"><a href="#callback" class="headerlink" title="callback"></a>callback</h3><p>目标元素的可见性变化时，就会调用观察器的回调函数callback。<br>callback一般会触发两次。一次是目标元素刚刚进入视口（开始可见），另一次是完全离开视口（开始不可见）。    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> io = <span class="keyword">new</span> IntersectionObserver(</div><div class="line">  entries =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(entries);</div><div class="line">  &#125;</div><div class="line">);</div></pre></td></tr></table></figure>
<p>callback函数的参数（entries）是一个数组，每个成员都是一个IntersectionObserverEntry对象。如果同时有两个被观察的对象的可见性发生变化，entries数组就会有两个成员。  </p>
<h3 id="IntersectionObserverEntry-对象"><a href="#IntersectionObserverEntry-对象" class="headerlink" title="IntersectionObserverEntry 对象"></a>IntersectionObserverEntry 对象</h3><p>IntersectionObserverEntry对象提供目标元素的信息，一共有六个属性：  </p>
<ul>
<li>time：可见性发生变化的时间ms</li>
<li>target：被观察的目标元素，是一个 DOM 节点对象</li>
<li>rootBounds：根元素的矩形区域的信息，getBoundingClientRect()方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回null</li>
<li>boundingClientRect：目标元素的矩形区域的信息</li>
<li>intersectionRect：目标元素与视口（或根元素）的交叉区域的信息</li>
<li>intersectionRatio：目标元素的可见比例，即intersectionRect占boundingClientRect的比例，完全可见时为1，完全不可见时小于等于0     </li>
</ul>
<h3 id="options-参数"><a href="#options-参数" class="headerlink" title="options 参数"></a>options 参数</h3><p>其中，options 整个参数对象以及它的三个属性都是可选的：</p>
<h4 id="root-属性"><a href="#root-属性" class="headerlink" title="root 属性"></a>root 属性</h4><p>IntersectionObserver API 的适用场景主要是这样的：一个可以滚动的元素，我们叫它根元素，它有很多后代元素，想要做的就是判断它的某个后代元素是否滚动进了自己的可视区域范围。这个 root 参数就是用来指定根元素的，默认值是 null。<br>如果它的值是 null，根元素就不是个真正意义上的元素了，而是这个浏览器窗口了，可以理解成 window。  </p>
<h4 id="threshold-属性"><a href="#threshold-属性" class="headerlink" title="threshold 属性"></a>threshold 属性</h4><p>当目标元素和根元素相交时，用相交的面积除以目标元素的面积会得到一个 0 到 1（0% 到 100%）的数值：<br>IntersectionObserver API 的基本工作原理就是：当目标元素和根元素相交的面积占目标元素面积的百分比到达或跨过某些指定的临界值时就会触发回调函数。threshold 参数就是用来指定那个临界值的，默认值是 0，表示俩元素刚刚挨上就触发回调。可以指定多个临界值，用数组形式，比如 [0, 0.5, 1]，表示在两个矩形开始相交，相交一半，完全相交这三个时刻都要触发一次回调函数。  </p>
<h4 id="rootMagin-属性"><a href="#rootMagin-属性" class="headerlink" title="rootMagin 属性"></a>rootMagin 属性</h4><p>rootMargin 可以给根元素添加一个假想的 margin，从而对真实的根元素区域进行缩放。比如当 root 为 null 时设置 rootMargin: “100px”，实际的根元素矩形四条边都会被放大 100px。</p>
<h2 id="利用-IntersectionObserver-实现高效的图片惰性加载"><a href="#利用-IntersectionObserver-实现高效的图片惰性加载" class="headerlink" title="利用 IntersectionObserver 实现高效的图片惰性加载"></a>利用 IntersectionObserver 实现高效的图片惰性加载</h2><p>首先获取哪儿些图片需要被IntersectionObserver 观测，这里我们认为带有 <code>.lazy-load</code> 类的图片：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取所有要观测的图片</span></div><div class="line"><span class="keyword">const</span> images = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.lazy-load'</span>);</div><div class="line"><span class="keyword">const</span> config = &#123;</div><div class="line">   <span class="comment">// 如果图像在Y轴上的50像素内，则开始下载。</span></div><div class="line">    rootMargin: <span class="string">'50px 0px'</span>,</div><div class="line">    threshold: <span class="number">0.01</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 观察图片</span></div><div class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> IntersectionObserver(onIntersection, config);</div><div class="line">    images.forEach(<span class="function"><span class="params">image</span> =&gt;</span> &#123;</div><div class="line">        observer.observe(image);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"><span class="string">``</span><span class="string">`  </span></div><div class="line"><span class="string">之后我们在 `</span>onIntersection<span class="string">` 中处理图片加载逻辑：  </span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">`</span><span class="string">``</span>javascript    </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onIntersection</span>(<span class="params">entries</span>) </span>&#123;</div><div class="line">    <span class="comment">// 查看所有观察的图片</span></div><div class="line">    entries.forEach(<span class="function"><span class="params">entry</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">if</span> (entry.intersectionRatio &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// 停止观察，并加载图片</span></div><div class="line">            observer.unobserve(entry.target);</div><div class="line">            preloadImage(entry.target);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样重写后的惰性加载插件性能将大大的提升，而且逻辑也变得十分简单。  </p>
<h2 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h2><p>下图为该API的支持情况：<br><img src="/2017/08/28/图片惰性加载的实现/2.png" alt="2.png" title=""><br>很遗憾safari还不支持该属性，你可以利用下面代码来简单实现降级方案：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!(<span class="string">'IntersectionObserver'</span> <span class="keyword">in</span> <span class="built_in">window</span>)) &#123;</div><div class="line">    <span class="comment">// 如果不支持，则立刻加载所有图片</span></div><div class="line">    <span class="built_in">Array</span>.from(images).forEach(<span class="function"><span class="params">image</span> =&gt;</span> preloadImage(image));</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    observer = <span class="keyword">new</span> IntersectionObserver(onIntersection, config);</div><div class="line">    images.forEach(<span class="function"><span class="params">image</span> =&gt;</span> &#123;</div><div class="line">        observer.observe(image);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果，你真的想在不支持的浏览器下体验该属性，你可以下载下面这个 polyfill。<a href="https://github.com/w3c/IntersectionObserver/tree/gh-pages/polyfill" target="_blank" rel="external">w3c/IntersectionObserver</a>  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于惰性加载&quot;&gt;&lt;a href=&quot;#关于惰性加载&quot; class=&quot;headerlink&quot; title=&quot;关于惰性加载&quot;&gt;&lt;/a&gt;关于惰性加载&lt;/h2&gt;&lt;p&gt;惰性加载又称为延迟加载、懒加载等，’lazyload’，即在长网页中延迟加载图像。当图片未到达可视区域时，不加载图片。如下图所示：  &lt;/p&gt;
&lt;img src=&quot;/2017/08/28/图片惰性加载的实现/1.gif&quot; alt=&quot;1.gif&quot; title=&quot;&quot;&gt;  
&lt;p&gt;优点：提升用户的体验，如果图片数量较大，打开页面的时候要将将页面上所有的图片全部获取加载，很可能会出现卡顿现象，影响用户体验。因此，有选择性地请求图片，这样能明显减少了服务器的压力和流量，也能够减小浏览器的负担。&lt;br&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>[译] 将你的网站改造为PWA</title>
    <link href="http://yoursite.com/2017/08/23/%E8%AF%91-%E5%B0%86%E4%BD%A0%E7%9A%84%E7%BD%91%E7%AB%99%E5%8D%87%E7%BA%A7%E4%B8%BAPWA/"/>
    <id>http://yoursite.com/2017/08/23/译-将你的网站升级为PWA/</id>
    <published>2017-08-23T12:07:14.000Z</published>
    <updated>2017-09-22T07:16:06.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文翻译自：<a href="https://www.sitepoint.com/retrofit-your-website-as-a-progressive-web-app/?utm_source=mobilewebweekly&amp;utm_medium=email" target="_blank" rel="external">Retrofit Your Website as a Progressive Web App</a><br>如果原文打不开请移步：<a href="https://www.zybuluo.com/caelumtian/note/860343" target="_blank" rel="external">这里</a>     </p>
</blockquote>
<p>最近大家都在讨论渐进增强web应用(Progressive Web Apps 简称PWA)，许多人质疑PWA是否能代表移动web的未来。这里我不会介入navtive app 和 PWA的争论之中，但是有件事是可以确定的-PWA在很大的长度上增强移动端提高了用户的体验。到2018年移动设备的web接入的数量注定要超过其他所有设备总量和，这种趋势是不可忽视的。<br><a id="more"></a><br>好消息是制作PWA程序并不是很困难。实际上，将现有的网站转换成PWA是很有可能的。在本文中，我将会介绍如何将一个网站改造成像native app一样。它可以离线工作，并且拥有自己的应用图标。  </p>
<h2 id="什么是渐进增强web应用？"><a href="#什么是渐进增强web应用？" class="headerlink" title="什么是渐进增强web应用？"></a>什么是渐进增强web应用？</h2><p>Progressiv Web App (简称PWA)是web上一个令人兴奋的创新。PWA由一系列技术组成，用来是web应用程序更像native应用。对于开发人员和用户来说，它可以突破web和native上面的限制因素：    </p>
<ol>
<li>你只需要开发一个符合W3c标准的web程序，不必开发单独的native版本  </li>
<li>用户可以在安装前就使用你的程序  </li>
<li>我们不在需要使用 AppStore，忍受那些难懂的规则或付费。应用程序可以自动更新，不再需要用户手动操作  </li>
<li>网页可以提醒用户是否在主屏幕上添加应用图标    </li>
<li>当程序启动时，PWA的具有吸引力的展示效果</li>
<li>如果有必要，可以修改浏览器设置达到全屏浏览的效果   </li>
<li>基本的文件被缓存在本地因此PWA具有比普通web应用更快的响应速度（他们设置比native app还要快  </li>
<li>安装更加的轻量，也许只是几百KB的缓存数据  </li>
<li>PWA处于离线状态可以在连接返回后同步数据  </li>
</ol>
<p>现在PWA技术还有些不成熟，但是已经有了积极的案例。印度最大的商务网站Flipkart 通过将native app转换成PWA使得销售增长了70%。全球最大的交易平台Alibaba转换率也达到了70%。<br>PWA技术已经被支持与Firefox,Chrome和其他基于Blink内核的浏览器中。微软的Edge也在努力的实现。尽管Apple在webkit五年计划上发表了很多积极的言论，但是依然没有支持PWA。  </p>
<h2 id="“渐进增强”-web-应用"><a href="#“渐进增强”-web-应用" class="headerlink" title="“渐进增强” web 应用"></a>“渐进增强” web 应用</h2><p>你的网站有可能依然运行在不支持PWA的浏览器中。这样做仅仅是让用户不能使用离线等功能，网站依然可以像网站一样正常运行。鉴于利益的汇报，我们没有理由不去将PWA技术添加到我们的网站之中。  </p>
<h2 id="这不仅仅是应用程序"><a href="#这不仅仅是应用程序" class="headerlink" title="这不仅仅是应用程序"></a>这不仅仅是应用程序</h2><p>Google 引领了PWA运动，以至于许多教程都在讲述如何在基于Chrome的基础上从头开始构建PWA应用。然而，你并不一定需要一个单页应用或者遵循界面设计指南。大多数网站都可以在几个小时能升级到PWA。这包括你的WordPress或者静态页面。在编写本文的时候，<code>Smashing</code> 杂志宣布，他们正在支持PWA的建设。  </p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>你可以在这里找到示例代码：<a href="https://github.com/sitepoint-editors/pwa-retrofit" target="_blank" rel="external">https://github.com/sitepoint-editors/pwa-retrofit</a><br>demo 提供了一个带有一些图片，一个样式表和一些主要的javascrit文件的四页网站。该网站可以运行在所有的现在浏览器中(IE10+)。如果您的浏览器支持PWA，那么你可以在离线时浏览整个网站。<br>运行代码请确保Node.js环境，在终端中执行下面的命令启动服务器:  </p>
<blockquote>
<p>node ./server.js [port]  </p>
</blockquote>
<p>打开Chrome或者基于Blik内核的浏览器，访问 <a href="http://localhost:8888/" target="_blank" rel="external">http://localhost:8888/</a> 来查看页面。你可以打开 Developer Tools来查看控制台输出信息。   </p>
<img src="/2017/08/23/译-将你的网站升级为PWA/1.png" alt="1.png" title=""> 
<p>下面的方案可以帮你离线查看： 关闭 web 服务器，或者在Developer Tools的 Network或Application中点击offline复选框。 重新访问你之前的页面，他们依然会加载。访问你没有看到过的网站，则会显示 <code>您处于离线状态</code>的页面，其中包含了网页列表信息。<br><img src="/2017/08/23/译-将你的网站升级为PWA/2.png" alt="2.png" title=""> </p>
<h3 id="连接移动设备"><a href="#连接移动设备" class="headerlink" title="连接移动设备"></a>连接移动设备</h3><p>你也可以通过USB线将移动设备连接到PC/MAC上，来查看页面。打开浏览器 More tools选中的Remote devices面板。    </p>
<img src="/2017/08/23/译-将你的网站升级为PWA/3.png" alt="3.png" title="">
<p>选择左侧的设置，点击 Add rule 添加 localhost:8888。现在你可以在移动设备上打开Chrome浏览器访问 <a href="http://localhost:8888。" target="_blank" rel="external">http://localhost:8888。</a>  </p>
<p>你可以使用浏览器菜单中的<code>Add to Home screen</code>。几次访问后，浏览器也会提醒你是否安装。上述两种方法都可以将应用程序添加到你的主屏幕。浏览几个页面后关闭Chrome断开设备链接。之后打开你的 PWA 网站，你可以看见启动屏幕并且依然能够查看之前的页面，尽管这时候你处于离线状态。  </p>
<h2 id="如何使用PWA技术"><a href="#如何使用PWA技术" class="headerlink" title="如何使用PWA技术"></a>如何使用PWA技术</h2><p>将你的网站转换成PWA仅需要一下三个基本步骤：  </p>
<h3 id="步骤1：设置HTTPS"><a href="#步骤1：设置HTTPS" class="headerlink" title="步骤1：设置HTTPS"></a>步骤1：设置HTTPS</h3><p>PWA需要HTTPS的支持，原因不言而喻。设置HTTPS在不同的主机上有不同的流程，但是HTTPS网站会在 Google 获得更高的 Rank 这使得一切都是值得的。<br>Chrome 允许使用 localhost 或者任何 127.x.x.x 来进行HTTPS测试。你也可以在Chrome启动中添加下面的命令，来使得PWA运行在HTTP中：  </p>
<blockquote>
<p>– user-data-dir<br>– unsafety-treat-insecure-origin-as-secure  </p>
</blockquote>
<h3 id="步骤2：创建-manifest-文件"><a href="#步骤2：创建-manifest-文件" class="headerlink" title="步骤2：创建 manifest 文件"></a>步骤2：创建 manifest 文件</h3><p>提供一个web应用程序相关的信息，包括名称，描述和配置到主屏幕的图标，启动图片和viewport。实际上，manifest 文件是提供上述信息的文件。<br>manifest 是一个JSON格式的文件。我们必须提供含有 Content-Type: application/manifest+json 或者 Content-Type: applicaiont/json 的HTTP请求头来时使用它。该文件可以随意起名，这里我们叫做 manifest.json：   </p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"name"</span>              : <span class="string">"PWA Website"</span>,</div><div class="line">  <span class="attr">"short_name"</span>        : <span class="string">"PWA"</span>,</div><div class="line">  <span class="attr">"description"</span>       : <span class="string">"An example PWA website"</span>,</div><div class="line">  <span class="attr">"start_url"</span>         : <span class="string">"/"</span>,</div><div class="line">  <span class="attr">"display"</span>           : <span class="string">"standalone"</span>,</div><div class="line">  <span class="attr">"orientation"</span>       : <span class="string">"any"</span>,</div><div class="line">  <span class="attr">"background_color"</span>  : <span class="string">"#ACE"</span>,</div><div class="line">  <span class="attr">"theme_color"</span>       : <span class="string">"#ACE"</span>,</div><div class="line">  <span class="attr">"icons"</span>: [</div><div class="line">    &#123;</div><div class="line">      <span class="attr">"src"</span>           : <span class="string">"/images/logo/logo072.png"</span>,</div><div class="line">      <span class="attr">"sizes"</span>         : <span class="string">"72x72"</span>,</div><div class="line">      <span class="attr">"type"</span>          : <span class="string">"image/png"</span></div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">      <span class="attr">"src"</span>           : <span class="string">"/images/logo/logo152.png"</span>,</div><div class="line">      <span class="attr">"sizes"</span>         : <span class="string">"152x152"</span>,</div><div class="line">      <span class="attr">"type"</span>          : <span class="string">"image/png"</span></div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">      <span class="attr">"src"</span>           : <span class="string">"/images/logo/logo192.png"</span>,</div><div class="line">      <span class="attr">"sizes"</span>         : <span class="string">"192x192"</span>,</div><div class="line">      <span class="attr">"type"</span>          : <span class="string">"image/png"</span></div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">      <span class="attr">"src"</span>           : <span class="string">"/images/logo/logo256.png"</span>,</div><div class="line">      <span class="attr">"sizes"</span>         : <span class="string">"256x256"</span>,</div><div class="line">      <span class="attr">"type"</span>          : <span class="string">"image/png"</span></div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">      <span class="attr">"src"</span>           : <span class="string">"/images/logo/logo512.png"</span>,</div><div class="line">      <span class="attr">"sizes"</span>         : <span class="string">"512x512"</span>,</div><div class="line">      <span class="attr">"type"</span>          : <span class="string">"image/png"</span></div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>&lt;head&gt;</code>标签中需要加入下面的内容：  </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"manifest"</span> <span class="attr">href</span>=<span class="string">"/manifest.json"</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这些字段的含义如下：  </p>
<ul>
<li>name – 应用名称</li>
<li>short_name – 应用的缩略名</li>
<li>description – 应用描述</li>
<li>start_url – 应用启动的相对路径 (通常为 /)</li>
<li>scope - 导航范围。例如：/app/会将应用限制在app文件夹下 </li>
<li>background-color - 启动界面的背景颜色  </li>
<li>display - 展示方式：fullscreen 全屏，standalong 类似native app，minimal-ui 一个简单的UI空间，browser 传统浏览器界面  </li>
<li>icons - 定义图片信息的数组，包括图片URL，大小和类型。应该定义一些列图标信息。  </li>
</ul>
<p>MDN 定义了完整的列表<a href="https://developer.mozilla.org/en-US/docs/Web/Manifest" target="_blank" rel="external">Web App Manifest properties</a><br>Chrome 浏览器会监听验证你的manifest文件，并且提供<code>add to homescreen</code> 链接：  </p>
<img src="/2017/08/23/译-将你的网站升级为PWA/4.png" alt="4.png" title="">  
<h3 id="步骤3：创建Service-Worker"><a href="#步骤3：创建Service-Worker" class="headerlink" title="步骤3：创建Service Worker"></a>步骤3：创建Service Worker</h3><p>Service Workers 是一个用来拦截网络请求的Javascript脚本，放在应用程序根目录下即可。<br>下面这段代码（/js/main.js）用来检测当网站支持 Service Worker 后注册service-worker.js脚本:  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator) &#123;</div><div class="line">    <span class="comment">// register service worker</span></div><div class="line">    navigator.serviceWorker.register(<span class="string">'/service-worker.js'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Service workers 可能会让感到迷惑，你可以根据自己的目的来调整demo代码。示例代码是标准的浏览器下载脚本，它单独运行在一个线程上。该脚本无权访问DOM或其他页面的API，但是它可以在网页发生变化的时候拦截网络请求，资源下载和Ajax请求。<br>Service workers也是网站需要采用HTTPS的根本原因。试想一下，如果第三方脚本可有轻易注入你的Service worker中。它就有可能窃取和篡改客户端和服务端之间的通讯信息。<br>Service workers 需要响应下面三个基本事件：install, activate 和 fetch。   </p>
<h4 id="Install-Event"><a href="#Install-Event" class="headerlink" title="Install Event"></a>Install Event</h4><p>这个事件发生在Service worker注册阶段。它通常用于使用Cache API来创建缓存，放置应用离线时所需要的资源。<br>首先，我们定义一些基础的配置：    </p>
<ol>
<li><code>缓存名称（CACHE）和版本号（version）</code> 你的应用可以有多个缓存，但我们只使用一个。因此应用版本号就很有用，当网站有重大的改变后，将使用心得缓存忽略掉之前的缓存。  </li>
<li><code>离线页面URL(offlineURL)</code> 当用户离线后视图访问之前没有访问过的页面，该页面将被显示。  </li>
<li><code>一系列提供离线功能的基本文件(installFilesEssential)</code> 这里应该提供一个包含CSS和Javascript的数组，我还向数组中加入了主页(/)和logo。你也应该加入其他的需要文件例如：/ 或者 /index.html。注意offlineURL也要加入这个数组。  </li>
<li><code>一些可选的文件(installFilesDesirable)</code> 如果有可能，这些内容将会被下载，但不会使安装中断    </li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// configuration</span></div><div class="line"><span class="keyword">const</span></div><div class="line">  version = <span class="string">'1.0.0'</span>,</div><div class="line">  CACHE = version + <span class="string">'::PWAsite'</span>,</div><div class="line">  offlineURL = <span class="string">'/offline/'</span>,</div><div class="line">  installFilesEssential = [</div><div class="line">    <span class="string">'/'</span>,</div><div class="line">    <span class="string">'/manifest.json'</span>,</div><div class="line">    <span class="string">'/css/styles.css'</span>,</div><div class="line">    <span class="string">'/js/main.js'</span>,</div><div class="line">    <span class="string">'/js/offlinepage.js'</span>,</div><div class="line">    <span class="string">'/images/logo/logo152.png'</span></div><div class="line">  ].concat(offlineURL),</div><div class="line">  installFilesDesirable = [</div><div class="line">    <span class="string">'/favicon.ico'</span>,</div><div class="line">    <span class="string">'/images/logo/logo016.png'</span>,</div><div class="line">    <span class="string">'/images/hero/power-pv.jpg'</span>,</div><div class="line">    <span class="string">'/images/hero/power-lo.jpg'</span>,</div><div class="line">    <span class="string">'/images/hero/power-hi.jpg'</span></div><div class="line">  ];</div></pre></td></tr></table></figure>
<p>installStaticFiles() 函数利用异步的Cache API 来将这些文件添加到缓存。当缓存生成后返回Promise对象：   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// install static assets</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">installStaticFiles</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> caches.open(CACHE)</div><div class="line">    .then(<span class="function"><span class="params">cache</span> =&gt;</span> &#123;</div><div class="line"></div><div class="line">      <span class="comment">// cache desirable files</span></div><div class="line">      cache.addAll(installFilesDesirable);</div><div class="line"></div><div class="line">      <span class="comment">// cache essential files</span></div><div class="line">      <span class="keyword">return</span> cache.addAll(installFilesEssential);</div><div class="line"></div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后，我们注册一个 install 监听器。我们必须提供一个waitUntil方法(参数为promise对象)，当oninstall或者onactivate触发时被调用，来执行我们的函数：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// application installation</span></div><div class="line">self.addEventListener(<span class="string">'install'</span>, event =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'service worker: install'</span>);</div><div class="line">  <span class="comment">// cache core files</span></div><div class="line">  event.waitUntil(</div><div class="line">    installStaticFiles()</div><div class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> self.skipWaiting())</div><div class="line">  );</div><div class="line">&#125;); </div><div class="line"><span class="string">``</span><span class="string">` </span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">#### Activate Event   </span></div><div class="line"><span class="string">当Service worker安装成功后会被立刻激活该事件。你可能并不总是需要这个处理程序。下面这段代码可以用来删除旧的缓存：  </span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">`</span><span class="string">``</span>javascript  </div><div class="line"><span class="comment">// clear old caches</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">clearOldCaches</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> caches.keys()</div><div class="line">    .then(<span class="function"><span class="params">keylist</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.all(</div><div class="line">        keylist</div><div class="line">          .filter(<span class="function"><span class="params">key</span> =&gt;</span> key !== CACHE)</div><div class="line">          .map(<span class="function"><span class="params">key</span> =&gt;</span> caches.delete(key))</div><div class="line">      );</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"><span class="comment">// application activated</span></div><div class="line">self.addEventListener(<span class="string">'activate'</span>, event =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'service worker: activate'</span>);</div><div class="line">    <span class="comment">// delete old caches</span></div><div class="line">  event.waitUntil(</div><div class="line">    clearOldCaches()</div><div class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> self.clients.claim())</div><div class="line">    );</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>注意，最后的 self.clients.claim() 将当前Service worker对象作为所有客户端的活动对象。  </p>
<h4 id="Fetch-Event"><a href="#Fetch-Event" class="headerlink" title="Fetch Event"></a>Fetch Event</h4><p>当网络产生请求后触发该事件，它通过调用respondWith() 方法来拦截GET请求并返回：  </p>
<ol>
<li>缓存中的内容。 </li>
<li>如果#1没有缓存，则使用Fetch API从网络加载资源(与Service worker的fetch event无关)，然后将资源添加到缓存中。  </li>
<li>如果#1，#2都失败了，则返回一个适当的结果。  </li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// application fetch network data</span></div><div class="line">self.addEventListener(<span class="string">'fetch'</span>, event =&gt; &#123;</div><div class="line">  <span class="comment">// abandon non-GET requests</span></div><div class="line">  <span class="keyword">if</span> (event.request.method !== <span class="string">'GET'</span>) <span class="keyword">return</span>;</div><div class="line">  <span class="keyword">let</span> url = event.request.url;</div><div class="line">  event.respondWith(</div><div class="line">    caches.open(CACHE)</div><div class="line">      .then(<span class="function"><span class="params">cache</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">return</span> cache.match(event.request)</div><div class="line">          .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</div><div class="line">            <span class="keyword">if</span> (response) &#123;</div><div class="line">              <span class="comment">// return cached file</span></div><div class="line">              <span class="built_in">console</span>.log(<span class="string">'cache fetch: '</span> + url);</div><div class="line">              <span class="keyword">return</span> response;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// make network request</span></div><div class="line">            <span class="keyword">return</span> fetch(event.request)</div><div class="line">              .then(<span class="function"><span class="params">newreq</span> =&gt;</span> &#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">'network fetch: '</span> + url);</div><div class="line">                <span class="keyword">if</span> (newreq.ok) cache.put(event.request, newreq.clone());</div><div class="line">                <span class="keyword">return</span> newreq;</div><div class="line">              &#125;)</div><div class="line">              <span class="comment">// app is offline</span></div><div class="line">              .catch(<span class="function"><span class="params">()</span> =&gt;</span> offlineAsset(url));</div><div class="line">          &#125;);</div><div class="line">      &#125;)</div><div class="line">  );</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>最后我们调用 offlineAsset(url) 方法返回一个适当的响应：    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// is image URL?</span></div><div class="line"><span class="keyword">let</span> iExt = [<span class="string">'png'</span>, <span class="string">'jpg'</span>, <span class="string">'jpeg'</span>, <span class="string">'gif'</span>, <span class="string">'webp'</span>, <span class="string">'bmp'</span>].map(<span class="function"><span class="params">f</span> =&gt;</span> <span class="string">'.'</span> + f);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isImage</span>(<span class="params">url</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> iExt.reduce(<span class="function">(<span class="params">ret, ext</span>) =&gt;</span> ret || url.endsWith(ext), <span class="literal">false</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// return offline asset</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">offlineAsset</span>(<span class="params">url</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (isImage(url)) &#123;</div><div class="line">    <span class="comment">// return image</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Response(</div><div class="line">      <span class="string">'&lt;svg role="img" viewBox="0 0 400 300" xmlns="http://www.w3.org/2000/svg"&gt;&lt;title&gt;offline&lt;/title&gt;&lt;path d="M0 0h400v300H0z" fill="#eee" /&gt;&lt;text x="200" y="150" text-anchor="middle" dominant-baseline="middle" font-family="sans-serif" font-size="50" fill="#ccc"&gt;offline&lt;/text&gt;&lt;/svg&gt;'</span>,</div><div class="line">      &#123; <span class="attr">headers</span>: &#123;</div><div class="line">        <span class="string">'Content-Type'</span>: <span class="string">'image/svg+xml'</span>,</div><div class="line">        <span class="string">'Cache-Control'</span>: <span class="string">'no-store'</span></div><div class="line">      &#125;&#125;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// return page</span></div><div class="line">    <span class="keyword">return</span> caches.match(offlineURL);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>例子中，offlineAsset()函数用来检测请求是否是一个图片并且返回一个包含”offline”字段的SVG。其他请求则返回离线页面。<br>Chrome开发工具提供了查看Service Worker信息的选项，包含了错误消息，重新加载工具和页面离线等内容：  </p>
<img src="/2017/08/23/译-将你的网站升级为PWA/5.png" alt="5.png" title="">
<p><code>Cache Storage</code> 列出了当前环境下所有的缓存内容，如果缓存有更新你需要点击刷新按钮来看到他们。  </p>
<img src="/2017/08/23/译-将你的网站升级为PWA/6.png" alt="6.png" title="">  
<p>同样Clear storage选项可以删除你的Service worker和缓存。  </p>
<h3 id="步骤4：创建一个实用的离线页面"><a href="#步骤4：创建一个实用的离线页面" class="headerlink" title="步骤4：创建一个实用的离线页面"></a>步骤4：创建一个实用的离线页面</h3><p>离线页面可以是一个静态页面来提醒用户他们访问的页面不能离线查看。同时，我们还需要提供一个可访问页面的URL列表供用户查看。<br>我们可以再main.js中来使用Cache API。但是，API的异步请求失败的时候会导致浏览器停止运行。为了防止这种情况发生，我们将检测离线元素和Caches API是否可用的代码放在其他的文件中 /js/offlinepage.js（必须放在 installFiledEssential数组前):    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// load script to populate offline page list</span></div><div class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.getElementById(<span class="string">'cachedpagelist'</span>) &amp;&amp; <span class="string">'caches'</span> <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</div><div class="line">  <span class="keyword">var</span> scr = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</div><div class="line">  scr.src = <span class="string">'/js/offlinepage.js'</span>;</div><div class="line">  scr.async = <span class="number">1</span>;</div><div class="line">  <span class="built_in">document</span>.head.appendChild(scr);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>/js/offlinepage 通过版本名称来查找最近的缓存，URL列表，删除没有页面的URLs，对列表进行排序并添加到id为cachedpagelist的DOM节点上：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// cache name</span></div><div class="line"><span class="keyword">const</span></div><div class="line">  CACHE = <span class="string">'::PWAsite'</span>,</div><div class="line">  offlineURL = <span class="string">'/offline/'</span>,</div><div class="line">  list = <span class="built_in">document</span>.getElementById(<span class="string">'cachedpagelist'</span>);</div><div class="line"><span class="comment">// fetch all caches</span></div><div class="line"><span class="built_in">window</span>.caches.keys()</div><div class="line">  .then(<span class="function"><span class="params">cacheList</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">// find caches by and order by most recent</span></div><div class="line">    cacheList = cacheList</div><div class="line">      .filter(<span class="function"><span class="params">cName</span> =&gt;</span> cName.includes(CACHE))</div><div class="line">      .sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</div><div class="line">    <span class="comment">// open first cache</span></div><div class="line">    caches.open(cacheList[<span class="number">0</span>])</div><div class="line">      .then(<span class="function"><span class="params">cache</span> =&gt;</span> &#123;</div><div class="line">        <span class="comment">// fetch cached pages</span></div><div class="line">        cache.keys()</div><div class="line">          .then(<span class="function"><span class="params">reqList</span> =&gt;</span> &#123;</div><div class="line">            <span class="keyword">let</span> frag = <span class="built_in">document</span>.createDocumentFragment();</div><div class="line">            reqList</div><div class="line">              .map(<span class="function"><span class="params">req</span> =&gt;</span> req.url)</div><div class="line">              .filter(<span class="function"><span class="params">req</span> =&gt;</span> (req.endsWith(<span class="string">'/'</span>) || req.endsWith(<span class="string">'.html'</span>)) &amp;&amp; !req.endsWith(offlineURL))</div><div class="line">              .sort()</div><div class="line">              .forEach(<span class="function"><span class="params">req</span> =&gt;</span> &#123;</div><div class="line">                <span class="keyword">let</span></div><div class="line">                  li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>),</div><div class="line">                  a = li.appendChild(<span class="built_in">document</span>.createElement(<span class="string">'a'</span>));</div><div class="line">                  a.setAttribute(<span class="string">'href'</span>, req);</div><div class="line">                  a.textContent = a.pathname;</div><div class="line">                  frag.appendChild(li);</div><div class="line">              &#125;);</div><div class="line">            <span class="keyword">if</span> (list) list.appendChild(frag);</div><div class="line">          &#125;);</div><div class="line">      &#125;)</div><div class="line">  &#125;);</div></pre></td></tr></table></figure>
<h2 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h2><p>如果你认为调试Serice Workers有困难，Chrome Development Tools中的 Application选项提供了一些列日志消息在控制台中。<br>你应该在隐身模式下开发你的应用程序，这样可以避免文件缓存带来的影响。<br>Firefox也提供了来自Service Workers的JavaScript调试信息，未来也会更加的完善。<br>最后Chrome 扩展程序 Lighthouse 可以提供更加丰富的PWA信息。  </p>
<h2 id="PWA-的问题"><a href="#PWA-的问题" class="headerlink" title="PWA 的问题"></a>PWA 的问题</h2><p>对于渐进增强web应用的支持需要谨慎，如果改造它花了很长时间那就得不偿失了。毕竟不支持 PWA 也不会造成很大的负面影响。<br>这里我们还有几个问题需要考虑：  </p>
<h3 id="URL-隐藏"><a href="#URL-隐藏" class="headerlink" title="URL 隐藏"></a>URL 隐藏</h3><p>如何隐藏地址栏我并没有演示，除非你开发了一个单页的游戏这才有必要。manifest的diplay：minimal-ui 或者 display: browser 才是适合大多数网站的。  </p>
<h3 id="缓存重载"><a href="#缓存重载" class="headerlink" title="缓存重载"></a>缓存重载</h3><p>你可以缓存站点的每一页。这对于小型网站是有好处的，但是对于那些拥有很多页面的网站就不那么可取了。没有人会对你所有的内容感兴趣并且设备缓存是有限度的。及时你只缓存访问过的页面，缓存依旧增长的很明显。<br>你也许该考虑以下建议：  </p>
<ul>
<li>只缓存重要的页面如主页，链接，最近的文章等</li>
<li>不缓存图片，视频和大的文件  </li>
<li>定期清除旧的缓存文件  </li>
<li>提供一个”缓存到本地”的按钮，以便用户可以自行选择  </li>
</ul>
<h3 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h3><p>缓存同样需要定期更新，不然用户只能看见旧的页面。<br>对于图片和视频这种不经常变化的内容，你可以设置一个持续一年的缓存时间：  </p>
<blockquote>
<p>Cache-Control: max-age=31536000    </p>
</blockquote>
<p>页面，css和脚本文件有可能频繁更新，你需要设置较短的更新时间例如24小时，确保在线状态服务器对版本的验证:  </p>
<blockquote>
<p>Cache-Control: must-revalidate, max-age=86400    </p>
</blockquote>
<p>你也可以考虑使用缓存清除技术来确定哪些不适用的旧文件，例如：命名你的CSS文件 styles-abc124.css，每个版本都修改哈希值。<br>缓存是很复杂的这里我建议你阅读 Jake Archibold 的文章 <a href="https://jakearchibald.com/2016/caching-best-practices/" target="_blank" rel="external">Caching best practices &amp; max-age gotchas</a>  </p>
<h2 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h2><p>如果你想了解更多，可以参考一下内容：  </p>
<ul>
<li><a href="https://pwa.rocks/" target="_blank" rel="external">PWA.rocks example applications</a></li>
<li><a href="https://developers.google.com/web/progressive-web-apps/" target="_blank" rel="external">Progressive Web Apps</a></li>
<li><a href="https://codelabs.developers.google.com/codelabs/your-first-pwapp/" target="_blank" rel="external">Your First PWA</a></li>
<li><a href="https://serviceworke.rs/" target="_blank" rel="external">Mozilla Service Worker Cookbook</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers" target="_blank" rel="external">MDN Using Service Workers</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文翻译自：&lt;a href=&quot;https://www.sitepoint.com/retrofit-your-website-as-a-progressive-web-app/?utm_source=mobilewebweekly&amp;amp;utm_medium=email&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Retrofit Your Website as a Progressive Web App&lt;/a&gt;&lt;br&gt;如果原文打不开请移步：&lt;a href=&quot;https://www.zybuluo.com/caelumtian/note/860343&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;     &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近大家都在讨论渐进增强web应用(Progressive Web Apps 简称PWA)，许多人质疑PWA是否能代表移动web的未来。这里我不会介入navtive app 和 PWA的争论之中，但是有件事是可以确定的-PWA在很大的长度上增强移动端提高了用户的体验。到2018年移动设备的web接入的数量注定要超过其他所有设备总量和，这种趋势是不可忽视的。&lt;br&gt;
    
    </summary>
    
      <category term="翻译文章" scheme="http://yoursite.com/categories/%E7%BF%BB%E8%AF%91%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="移动开发" scheme="http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
      <category term="PWA" scheme="http://yoursite.com/tags/PWA/"/>
    
  </entry>
  
  <entry>
    <title>[译] 如何利用 localStorage 来构建更快的应用程序</title>
    <link href="http://yoursite.com/2017/08/23/%E8%AF%91-%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8-localStorage-%E6%9D%A5%E6%9E%84%E5%BB%BA%E6%9B%B4%E5%BF%AB%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"/>
    <id>http://yoursite.com/2017/08/23/译-如何利用-localStorage-来构建更快的应用程序/</id>
    <published>2017-08-23T11:45:13.000Z</published>
    <updated>2017-08-25T09:03:48.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文翻译自：<a href="https://medium.freecodecamp.org/how-leverage-local-storage-to-build-lightning-fast-apps-4e8218134e0c" target="_blank" rel="external">How to leverage Local Storage to build lightning-fast apps</a><br>如果原文打不开请移步：<a href="https://www.zybuluo.com/caelumtian/note/857353" target="_blank" rel="external">这里</a>   </p>
</blockquote>
<p>用户偏爱快速响应的应用程序。他们并不关心API运行所需要的时间，而仅仅是想立即看到变化。所以我们怎么做才能尽力满足用户的需求？<br>解决方案：本地存储应用的更改，然后不定时的与你的服务器同步这些内容。但是当我们考虑到连接延迟问题的时候，这样做将会变得更加复杂。<br><a id="more"></a><br>让我们以一个媒体网站为例，用户可以通过点击 ❤️ 按钮来推荐一篇文章给他的朋友们。当用于再次点击该按钮后，则取消推荐。  </p>
<h2 id="上述案例虽然简单，但有一些极端的例子造成了很多问题"><a href="#上述案例虽然简单，但有一些极端的例子造成了很多问题" class="headerlink" title="上述案例虽然简单，但有一些极端的例子造成了很多问题"></a>上述案例虽然简单，但有一些极端的例子造成了很多问题</h2><p>我们并不知道网站内部发生了什么，为了简单起见，我们可以想象在第一次点击的时候，程序将一个项目添加到了推荐列表中，并且在第二次点击的时候移除这个项目。<br>下面让我们看看，如果我们开发这样一个简单的应用功能，会遇到哪儿些问题    </p>
<ol>
<li>我们需要考虑如果用户疯狂的点击 ❤️ 按钮，这些行为将会触发一系列响应 事件  </li>
<li>网速并不总是快的。在一个网速差的环境下，甚至连最简单的API调用都要花上几秒钟才可以完成。在这段时间用户就有可能离开了当前屏幕，然后才会返回  </li>
<li>有的时候，API调用可能失败，我们的程序应该能够有能力从在状况下正常运行  </li>
<li>用户有可能使用不同的设备来打开我们的网站，或者同时在移动设备和PC上面访问我们的网站。不管在哪儿种情况下我们都应该有一个策略来和后端同步数据并更新其状态  </li>
</ol>
<p>我们在实际中可能遇到更多的问题，但是本文着重来解决上面提到的问题。  </p>
<h2 id="明确问题"><a href="#明确问题" class="headerlink" title="明确问题"></a>明确问题</h2><img src="/2017/08/23/译-如何利用-localStorage-来构建更快的应用程序/1.jpeg" alt="1.jpeg" title="">  
<p>在讨论如何解决问题之前，我们来先定义要开发功能的实现标准。任务是开发一个可以在列表中添加和删除项目的功能，列表数据存储在后端。功能必须满足如下要求：  </p>
<ol>
<li>用户界面需要立刻响应用户的操作，让用户看到他们操作的结果。如果之后由于某些原因我们不能同步这些更改内容，我们应该通知用户操作失败。并且回滚到之前的状态。  </li>
<li>支持多个设备的交互。这并不意味着我们需要支持实时修改的功能，但是我们需要不断地获取整个数据。此外，后端为我们提供了添加和删除项目的API，我们必须使用它们来支持更好的同步效果。  </li>
<li>保证数据的完整性：无论什么时候一旦数据同步失败，我们的网站都应该从错误中恢复正常状态。  </li>
</ol>
<p>幸运的是，我们并不需要实现所有，而是开发一种可以实现它的数据存储机制。让我们来探究不同的实现方案。  </p>
<h2 id="最直接的方法"><a href="#最直接的方法" class="headerlink" title="最直接的方法"></a>最直接的方法</h2><img src="/2017/08/23/译-如何利用-localStorage-来构建更快的应用程序/2.jpeg" alt="2.jpeg" title="">   
<p>第一种解决办法是在 localStorage 中存储一份列表数据的副本，当用户进行操作时，我们也同时更新 localStorage 中的数据。这种解决问题的方案大多数与竞争条件或者API调用失败有关，例如：  </p>
<ol>
<li><code>获取并修改列表之间冲突</code> 让我们设想这样一个场景，网站从后端获取列表数据来更新我们的 localStorage。用户这个在更新没有完成之前，修改了数据。这将导致获取到的列表和本地列表之间产生合并冲突。为此我们需要区分那些还没有添加的项目和已经从web中或其他设备上删除的项目。  </li>
<li><code>API调用失败</code> 用户可能进行快速的大量的修改操作，也有可能是恢复操作。例如，用户可以添加项目到列表，然后删除它们，然后又添加回来。如果第一次操作失败，我们应该复原列表即从列表中删除该项。但是这样会破坏我们数据的完整性，因为该项目实际是应该在列表中的。我们最后一次调用时添加操作，而且它还没有完成。  </li>
</ol>
<p>因此，我认为应该保留更多的信息在 localStorage 中，而不仅仅只有最终的预期效果。这样我们才有能力从可能遇到的问题中恢复过来。  </p>
<h2 id="保留用户的操作历史记录"><a href="#保留用户的操作历史记录" class="headerlink" title="保留用户的操作历史记录"></a>保留用户的操作历史记录</h2><img src="/2017/08/23/译-如何利用-localStorage-来构建更快的应用程序/3.jpeg" alt="3.jpeg" title="">   
<p>这里有一个不同的方案：我们保留冲后端获取到的列表，并记录用户的所有操作。每个记录都会匹配一个后端API的调用(分别是’add’和’remove’)。<br>一旦API调用完成，我们更新本地副本数据并从历史记录中删去记录。当我们想和后端同步用户浏览器数据，我们仅仅获取列表的版本然后替换我们的副本。<br>我们不在有任何API调用失败的问题，因为我们明确知道API调用前列表的状态，并且我们可以从历史记录中删除该记录，从而保证数据的完整性。<br>这么做主要会带来性能问题。每次检查一个特性的项目是否在列表中，我们都需要通过所有记录来计算用户期望看到的内容。当然，这些性能都取决于在一定时间内用户进行的交互次数以及数据的存储方式。<br>我认为，这种方案非常利于用户在应用中创建内容的场景，因为它提供了许多解决同步问题的方案。但是我们的问题比这更简单，所以我们应该能够进行一些优化来提升性能。  </p>
<h2 id="中间地带"><a href="#中间地带" class="headerlink" title="中间地带"></a>中间地带</h2><img src="/2017/08/23/译-如何利用-localStorage-来构建更快的应用程序/4.jpeg" alt="4.jpeg" title="">   
<p>这种方案有足够的信息从负面情况中恢复。我们需要两个额外的列表，一个用于持续添加另一个用于删除。为了确保数据的完整性，你仅仅需要添加一些规则：  </p>
<ol>
<li><code>添加和删除列表优先于主列表</code> 例如：一个项目同时在删除列表中和主列表中时。如果浏览器检查项目是否在列表中，它应该返回 false。  </li>
<li><code>一个项目不能同时出现在两个列表中如果用户对一个项目进行了多次操作，则最后的修改应该具有优先级</code> 例如，如果用户添加了项目然后删除了它，作为结果它应该出现在删除列表中。项目在不在主列表中反而无关紧要。  </li>
<li><code>只有某个项目在最后一次调用API完成后，才可以从相应的列表中删除</code> 例如，用户添加了一个项目并删除了它，然后又在第一次调用完成之前添加了它。在这种情况下，该项目应该在添加列表中。但是只有在第二次添加完成后它才应该被删除。我们可以通过为每个条目分配一个ID来实现。在API调用完成后，删除使用这些ID的条目。  </li>
<li><code>每次API调用完成后，主列表应该被更新</code> 主列表应该反映后端的实际情况。所以在连续的添加和删除的情况下，即使在客户端看起来，项目并不在列表中，在第一次调用后我们应该把它添加到主列表中。  </li>
</ol>
<h2 id="关于API调用失败"><a href="#关于API调用失败" class="headerlink" title="关于API调用失败"></a>关于API调用失败</h2><p>调用API失败的原因是有所不同的。有些是临时的，有些不是。他们当中有些是致命的，有些事可以恢复的。无论解决方案是什么，失败的请求都应该返回一些关于失败原因的有用信息。<br>我认为HTTP状态吗是完美的。例如，如果状态吗是504网关超时，重新请求将是个不错的方案。但是如果是400请求错误，那么简单的重新请求将不会有任何效果。其中一些，比如401未经授权，可能需要用户额外的操作。在删除项目的时候，410状态码就可能意味着是用户从不同的设备删除了该项目。  </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>第一个解决方案是简单的列表，他是快速的，但处理负面情况是困难的  </li>
<li>第二种方案，我们创建了一个像列表的数据结构，但是保留了所有的更改记录。这有利于解决负面情况，但是速度很慢  </li>
<li>中间地带解决方案，从外表看依然想一个列表。但是他允许我们平衡性能并且简单快速的从错误中恢复  </li>
</ul>
<p>本文提到的问题只是一个方面。还有就是API调用的数量问题。如果用户执行了大量类似的交互，我们可以尝试最小化API调用的数量。此优化也会影响本地存储的结构。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文翻译自：&lt;a href=&quot;https://medium.freecodecamp.org/how-leverage-local-storage-to-build-lightning-fast-apps-4e8218134e0c&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;How to leverage Local Storage to build lightning-fast apps&lt;/a&gt;&lt;br&gt;如果原文打不开请移步：&lt;a href=&quot;https://www.zybuluo.com/caelumtian/note/857353&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;   &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用户偏爱快速响应的应用程序。他们并不关心API运行所需要的时间，而仅仅是想立即看到变化。所以我们怎么做才能尽力满足用户的需求？&lt;br&gt;解决方案：本地存储应用的更改，然后不定时的与你的服务器同步这些内容。但是当我们考虑到连接延迟问题的时候，这样做将会变得更加复杂。&lt;br&gt;
    
    </summary>
    
      <category term="翻译文章" scheme="http://yoursite.com/categories/%E7%BF%BB%E8%AF%91%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="数据交互" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92/"/>
    
      <category term="翻译文章" scheme="http://yoursite.com/tags/%E7%BF%BB%E8%AF%91%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>[译] 为 Web Bluetooth 做好准备</title>
    <link href="http://yoursite.com/2017/08/21/%E8%AF%91-%E4%B8%BA-Web-Bluetooth-%E5%81%9A%E5%A5%BD%E5%87%86%E5%A4%87/"/>
    <id>http://yoursite.com/2017/08/21/译-为-Web-Bluetooth-做好准备/</id>
    <published>2017-08-21T11:43:00.000Z</published>
    <updated>2017-08-21T11:43:00.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>利用javascript搭建富文本编辑器</title>
    <link href="http://yoursite.com/2017/08/21/%E5%88%A9%E7%94%A8javascript%E6%90%AD%E5%BB%BA%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <id>http://yoursite.com/2017/08/21/利用javascript搭建富文本编辑器/</id>
    <published>2017-08-21T11:37:32.000Z</published>
    <updated>2017-10-30T12:34:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>近期项目中需要开发一个兼容PC和移动端的富文本编辑器，其中包含了一些特殊的定制功能。考察了下现有的js富文本编辑器，桌面端的很多，移动端的几乎没有。桌面端以UEditor为代表。但是我们并不打算考虑兼容性，所以没有必要采用UEditor这么重的插件。为此决定自研一个富文本编辑器。本文，主要介绍如何实现富文本编辑器，和解决一些不同浏览器和设备之间的bug。<br><a id="more"></a></p>
<h1 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h1><p>在现代浏览器中已经为我们准备好了许多API来让 html 支持富文本编辑功能，我们没有必要自己完成全部内容。  </p>
<h2 id="contenteditable-”true”"><a href="#contenteditable-”true”" class="headerlink" title="contenteditable=”true”"></a>contenteditable=”true”</h2><p>首先我们需要让一个 <code>div</code> 成为可编辑状态，加入<code>contenteditable=&quot;true&quot;</code> 属性即可。  </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">contenteditable</span>=<span class="string">"true"</span> <span class="attr">id</span>=<span class="string">"rich-editor"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在这样的 <code>&lt;div&gt;</code> 中插入任何节点都将默认是可编辑状态的。如果想插入不可编辑的节点，我们就需要指定插入节点的属性为 <code>contenteditable=&quot;false&quot;</code>。  </p>
<h2 id="光标操作"><a href="#光标操作" class="headerlink" title="光标操作"></a>光标操作</h2><p>作为富文本编辑器，开发者需要有能力控制光标的各种状态信息，位置信息等。浏览器提供了 <code>selection</code> 对象和 <code>range</code> 对象来操作光标。    </p>
<h3 id="selection-对象"><a href="#selection-对象" class="headerlink" title="selection 对象"></a>selection 对象</h3><p>Selection对象表示用户选择的文本范围或插入符号的当前位置。它代表页面中的文本选区，可能横跨多个元素。文本选区由用户拖拽鼠标经过文字而产生。<br>获得一个 selection 对象  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> selection = <span class="built_in">window</span>.getSelection();</div></pre></td></tr></table></figure>
<p>通常情况下我们不会直接操作 <code>selection</code> 对象，而是需要操作用 <code>seleciton</code> 对象所对应的用户选择的 <code>ranges</code> (区域)，俗称”拖蓝“。获取方式如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> range = selection.getRangeAt(<span class="number">0</span>);</div></pre></td></tr></table></figure>
<p>由于浏览器当前可能存在多个文本选取，所以 <code>getRangeAt</code> 函数接受一个索引值。在富文本编辑其中，我们不考虑多选取的可能性。  </p>
<p>selection 对象还有两个重要的方法， <code>addRange</code> 和 <code>removeAllRanges</code>。分别用于向当前选取添加一个 range 对象和 删除所有 range 对象。之后你会看到他们的用途。  </p>
<h3 id="range-对象"><a href="#range-对象" class="headerlink" title="range 对象"></a>range 对象</h3><p>通过 selection 对象获得的 range 对象才是我们操作光标的重点。Range表示包含节点和部分文本节点的文档片段。初见 range 对象你有可能会感到陌生又熟悉，在哪儿看见过呢？作为一个前端工程师，想必你一定拜读过《javascript 高级程序设计第三版》 这本书。在第12.4节，作者为我们介绍了 DOM2 级提供的 range 接口，用来更好的控制页面。反正我当时看的一脸？？？？这个有啥用，也没有这种需求啊。这里我们就大量的用到这个对象。对于下面节点：  </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">contenteditable</span>=<span class="string">"true"</span> <span class="attr">id</span>=<span class="string">"rich-editor"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>百度EUX团队<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>光标位置如图所示：<br><img src="/2017/08/21/利用javascript搭建富文本编辑器/a.png" alt="a.png" title=""><br>打印出此时的 range 对象：<br><img src="/2017/08/21/利用javascript搭建富文本编辑器/b.png" alt="b.png" title="">   </p>
<p>其中属性含义如下：  </p>
<ul>
<li>startContainer: range 范围的起始节点。</li>
<li>endContainer: range 范围的结束节点</li>
<li>startOffset: range 起点位置的偏移量。</li>
<li>endOffset: range 终点位置的偏移量。</li>
<li>commonAncestorContainer: 返回包含 startContainer 和 endContainer 的最深的节点。  </li>
<li>collapsed: 返回一个用于判断 Range 起始位置和终止位置是否相同的布尔值。  </li>
</ul>
<p>这里我们的 startContainer , endContainer, commonAncestorContainer都为 <code>#text</code> 文本节点 ‘百度EUX团队’。因为光标在‘度‘字后面，所以startOffset 和 endOffset 均为 2。且没有产生拖蓝，所以 collapsed 的值为 true。我们再看一个产生拖蓝的例子：  </p>
<p>光标位置如图所示：<br><img src="/2017/08/21/利用javascript搭建富文本编辑器/c.png" alt="c.png" title=""><br>打印出此时的 range 对象：<br><img src="/2017/08/21/利用javascript搭建富文本编辑器/d.png" alt="d.png" title="">   </p>
<p>由于产生了拖蓝 startContainer 和 endContainer 不再一致，collapsed 的值变为了 false。startOffset 和 endOffset 正好代表了拖蓝的起终位置。更多的效果大家自己尝试吧。  </p>
<p>操作一个 range 节点，主要有如下方法：  </p>
<ul>
<li>setStart(): 设置 Range 的起点</li>
<li>setEnd(): 设置 Range 的终点 </li>
<li>selectNode(): 设定一个包含节点和节点内容的 Range  </li>
<li>collapse(): 向指定端点折叠该 Range</li>
<li>insertNode(): 在 Range 的起点处插入节点。</li>
<li>cloneRange(): 返回拥有和原 Range 相同端点的克隆 Range 对象  </li>
</ul>
<p>富文本编辑里面常用的就这么多，还有很多方法就不列举了。  </p>
<h4 id="修改光标位置"><a href="#修改光标位置" class="headerlink" title="修改光标位置"></a>修改光标位置</h4><p>我们可以通过调用 <code>setStart()</code> 和 <code>setEnd()</code> 方法，来修改一个光标的位置或拖蓝范围。这两个方法接受的参数为各自的起终节点和偏移量。例如我想让光标位置到”百度EUX团队”最末尾，那么可以采用如下方法：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> range = <span class="built_in">window</span>.getSelection().getRangeAt(<span class="number">0</span>),</div><div class="line">    textEle = range.commonAncestorContainer;</div><div class="line">range.setStart(range.startContainer, textEle.length);</div><div class="line">range.setEnd(range.endContainer, textEle.length);</div></pre></td></tr></table></figure>
<p>我们加入一个定时器来查看效果： </p>
<img src="/2017/08/21/利用javascript搭建富文本编辑器/e.gif" alt="e.gif" title="">  
<p>然而这种方式有个局限性，就是当光标所在的节点如果发生了变动。比如被替换或者加入新的节点了，那么再用这种方式就不会有任何效果。为此我们有时候需要一种强制更改光标位置手段, 简要代码如下(实际中你有可能还需要考虑自闭和元素等内容)：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">resetRange</span>(<span class="params">startContainer, startOffset, endContainer, endOffset</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> selection = <span class="built_in">window</span>.getSelection();</div><div class="line">        selection.removeAllRanges();</div><div class="line">    <span class="keyword">let</span> range = <span class="built_in">document</span>.createRange();</div><div class="line">    range.setStart(startContainer, startOffset);</div><div class="line">    range.setEnd(endContainer, endOffset);</div><div class="line">    selection.addRange(range);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们通过重新创造一个 range 对象并且删除原有的 ranges 来保证光标一定会变动到我们想要的位置。 </p>
<h2 id="修改文本格式"><a href="#修改文本格式" class="headerlink" title="修改文本格式"></a>修改文本格式</h2><p>实现富文本编辑器，我们就要能够有修改文档格式的能力，比如加粗，斜体，文本颜色，列表等内容。DOM 为可编辑区提供了 <code>document.execCommand</code> 方法，该方法允许运行命令来操纵可编辑区域的内容。大多数命令影响文档的选择（粗体，斜体等），而其他命令插入新元素（添加链接）或影响整行（缩进）。当使用 contentEditable时，调用 execCommand() 将影响当前活动的可编辑元素。语法如下：  </p>
<blockquote>
<p>bool = document.execCommand(aCommandName, aShowDefaultUI, aValueArgument)  </p>
</blockquote>
<ul>
<li>aCommandName: 一个 DOMString ，命令的名称。可用命令列表请参阅 命令 。</li>
<li>aShowDefaultUI: 一个 Boolean， 是否展示用户界面，一般为 false。Mozilla 没有实现。</li>
<li>aValueArgument: 一些命令（例如insertImage）需要额外的参数（insertImage需要提供插入image的url），默认为null。  </li>
</ul>
<p>总之浏览器能把大部分我们想到的富文本编辑器需要的功能都实现了，这里我就不一一演示了。感兴趣的同学可以查看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/execCommand" target="_blank" rel="external">MDN - document.execCommand</a>。  </p>
<p>到这里，我相信你已经可以做出一个像模像样的富文本编辑器了。想想还挺激动的，但是呢，一切都没有结束，浏览器又一次坑了我们。  </p>
<h1 id="实战开始，填坑的旅途"><a href="#实战开始，填坑的旅途" class="headerlink" title="实战开始，填坑的旅途"></a>实战开始，填坑的旅途</h1><p>就在我们都以为开发如此简单的时候，实际上手却遇到了许多坑。   </p>
<h2 id="修正浏览器的默认效果"><a href="#修正浏览器的默认效果" class="headerlink" title="修正浏览器的默认效果"></a>修正浏览器的默认效果</h2><p>浏览器提供的富文本效果并不总是好用的，下面介绍几个遇到的问题。</p>
<h3 id="回车换行"><a href="#回车换行" class="headerlink" title="回车换行"></a>回车换行</h3><p>当我们在编辑其中输入内容并回车换行继续输入后，可编辑框内容生成的节点和我们预期是不符的。<br><img src="/2017/08/21/利用javascript搭建富文本编辑器/f.png" alt="f.png" title=""><br><img src="/2017/08/21/利用javascript搭建富文本编辑器/g.png" alt="g.png" title=""><br>可以看到最先输入的文字没有被包裹起来，而换行产生的内容，包裹元素是 <code>&lt;div&gt;</code> 标签。为了能够让文字被 <code>&lt;p&gt;</code> 元素包裹起来。<br>我们要在初始化的时候，向<code>&lt;div contenteditable=&quot;true&quot;&gt;</code>默认插入<code>&lt;p&gt;&lt;br&gt;&lt;/p&gt;</code> 元素(<code>&lt;br&gt;</code>标签用来占位，有内容输入后会自动删除)。这样以后每次回车产生的新内容都会被<code>&lt;p&gt;</code> 元素包裹起来(在可编辑状态下，回车换行产生的新结构会默认拷贝之前的内容，包裹节点，类名等各种内容)。<br>我们还需要监听 keyUp 事件下 <code>event.keyCode === 8</code> 删除键。当编辑器中内容全被清空后(delete键也会把<code>&lt;p&gt;</code>标签删除)，要重新加入<code>&lt;p&gt;&lt;br&gt;&lt;/p&gt;</code>标签，并把光标定位在里面。   </p>
<h3 id="插入-ul-和-ol-位置错误"><a href="#插入-ul-和-ol-位置错误" class="headerlink" title="插入 ul 和 ol 位置错误"></a>插入 ul 和 ol 位置错误</h3><p>当我们调用 <code>document.execCommand(&quot;insertUnorderedList&quot;, false, null)</code> 来插入一个列表的时候，新的列表会被插入<code>&lt;p&gt;</code>标签中。<br><img src="/2017/08/21/利用javascript搭建富文本编辑器/h.png" alt="h.png" title=""><br>为此我们需要每次调用该命令前做一次修正，参考代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">adjustList</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> lists = <span class="built_in">document</span>.querySelectorAll(<span class="string">"ol, ul"</span>);</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; lists.length; i++) &#123;</div><div class="line">        <span class="keyword">let</span> ele = lists[i]; <span class="comment">// ol</span></div><div class="line">        <span class="keyword">let</span> parentNode = ele.parentNode;</div><div class="line">        <span class="keyword">if</span> (parentNode.tagName === <span class="string">'P'</span> &amp;&amp; parentNode.lastChild === parentNode.firstChild) &#123;</div><div class="line">                parentNode.insertAdjacentElement(<span class="string">'beforebegin'</span>, ele);</div><div class="line">                parentNode.remove()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里有个附带的小问题，我试图在 <code>&lt;li&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;</code> 维护这样的编辑器结构(默认是没有<code>&lt;p&gt;</code>标签的)。效果在 chrome 下运行很好。但是在 safari 中，回车永远不会产生新的 <code>&lt;li&gt;</code> 标签，这样就是去了该有的列表效果。  </p>
<h3 id="插入分割线"><a href="#插入分割线" class="headerlink" title="插入分割线"></a>插入分割线</h3><p>调用 <code>document.execCommand(&#39;insertHorizontalRule&#39;, false, null);</code> 会插入一个<code>&lt;hr&gt;</code>标签。然而产生的效果却是这样的：<br><img src="/2017/08/21/利用javascript搭建富文本编辑器/i.gif" alt="i.gif" title=""><br>光标和<code>&lt;hr&gt;</code>的效果一致了。为此要判断当前光标是否在 <code>&lt;li&gt;</code> 里面，如果是则在 <code>&lt;hr&gt;</code> 后面追加一个空的文本节点 <code>#text</code> 不是的话追加 <code>&lt;p&gt;&lt;br&gt;&lt;/p&gt;</code>。然后将光标定位在里面，可用如下方式查找。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 查找父元素</span></div><div class="line"><span class="comment"> * @param &#123;String&#125; root </span></div><div class="line"><span class="comment"> * @param &#123;String | Array&#125; name </span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">findParentByTagName</span>(<span class="params">root, name</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> parent = root;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">"string"</span>) &#123;</div><div class="line">        name = [name];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (name.indexOf(parent.nodeName.toLowerCase()) === <span class="number">-1</span> &amp;&amp; parent.nodeName !== <span class="string">"BODY"</span> &amp;&amp; parent.nodeName !== <span class="string">"HTML"</span>) &#123;</div><div class="line">        parent = parent.parentNode;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> parent.nodeName === <span class="string">"BODY"</span> || parent.nodeName === <span class="string">"HTML"</span> ? <span class="literal">null</span> : parent;</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<h3 id="插入链接"><a href="#插入链接" class="headerlink" title="插入链接"></a>插入链接</h3><p>调用 <code>document.execCommand(&#39;createLink&#39;, false, url);</code> 方法我们可以插入一个 url 链接，但是该方法不支持插入指定文字的链接。同时对已经有链接的位置可以反复插入新的链接。为此我们需要重写此方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertLink</span>(<span class="params">url, title</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> selection = <span class="built_in">document</span>.getSelection(),</div><div class="line">        range = selection.getRangeAt(<span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span>(range.collapsed) &#123;</div><div class="line">        <span class="keyword">let</span> start = range.startContainer,</div><div class="line">            parent = Util.findParentByTagName(start, <span class="string">'a'</span>);</div><div class="line">        <span class="keyword">if</span>(parent) &#123;</div><div class="line">            parent.setAttribute(<span class="string">'src'</span>, url);</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">this</span>.insertHTML(<span class="string">`&lt;a href="<span class="subst">$&#123;url&#125;</span>"&gt;<span class="subst">$&#123;title&#125;</span>&lt;/a&gt;`</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">document</span>.execCommand(<span class="string">'createLink'</span>, <span class="literal">false</span>, url);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="设置-h1-h6-标题"><a href="#设置-h1-h6-标题" class="headerlink" title="设置 h1 ~ h6 标题"></a>设置 h1 ~ h6 标题</h3><p>浏览器没有现成的方法，但我们可以借助 <code>document.execCommand(&#39;formatBlock&#39;, false, tag)</code>, 来实现，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setHeading</span>(<span class="params">heading</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> formatTag = heading,</div><div class="line">        formatBlock = <span class="built_in">document</span>.queryCommandValue(<span class="string">"formatBlock"</span>);</div><div class="line">    <span class="keyword">if</span> (formatBlock.length &gt; <span class="number">0</span> &amp;&amp; formatBlock.toLowerCase() === formatTag) &#123;</div><div class="line">        <span class="built_in">document</span>.execCommand(<span class="string">'formatBlock'</span>, <span class="literal">false</span>, <span class="string">`&lt;<span class="subst">$&#123;<span class="keyword">this</span>.defaultParagraphSeparator&#125;</span>&gt;`</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">document</span>.execCommand(<span class="string">'formatBlock'</span>, <span class="literal">false</span>, <span class="string">`&lt;<span class="subst">$&#123;formatTag&#125;</span>&gt;`</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="插入定制内容"><a href="#插入定制内容" class="headerlink" title="插入定制内容"></a>插入定制内容</h3><p>当编辑器上传或加载附件的时候，要插入能够展示附件的 <code>&lt;div&gt;</code> 节点卡片到编辑中。这里我们借助 <code>document.execCommand(&#39;insertHTML&#39;, false, html);</code> 来插入内容。为了防止div被编辑，要设置 <code>contenteditable=&quot;false&quot;</code>哦。</p>
<h3 id="处理-paste-粘贴"><a href="#处理-paste-粘贴" class="headerlink" title="处理 paste 粘贴"></a>处理 paste 粘贴</h3><p>在富文本编辑器中，粘贴效果默认采用如下规则：   </p>
<ol>
<li>如果是带有格式的文本，则保留格式(格式会被转换成html标签的形式)</li>
<li>粘贴图文混排的内容，图片可以显示，src 为图片真实地址。</li>
<li>通过复制图片来进行粘贴的时候，不能粘入内容</li>
<li>粘贴其他格式内容，不能粘入内容  </li>
</ol>
<p>为了能够控制粘贴的内容，我们监听 <code>paste</code> 事件。该事件的 event 对象中会包含一个 clipboardData 剪切板对象。我们可以利用该对象的 getData 方法来获得带有格式和不带格式的内容，如下。   </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> plainText = event.clipboardData.getData(<span class="string">'text/plain'</span>);  <span class="comment">// 无格式文本</span></div><div class="line"><span class="keyword">let</span> plainHTML = event.clipboardData.getData(<span class="string">'text/html'</span>);   <span class="comment">// 有格式文本</span></div></pre></td></tr></table></figure>
<p>之后调用 <code>document.execCommand(&#39;insertText&#39;, false, plainText);</code> 或 <code>document.execCommand(&#39;insertHTML&#39;, false, plainHTML;</code> 来重写编辑上的paste效果。</p>
<p>然而对于规则 3 ，上述方案就无法处理了。这里我们要引入 <code>event.clipboardData.items</code> 。这是一个数组包含了所有剪切板中的内容对象。比如你复制了一张图片来粘贴，那么 <code>event.clipboardData.items</code> 的长度就为2：<br><code>items[0]</code> 为图片的名称，items[0].kind 为 ‘string’, items[0].type 为 ‘text/plain’ 或 ‘text/html’。获取内容方式如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">items[<span class="number">0</span>].getAsString(<span class="function"><span class="params">str</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">// 处理 str 即可</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><code>items[1]</code> 为图片的二进制数据，items[1].kind 为’file’， items[1].type 为图片的格式。想要获取里面的内容，我们就需要创建 <code>FileReader</code> 对象了。示例代码如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> file = items[<span class="number">1</span>].getAsFile();</div><div class="line"><span class="comment">// file.size 为文件大小</span></div><div class="line"><span class="keyword">let</span> reader = <span class="keyword">new</span> FileReader();</div><div class="line">reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// reader.result 为文件内容，就可以做上传操作了</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>(<span class="regexp">/image/</span>.test(item.type)) &#123;</div><div class="line">    reader.readAsDataURL(file);   <span class="comment">// 读取为 base64 格式</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>处理完图片，那么对于复制粘贴其他格式内容会怎么样呢？在 mac 中，如果你复制一个磁盘文件，event.clipboardData.items 的长度为 2。 items[0] 依然为文件名，然而 items[1] 则为图片了，没错，是文件的缩略图。  </p>
<h3 id="输入法处理"><a href="#输入法处理" class="headerlink" title="输入法处理"></a>输入法处理</h3><p>当使用输入发的时候，有时候会发生一些意想不到的事情。 比如百度输入法可以输入一张本地图片，为此我们需要监听输入法产生的内容做处理。这里通过如下两个事件处理： </p>
<ul>
<li>compositionstart: 当浏览器有非直接的文字输入时, compositionstart事件会以同步模式触发</li>
<li>compositionend: 当浏览器是直接的文字输入时, compositionend会以同步模式触发</li>
</ul>
<h2 id="修复移动端的问题"><a href="#修复移动端的问题" class="headerlink" title="修复移动端的问题"></a>修复移动端的问题</h2><p>在移动端，富文本编辑器的问题主要集中在光标和键盘上面。我这里介绍几个比较大的坑。  </p>
<h3 id="自动获取焦点"><a href="#自动获取焦点" class="headerlink" title="自动获取焦点"></a>自动获取焦点</h3><p>如果想让我们的编辑器自动获得焦点，弹出软键盘，可以利用 <code>focus()</code> 方法。然而在 ios 下，死活没有结果。这主要是因为 ios safari 中，为了安全考虑不允许代码获得焦点。只能通过用户交互点击才可以。还好，这一限制可以去除： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self.appWebView setKeyboardDisplayRequiresUserAction:NO]</div></pre></td></tr></table></figure>
<h3 id="iOS-下回车换行，滚动条不会自动滚动"><a href="#iOS-下回车换行，滚动条不会自动滚动" class="headerlink" title="iOS 下回车换行，滚动条不会自动滚动"></a>iOS 下回车换行，滚动条不会自动滚动</h3><p>在 iOS 下，当我们回车换行的时候，滚动条并不会随着滚动下去。这样光标就可能被键盘挡住，体验不好。为了解决这一问题，我们就需要监听 <code>selectionchange</code> 事件，触发时，计算每次光标编辑器顶端距离，之后再调用 window.scroll() 即可解决。问题在于我们要如何计算当前光标的位置，如果仅是计算光标所在父元素的位置很有可能出现偏差(多行文本计算不准)。我们可以通过创建一个临时 <code>&lt;span&gt;</code> 元素查到光标位置，计算<code>&lt;span&gt;</code>元素的位置即可。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCaretYPosition</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> sel = <span class="built_in">window</span>.getSelection(),</div><div class="line">        range = sel.getRangeAt(<span class="number">0</span>);</div><div class="line">    <span class="keyword">let</span> span = <span class="built_in">document</span>.createElement(<span class="string">'span'</span>);</div><div class="line">    range.collapse(<span class="literal">false</span>);</div><div class="line">    range.insertNode(span);</div><div class="line">    <span class="keyword">var</span> topPosition = span.offsetTop;</div><div class="line">    span.parentNode.removeChild(span);</div><div class="line">    <span class="keyword">return</span> topPosition;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>正当我开心的时候，安卓端反应，编辑器越编辑越卡。什么鬼？我在 chrome 上线检查了一下，发现 <code>selectionchange</code> 函数一直在运行，不管有没有操作。<br>在逐一排查的时候发现了这么一个事实。<code>range.insertNode</code> 函数同样触发 <code>selectionchange</code> 事件。这样就形成了一个死循环。这个死循环在 safari 中就不会产生，只出现在 safari 中，为此我们就需要加上浏览器类型判断了。  </p>
<h3 id="键盘弹起遮挡输入部分"><a href="#键盘弹起遮挡输入部分" class="headerlink" title="键盘弹起遮挡输入部分"></a>键盘弹起遮挡输入部分</h3><p>网上对于这个问题主要的方案就是，设置定时器。局限与前端，确实只能这采用这样笨笨的解决。最后我们让 iOS 同学在键盘弹出的时候，将 webview 高度减去软键盘高度就解决了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CGFloat webviewY = 64.0 + self.noteSourceView.height;</div><div class="line">self.appWebView.frame = CGRectMake(0, webviewY, BDScreenWidth, BDScreenHeight - webviewY - height);</div></pre></td></tr></table></figure>
<h3 id="插入图片失败"><a href="#插入图片失败" class="headerlink" title="插入图片失败"></a>插入图片失败</h3><p>在移动端，通过调用 jsbridge 来唤起相册选择图片。之后调用 <code>insertImage</code> 函数来向编辑器插入图片。然而，插入图片一直失败。最后发现是因为早 safari 下，如果编辑器失去了焦点，那么 <code>selection</code> 和 <code>range</code> 对象将销毁。因此调用 <code>insertImage</code> 时，并不能获得光标所在位置，因此失败。为此需要增加，<code>backupRange()</code> 和 <code>restoreRange()</code> 函数。当页面失去焦点的时候记录 range 信息，插入图片前恢复 range 信息。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">backupRange() &#123;</div><div class="line">    <span class="keyword">let</span> selection = <span class="built_in">window</span>.getSelection();</div><div class="line">    <span class="keyword">let</span> range = selection.getRangeAt(<span class="number">0</span>);</div><div class="line">    <span class="keyword">this</span>.currentSelection = &#123;</div><div class="line">        <span class="string">"startContainer"</span>: range.startContainer,</div><div class="line">        <span class="string">"startOffset"</span>: range.startOffset,</div><div class="line">        <span class="string">"endContainer"</span>: range.endContainer,</div><div class="line">        <span class="string">"endOffset"</span>: range.endOffset</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">restoreRange() &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.currentSelection) &#123;</div><div class="line">        <span class="keyword">let</span> selection = <span class="built_in">window</span>.getSelection();</div><div class="line">            selection.removeAllRanges();</div><div class="line">        <span class="keyword">let</span> range = <span class="built_in">document</span>.createRange();</div><div class="line">        range.setStart(<span class="keyword">this</span>.currentSelection.startContainer, <span class="keyword">this</span>.currentSelection.startOffset);</div><div class="line">        range.setEnd(<span class="keyword">this</span>.currentSelection.endContainer, <span class="keyword">this</span>.currentSelection.endOffset);</div><div class="line">        <span class="comment">// 向选区中添加一个区域</span></div><div class="line">        selection.addRange(range);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 chrome 中，失去焦点并不会清除 <code>seleciton</code> 对象和 <code>range</code> 对象，这样我们轻轻松松一个 <code>focus()</code> 就搞定了。  </p>
<p>重要问题就这么多，限于篇幅限制其他的问题省略了。总体来说，填坑花了开发的大部分时间。  </p>
<h1 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h1><p>基础功能修修补补以后，实际项目中有可能遇到一些其他的需求，比如当前光标所在文字内容状态啊，图片拖拽放大啊，待办列表功能，附件卡片等功能啊，markdown切换等等。在了解了js 富文本的种种坑之后，range 对象的操作之后，相信这些问题你都可以轻松解决。这里最后提几个做扩展功能时候遇到的有去的问题。  </p>
<h2 id="回车换行带格式"><a href="#回车换行带格式" class="headerlink" title="回车换行带格式"></a>回车换行带格式</h2><p>前面已经说过了，富文本编辑器的机制就是这样，当你回车换行的时候新产生的内容和之前的格式一模一样。如果我们利用 <code>.card</code> 类来定义了一个卡片内容，那么换行产生的新的段落都将含有 <code>.card</code> 类且结构也是直接 copy 过来的。我们想要屏蔽这种机制，于是尝试在 keydown 的阶段做处理(如果在 keyup 阶段处理用户体验不好)。然而，并没有什么用，因为用户自定义的 keydown 事件要在 浏览器富文本的默认 keydown 事件之前触发，这样你就做不了任何处理。<br>为此我们为这类特殊的个体都添加一个 property 属性，添加在 property 上的内容是不会被copy下来的。这样以后就可以区分出来了，从而做对应的处理。  </p>
<h2 id="获取当前光标所在处样式"><a href="#获取当前光标所在处样式" class="headerlink" title="获取当前光标所在处样式"></a>获取当前光标所在处样式</h2><p>这里主要是考虑 下划线，删除线之类的样式，这些样式都是用标签类描述的，所以要遍历标签层级。直接上代码：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCaretStyle</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> selection = <span class="built_in">window</span>.getSelection(),</div><div class="line">        range = selection.getRangeAt(<span class="number">0</span>);</div><div class="line">        aimEle = range.commonAncestorContainer,</div><div class="line">        tempEle = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">let</span> tags = [<span class="string">"U"</span>, <span class="string">"I"</span>, <span class="string">"B"</span>, <span class="string">"STRIKE"</span>],</div><div class="line">        result = [];</div><div class="line">    <span class="keyword">if</span>(aimEle.nodeType === <span class="number">3</span>) &#123;</div><div class="line">        aimEle = aimEle.parentNode;</div><div class="line">    &#125;</div><div class="line">    tempEle = aimEle;</div><div class="line">    <span class="keyword">while</span>(block.indexOf(tempEle.nodeName.toLowerCase()) === <span class="number">-1</span>) &#123;</div><div class="line">        <span class="keyword">if</span>(tags.indexOf(tempEle.nodeName) !== <span class="number">-1</span>) &#123;</div><div class="line">            result.push(tempEle.nodeName);</div><div class="line">        &#125;</div><div class="line">        tempEle = tempEle.parentNode;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">let</span> viewStyle = &#123;</div><div class="line">        <span class="string">"italic"</span>: result.indexOf(<span class="string">"I"</span>) !== <span class="number">-1</span> ? <span class="literal">true</span> : <span class="literal">false</span>,</div><div class="line">        <span class="string">"underline"</span>: result.indexOf(<span class="string">"U"</span>) !== <span class="number">-1</span> ? <span class="literal">true</span> : <span class="literal">false</span>,</div><div class="line">        <span class="string">"bold"</span>: result.indexOf(<span class="string">"B"</span>) !== <span class="number">-1</span> ? <span class="literal">true</span> : <span class="literal">false</span>,</div><div class="line">        <span class="string">"strike"</span>: result.indexOf(<span class="string">"STRIKE"</span>) !== <span class="number">-1</span> ? <span class="literal">true</span> : <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">let</span> styles = <span class="built_in">window</span>.getComputedStyle(aimEle, <span class="literal">null</span>);</div><div class="line">    viewStyle.fontSize = styles[<span class="string">"fontSize"</span>],</div><div class="line">    viewStyle.color = styles[<span class="string">"color"</span>],</div><div class="line">    viewStyle.fontWeight = styles[<span class="string">"fontWeight"</span>],</div><div class="line">    viewStyle.fontStyle = styles[<span class="string">"fontStyle"</span>],</div><div class="line">    viewStyle.textDecoration = styles[<span class="string">"textDecoration"</span>];</div><div class="line">    viewStyle.isH1 = Util.findParentByTagName(aimEle, <span class="string">"h1"</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</div><div class="line">    viewStyle.isH2 = Util.findParentByTagName(aimEle, <span class="string">"h2"</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</div><div class="line">    viewStyle.isP = Util.findParentByTagName(aimEle, <span class="string">"p"</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</div><div class="line">    viewStyle.isUl = Util.findParentByTagName(aimEle, <span class="string">"ul"</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</div><div class="line">    viewStyle.isOl = Util.findParentByTagName(aimEle, <span class="string">"ol"</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</div><div class="line">    <span class="keyword">return</span> viewStyle;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="最后说一句"><a href="#最后说一句" class="headerlink" title="最后说一句"></a>最后说一句</h1><p>该项目目前提测中，所以呢，一但发现有意思的坑，我会及时补充的。  </p>
<h1 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h1><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/execCommand" target="_blank" rel="external">MDN - document.execCommand</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Selection" target="_blank" rel="external">MDN - selection</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Range" target="_blank" rel="external">MDN - range</a>  </li>
<li><a href="http://frontenddev.org/article/compatible-with-processing-and-chinese-input-method-to-optimize-the-input-events.html" target="_blank" rel="external">input 事件兼容处理以及中文输入法优化</a></li>
<li><a href="https://segmentfault.com/a/1190000004288686" target="_blank" rel="external">js获取剪切板内容，js控制图片粘贴</a></li>
<li><a href="http://blog.csdn.net/ll845876425/article/details/51884736" target="_blank" rel="external">iOS UIWebView 全属性详解</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期项目中需要开发一个兼容PC和移动端的富文本编辑器，其中包含了一些特殊的定制功能。考察了下现有的js富文本编辑器，桌面端的很多，移动端的几乎没有。桌面端以UEditor为代表。但是我们并不打算考虑兼容性，所以没有必要采用UEditor这么重的插件。为此决定自研一个富文本编辑器。本文，主要介绍如何实现富文本编辑器，和解决一些不同浏览器和设备之间的bug。&lt;br&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="富文本编辑器" scheme="http://yoursite.com/tags/%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据响应系统原理解析</title>
    <link href="http://yoursite.com/2017/08/21/%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2017/08/21/数据响应系统原理解析/</id>
    <published>2017-08-21T11:36:49.000Z</published>
    <updated>2017-08-21T11:36:49.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>移动端交互手势详解与实现</title>
    <link href="http://yoursite.com/2016/08/23/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%BA%A4%E4%BA%92%E6%89%8B%E5%8A%BF%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2016/08/23/移动端交互手势详解与实现/</id>
    <published>2016-08-23T11:09:51.000Z</published>
    <updated>2017-09-22T07:17:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一丶概述"><a href="#一丶概述" class="headerlink" title="一丶概述"></a>一丶概述</h2><p>如今移动端设备大行其道，前端也走进了移动的领域。在写移动端页面的交互效果的时候，我么难免要接触一些复杂的手势，而不仅仅像pc端那样简单的鼠标事件。手势实际上是一种输入模式。我们现在在直观意义上理解的人机交互是指人与机器之间的互动方式，这种互动方式经历了鼠标、物理硬件、屏幕触控、远距离的体感操作的逐步发展的过程。<br><a id="more"></a></p>
<h2 id="二丶移动端手势事件"><a href="#二丶移动端手势事件" class="headerlink" title="二丶移动端手势事件"></a>二丶移动端手势事件</h2><p>在浏览器中，为我们提供的手势并不算多，主要有：</p>
<ul>
<li>touchstart 当手指触摸屏幕时触发</li>
<li>touchmove 当手指在屏幕滑动时不断的触发</li>
<li>touchend 当手指从屏幕上移开时触发</li>
<li>touchcancel 当系统停止跟踪触摸时触发  </li>
</ul>
<p>是不是感觉很少，safari还为我们提供了三个独有的手势事件(用于复杂的手势)，然而也仅仅只能在safari中使用  </p>
<ul>
<li>gesturestart 当一个手指已经按在屏幕上，另一个手指也按上时触发</li>
<li>gesturechange 当触摸屏幕上任何一个手指发生变化时触发</li>
<li>gestureend 当任何一个手指从屏幕上移开时触发   2</li>
</ul>
<img src="/2016/08/23/移动端交互手势详解与实现/1.png" alt="1.png" title="">  
<p>最后呢，让我们看看移动设备上究竟有哪儿手势需要我们使用<br><img src="/2016/08/23/移动端交互手势详解与实现/2.png" alt="2.png" title=""></p>
<h2 id="三丶让JS支持这些手势"><a href="#三丶让JS支持这些手势" class="headerlink" title="三丶让JS支持这些手势"></a>三丶让JS支持这些手势</h2><p>目前看来，我们能用的也就只有touchstart，touchmove, touchend, touchcancel这四个手势，那么如何才能利用这四个手势支持众多的交互效果呢？首先我们从最简单的手势开始。简单的手势也就是说是单点触控，我们主要来实现如下几个手势：    </p>
<ul>
<li>tap 轻触</li>
<li>doubletap 连续两次轻触</li>
<li>press 长按</li>
<li>pan 平移</li>
<li>flick 轻拂  </li>
</ul>
<p>首先我们要解决如何触发自定义事件(已经了解自定事件的可以跳过)：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//自定义一个事件</span></div><div class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">"tap"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"tap事件触发"</span>)</div><div class="line">&#125;, <span class="literal">false</span>)  </div><div class="line"><span class="comment">//触发自定义事件  </span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fireEvent</span>(<span class="params">element, type, extra</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> event = doc.createEvent(<span class="string">'HTMLEvents'</span>);</div><div class="line">    event.initEvent(type, <span class="literal">true</span>, <span class="literal">true</span>);</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> extra === <span class="string">'object'</span>) &#123;</div><div class="line">        Util.extends(event, extra);     <span class="comment">//浅拷贝</span></div><div class="line">    &#125;</div><div class="line">    element.dispatchEvent(event);</div><div class="line">&#125;</div><div class="line">fireEvent(<span class="built_in">document</span>.body, <span class="string">"tap"</span>, &#123;&#125;);   <span class="comment">//触发tap事件</span></div></pre></td></tr></table></figure>
<p>我们在整个事件模拟中定义一个中间状态 <code>evet.status</code> 来表示当前的触摸状态，接下来我们就利用 touchstart，touchmove，touchend 来可以实现自己的触摸事件了:  </p>
<ul>
<li>tap事件：当touchstart触发时，我们将event.status状态改为 tapping。在touchend触发时，如果event.status依然为tapping则，触发tap事件。  </li>
<li>doubletap事件：在触发tap事件的时候，我们用一个变量lastTime记录当前时间。下一次触发tap时，用当前时间和lastTime做对比，如果小于300ms则触发doubletap事件  </li>
<li>pess事件：当touchstart触发时，我们定义一个setTimeout的函数(500ms)，如果500ms后仍然没有touchend触发，则定时函数将event.staus状态改为pressing。当touchend触发时，检测到状态为pressing则触发press事件。  </li>
<li>pan事件：我们在touchmove中检测当前状态是tapping和pressing时，并且手指移动距离大于10px则，触发pan平移事件。这个移动距离用event.touches[0].clientX - lastTouch.clientY 来检测就好(利用lastTouch记录，起始手指的event对象)。  </li>
<li>flick事件：这个事件就是”刷~刷”的划过屏幕的交互效果，在touchend时通过pan事件的移动距离和移动事件算出速度(注意是X和Y轴的合速度)，如果速度大于0.5，并且整个触摸过程时间小于100ms，则触发flick事件。  </li>
</ul>
<p>是不是很简单的用最原始的浏览器事件就能实现这些内容。接下来让我们看看两个手指的事件如果实现。  </p>
<h2 id="四丶实现多指触控"><a href="#四丶实现多指触控" class="headerlink" title="四丶实现多指触控"></a>四丶实现多指触控</h2><p>在实现多指触控的时候，我们需要了解一下触摸过程中event用来保存多个手指信息的三个属性：  </p>
<ul>
<li>touches当前屏幕上所有触摸点的集合列表</li>
<li>targetTouches绑定事件的那个结点上的触摸点的集合列表</li>
<li>changedTouches触发事件时改变的触摸点的集合    </li>
</ul>
<p>这三个有什么区别？举例来说，比如div1, div2只有div2绑定了touchstart事件，第一次放下一个手指在div2上，触发了touchstart事件，这个时候，三个集合的内容是一样的，都包含这个手指的touch，然后，再放下两个手指一个在div1上，一个在div2上，这个时候又会触发事件，但changedTouches里面只包含第二个第三个手指的信息，因为第一个没有发生变化，而targetTouches包含的是在第一个手指和第三个在div2上的手指集合，touches包含屏幕上所有手指的信息，也就是三个手指。这样是不是就很很清楚了。下面我们要根据上面的内容，继续解决一个问题：当两个手指作用在不同的节点上应该触发哪个节点的事件呢？<br>这里我们规定，如果触发在了两个不同节点上，我们去两个节点公有的最近父节点，作为触发的目标。寻找共有最小父节点代码如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//判断节点ele1是否包含ele2</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">contains</span>(<span class="params">ele1, ele2</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> ele1.contains ? ele1 != ele2 &amp;&amp; ele1.contains(ele2) : !!(ele1.compareDocumentPosition(ele2) &amp; <span class="number">16</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//获得共有最近的父节点</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCommonRootNode</span>(<span class="params">ele1, ele2</span>) </span>&#123;</div><div class="line">    <span class="keyword">while</span> (ele1) &#123;</div><div class="line">        <span class="keyword">if</span> (contains(ele1, ele2) || ele1 === ele2) &#123;</div><div class="line">            <span class="keyword">return</span> ele1;</div><div class="line">        &#125;</div><div class="line">        ele1 = ele1.parentNode;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 这样我们解决了，如何找到多个手指信息和触发哪个节点的问题。最后一个问题，当给了我们这些信息我们怎么能用？比如计算旋转手势，缩放手势啊什么的。<br> 这里我们仅考虑两个手指的多点触控。我们设touchstart阶段的两个手指坐标为 A(x1, y1)   B(x2, y2)。touchmove过程中的两个手指的坐标为 C(x3, y3) D(x4, y4)。  </p>
<ul>
<li>rotate旋转：计算AB，CD线段与坐标轴的夹角，对角度相减即得到旋转角度。  </li>
<li>scale 缩放：计算AB线段长度和CD线段长度(勾股定理)，两条线段做比值就好。  </li>
<li>translate平移： 平移的话我们只计算A点到C点的x坐标变化量。   </li>
</ul>
<p>具体代码如下：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">calcAction</span>(<span class="params">x1, y1, x2, y2, x3, y3, x4, y4</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> rotate = <span class="built_in">Math</span>.atan2(y4 - y3, x4 - x3) - <span class="built_in">Math</span>.atan2(y2 - y1, x2 - x1),</div><div class="line">        scale = <span class="built_in">Math</span>.sqrt((<span class="built_in">Math</span>.pow(y4 - y3, <span class="number">2</span>) + <span class="built_in">Math</span>.pow(x4 - x3, <span class="number">2</span>)) / (<span class="built_in">Math</span>.pow(y2 - y1, <span class="number">2</span>) + <span class="built_in">Math</span>.pow(x2 - x1, <span class="number">2</span>))),</div><div class="line">            translate = [x3 - scale * x1 * <span class="built_in">Math</span>.cos(rotate) + scale * y1 * <span class="built_in">Math</span>.sin(rotate), y3 - scale * y1 * <span class="built_in">Math</span>.cos(rotate) - scale * x1 * <span class="built_in">Math</span>.sin(rotate)];</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        rotate: rotate,</div><div class="line">        scale: scale,</div><div class="line">        translate: translate,</div><div class="line">            <span class="comment">/**</span></div><div class="line"><span class="comment">             * |ax + cy + e|</span></div><div class="line"><span class="comment">             * |bx + dy + f|</span></div><div class="line"><span class="comment">             * | 0 +  0 + 1|</span></div><div class="line"><span class="comment">             */</span></div><div class="line">        martrix: [</div><div class="line">            [scale * <span class="built_in">Math</span>.cos(rotate), -scale * <span class="built_in">Math</span>.sin(rotate), translate[<span class="number">0</span>]],</div><div class="line">            [scale * <span class="built_in">Math</span>.sin(rotate), scale * <span class="built_in">Math</span>.cos(rotate), translate[<span class="number">1</span>]],</div><div class="line">            [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</div><div class="line">        ]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 了解这些内容，你就可以在touchmove过程中完成对两个手指的旋转缩放平移等交互效果进行封装了。是不是很简单呢！<br> 当然完整的事件过程要分start，move，end这三种情况，在实现的时候要分别给予对应的实现就可以了。都逃不开对touchstart，touchmove，touchend的利用。  </p>
<h1 id="五丶实现案例"><a href="#五丶实现案例" class="headerlink" title="五丶实现案例"></a>五丶实现案例</h1><p>基于上面的方案，我实现了一个对移动端手势的封装库，包含以上所有的手势。犹豫这里代码运行不能模拟手机环境，我就不贴代码了。 感兴趣的同学可以访问：<a href="https://github.com/T-phantom/si-gesture" target="_blank" rel="external">https://github.com/T-phantom/si-gesture</a> 上面有具体的使用方法和带有详细注释的源码哦，欢迎start。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一丶概述&quot;&gt;&lt;a href=&quot;#一丶概述&quot; class=&quot;headerlink&quot; title=&quot;一丶概述&quot;&gt;&lt;/a&gt;一丶概述&lt;/h2&gt;&lt;p&gt;如今移动端设备大行其道，前端也走进了移动的领域。在写移动端页面的交互效果的时候，我么难免要接触一些复杂的手势，而不仅仅像pc端那样简单的鼠标事件。手势实际上是一种输入模式。我们现在在直观意义上理解的人机交互是指人与机器之间的互动方式，这种互动方式经历了鼠标、物理硬件、屏幕触控、远距离的体感操作的逐步发展的过程。&lt;br&gt;
    
    </summary>
    
      <category term="移动开发" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="移动开发" scheme="http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>CORS 跨域数据交互</title>
    <link href="http://yoursite.com/2016/08/22/CORS-%E8%B7%A8%E5%9F%9F%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92/"/>
    <id>http://yoursite.com/2016/08/22/CORS-跨域数据交互/</id>
    <published>2016-08-22T04:09:20.000Z</published>
    <updated>2017-09-22T07:01:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="跨域数据交互"><a href="#跨域数据交互" class="headerlink" title="跨域数据交互  "></a>跨域数据交互  </h1><p>在实际项目中，ajax 经常应用在跨域通信的场景下，如果采用 jsonp 来实现跨域，需要对前后端代码有很大的改动。而且， jsonp 仅支持 get 请求<br>跨域。为此我们必须寻找一个简单的跨域通信方式 - CORS。<br><a id="more"></a></p>
<h1 id="什么是-CORS"><a href="#什么是-CORS" class="headerlink" title="什么是 CORS"></a>什么是 CORS</h1><p>CORS是一种允许当前域（domain）的资源（比如html/js/web service）被其他域（domain）的脚本请求访问的机制。使用CORS，可以通过普通的XMLHttpRequest发起请求和获得数据，并且支持各种类型请求。说白了就是利用XMLHttpRequest来实现跨站通信，而不是仅仅遵循同源策略，再也不用为了ajax能跨域写苦逼的jsonp了。  CORS技术现在已经被广泛的支持了。 兼容性如下：<br><img src="/2016/08/22/CORS-跨域数据交互/js12-1.png" alt="js12-1.png" title=""><br>CORS 兼容大部分浏览器， IE8 及其以下就自求多福吧。  </p>
<h1 id="CORS-使用方法及场景举例"><a href="#CORS-使用方法及场景举例" class="headerlink" title="CORS 使用方法及场景举例"></a>CORS 使用方法及场景举例</h1><p>所谓的跨域请求，从本质上来说并不是浏览器对其他域名的请求不能发送，而是请求可以正常发起，<br>但是浏览器在收到服务器信息后就屏蔽掉了，并向前端报错(跨域)。如图所示，跨域请求结果被屏蔽。<br><img src="/2016/08/22/CORS-跨域数据交互/js12-2.png" alt="js12-2.png" title=""><br>解决方案，服务器在响应HTTP头部加入 <code>Access-Control-Allow-Origin：*</code>即可，这样就表示服务端同意任意域名的请求。<br>一般我们会指定可响应的域名如：<code>Access-Control-Allow-Origin: http://b.com, http://c.com</code>等。这样浏览器在检测到服务端HTTP头部的时候就可以不再拦截响应。<br>请求头部：<br><img src="/2016/08/22/CORS-跨域数据交互/js12-3.png" alt="js12-3.png" title=""><br>响应头部：<br><img src="/2016/08/22/CORS-跨域数据交互/js12-4.png" alt="js12-4.png" title=""><br>就在我们以为轻松搞定的时候，我们又遇到了问题。前端要给后端传json格式的数据于是在http头部加入了<br><code>content-type: application/json</code>, <code>access_token</code>等信息。请求再次失败，通过观察控制台信息我们发现，多了一个请求<code>options</code>:<br><img src="/2016/08/22/CORS-跨域数据交互/js12-5.png" alt="js12-5.png" title=""><br>原来在CORS中的请求分为两种：简单请求和复杂请求    </p>
<h2 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h2><ol>
<li>只使用GET，HEAD或者POST。如果使用POST来发送数据到服务器，那么使用HTTP POST请求发送到服务器的数据的Content-Type为以下几种之一：application/x-www-form-urlencoded，multipart/form-data以及text/plain。  </li>
<li>不使用HTTP请求发送定制请求头（例如X-Modified等）  </li>
</ol>
<p>在简单请求下，我们只需要像上面所说设置Access-Control-Allow-Origin头部即可。  </p>
<h2 id="复杂请求"><a href="#复杂请求" class="headerlink" title="复杂请求"></a>复杂请求</h2><ol>
<li>使用了除GET，HEAD和POST以外的方法。如果使用POST方法发送请求数据时的<code>Content-Type</code>不是<code>application/x-www-form-urlencoded，multipart/form-data</code>或者<code>text/plaint</code>。例如，如果POST请求向服务器使用application/xml或者text/xml向服务器发送请求，那么这个请求就是preflighted的。</li>
<li>设置了定制请求头的请求（例如，请求使用了例如X-PINGOTHER这样的请求头）。这类请求在发送正式请求之前会发送一个<code>Preflighted(预请求)</code>，<code>Preflighted</code>请求首先通过HTTP OPTIONS方法请求其他域上的资源，以确定发送实际的请求是否安全。这样做，是因为跨站请求可能会对目的站点的数据造成破坏。我们第二次发的请求是一个复杂请求，服务端没有响应options的方法，导致预请求失败，之后的请求也就终止了。我们看一下复杂请求下的HTTP报文:  </li>
</ol>
<p>Prelignted请求头部：<br><img src="/2016/08/22/CORS-跨域数据交互/js12-6.png" alt="js12-6.png" title=""><br>可以看到报文头部信息为OPTIONS请求<br>预请求服务端响应报文<br><img src="/2016/08/22/CORS-跨域数据交互/js12-7.png" alt="js12-7.png" title=""><br>预请求响应只要返回一个2xx表示成功的响应信息即可说明服务端同意了跨域请求，<br>这里我们选择204的状态码作为响应状态。因为<code>204</code>表示响应成功，并且没有结果返回的状态。这样节省了传输信息的事件，加快了预请求的处理。<br>预处理结束后，事情并没有就此解决。错误信息再次传来。<br><br>原来我们自定义了头部信息，还要在响应报文中加入<code>Access-Control-Allow-Headers</code>来指出服务端允许的复杂请求需要的自定义头部信息。注意这里不能用*来表示所有，<br>只能一个个添加。例如：<code>&quot;Access-Control-Allow-Methods&quot; : &quot;PUT,POST,GET,DELETE,OPTIONS&quot;</code>。<br>这样就齐活了，总算是数据可以流通了。这里我建议在服务端响应部分也加入 <code>&quot;Access-Control-Allow-Methods&quot; : &quot;PUT,POST,GET,DELETE,OPTIONS&quot;</code>来指出可接受的请求类型。<br>最后我们的服务端响应头部信息：<br> </p>
<h2 id="附带凭证信息的请求"><a href="#附带凭证信息的请求" class="headerlink" title="附带凭证信息的请求"></a>附带凭证信息的请求</h2><p>我手贱的在xhr中加入了 <code>xhr.withCredentials = true</code> 因为跨源请求默认请求头部中不提供凭据(cookie、HTTP认证及客户端SSL证明等)。<br>为了能把这些信息带上，我们设置了withCredentials为true。浏览器再次报错，通过检查我们发现，<br>如果你设置了withCredentials为true那么 Access-Control-Allow-Origin就不能用 * ，必须使用明确的域名。<br>而且还要为你的响应头加上<code>&quot;Access-Control-Allow-Credentials&quot;:&quot;true&quot;</code>信息。<br>最后我列出CORS中可能使用的头部信息供大家参考：  </p>
<ul>
<li><p><strong>HTTP响应头</strong>：Access-Control-Allow-Origin，Access-Control-Expose-Headers，Access-Control-Max-Age，<br>Access-Control-Allow-Credentials，Access-Control-Allow-Methods，Access-Control-Allow-Headers      </p>
</li>
<li><p><strong>HTTP请求头</strong>：Origin，Access-Control-Request-Method，Access-Control-Request-Headers   </p>
</li>
</ul>
<p>附上用Node.js跨域请求服务端的简单配置：  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>),</div><div class="line">    app = express();</div><div class="line">    </div><div class="line"><span class="comment">//统一拦截请求设置头部信息，响应预请求</span></div><div class="line">app.all(<span class="string">'*'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">    res.set(&#123;</div><div class="line">        <span class="string">"Access-Control-Allow-Origin"</span>: <span class="string">"*"</span>,</div><div class="line">        <span class="string">"Access-Control-Allow-Headers"</span>: <span class="string">"Content-Type,access_token,user_id"</span>,</div><div class="line">        <span class="string">"Access-Control-Allow-Methods"</span>: <span class="string">"PUT,POST,GET,DELETE,OPTIONS"</span></div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(req.method==<span class="string">"OPTIONS"</span>) &#123;</div><div class="line">        res.send(<span class="number">204</span>);</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        next();</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">app.post(<span class="string">"/data"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</div><div class="line">    res.json(&#123;</div><div class="line">        status: <span class="string">"success"</span>,</div><div class="line">        text: <span class="string">"返回数据"</span></div><div class="line">    &#125;)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">app.listen(<span class="number">3000</span>, <span class="string">"127.0.0.1"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"服务器启动了"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h1 id="跨域请求的其他方案"><a href="#跨域请求的其他方案" class="headerlink" title="跨域请求的其他方案"></a>跨域请求的其他方案</h1><p>这里列举一下其他常用的跨域方案，仅供参考:    </p>
<ol>
<li><code>jsonp</code>：利用 <code>&lt;script&gt;</code> 元素的这个开放策略，网页可以得到从其他来源动态产生的 JSON 资料，而这种使用模式就是所谓的 JSONP。用 JSONP 抓到的资料并不是 JSON，而是任意的JavaScript，用 JavaScript 直译器执行而不是用 JSON 解析器解析。  </li>
<li><code>postMessage</code>：postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。  </li>
<li><code>websocket</code>：WebSocket实现了全双工通信，使WEB上的真正的实时通信成为可能。浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。  </li>
<li><code>SSE</code>：Server-Sent Events(SSE)功能，允许服务端推送数据到客户端(通常叫数据推送)。已经在浏览器上普遍支持，然而IE和Edge全系列不支持。</li>
<li><code>ServiceWorker</code>：一个 service worker 是一段运行在浏览器后台进程里的脚本，它独立于当前页面，提供了那些不需要与web页面交互的功能在网页背后悄悄执行的能力。在将来，基于它可以实现消息推送，静默更新以及地理围栏等服务，但是目前它首先要具备的功能是拦截和处理网络请求，包括可编程的响应缓存管理。简而言之，这是让浏览器具有服务器功能的API，有了他还跨域个球球。不过这只是实验中API目前只有chrome和firfox高版本浏览器支持。   </li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;跨域数据交互&quot;&gt;&lt;a href=&quot;#跨域数据交互&quot; class=&quot;headerlink&quot; title=&quot;跨域数据交互  &quot;&gt;&lt;/a&gt;跨域数据交互  &lt;/h1&gt;&lt;p&gt;在实际项目中，ajax 经常应用在跨域通信的场景下，如果采用 jsonp 来实现跨域，需要对前后端代码有很大的改动。而且， jsonp 仅支持 get 请求&lt;br&gt;跨域。为此我们必须寻找一个简单的跨域通信方式 - CORS。&lt;br&gt;
    
    </summary>
    
      <category term="浏览器" scheme="http://yoursite.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript 类与继承</title>
    <link href="http://yoursite.com/2015/05/03/javascript-%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF/"/>
    <id>http://yoursite.com/2015/05/03/javascript-类与继承/</id>
    <published>2015-05-03T10:59:31.000Z</published>
    <updated>2017-08-22T10:02:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类的创建"><a href="#类的创建" class="headerlink" title="类的创建"></a>类的创建</h1><p>在面向对象语言中，类是面向对象的基础，并且具有棉线的层次概念和继承关系。Javascript中并没有类的概念，Javascript是基于对象的弱类型语言，以对象为基础，以函数为模型，以原形为继承机制的一种模式。创建一个简单的对象，就是创建一个Object类的实例。虽然Object构造函数或对象字面量可以用来创建单个对象，但是这些对象都是基于Object这一个类。为此我们需要创建自己的类，Javascript中创建类的方式有很多种：工厂模式，构造函数模式，原形模式，动态原形模式，寄生构造模式，稳妥构造模式。<br><a id="more"></a></p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>通过函数把一个类型实例包装起来，这样可以通过函数来实现类型的实例化；但是这只是一种伪装的构造函数，而且instanceof判断会发现创建的对象并不属于自己定义的类而是Object不推荐使用     </p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>) </span>{
    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();    <span class="comment">//Object创建对象</span>
    o.name = name;
    o.age = age;
    <span class="keyword">return</span> o;
}
<span class="keyword">var</span> per1 = Person(<span class="string">"tian"</span>,<span class="number">11</span>);
per1 <span class="keyword">instanceof</span> Person;   <span class="comment">//false</span>
per1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>;   <span class="comment">//true</span>
</code></pre>
<h2 id="原形模式"><a href="#原形模式" class="headerlink" title="原形模式"></a>原形模式</h2><p>声明一个构造函数，利用构造函数的prototype属性为该构造函数定义原形属性（原形prototype是Javascript核心特性之一，设计的目的就是用来实现继承的，从予以角度分析，prototype就是构造类拥有的原始成员。注意对象是没有原形的，只有构造函数拥有原形)；  </p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>{

}
Person.prototype = {
        name : <span class="string">"tian"</span>,
        age : <span class="number">21</span>,
        run : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">"在跑步"</span>);
        }                                                                                                                
}
<span class="keyword">var</span> per1 = <span class="keyword">new</span> Person(<span class="string">"tian"</span>, <span class="number">12</span>);
</code></pre>
<p>一般的我们把定义在原形上的方法叫做原形方法，他们被所有对象共享，也就是只有一份。这样就解决了构造模式的缺点，但是又没有特权方法||属性。于是，我们参考以上这几种方法，就可以得到目前最常用的类的创建方法。  </p>
<h2 id="组合模式（构造原形模式）"><a href="#组合模式（构造原形模式）" class="headerlink" title="组合模式（构造原形模式）"></a>组合模式（构造原形模式）</h2><p>可以看出这是原型模式和构造模式的组合，构造函数中我们放入特权属性和特权方法，他们每一个实例就是一个副本，互不影响。在内部还可以放入var 声明的变量作为私有属性。把公共的方法给原形，这样就可以通用。  </p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>{
        <span class="keyword">this</span>.name = name;        <span class="comment">//特权方法</span>
        <span class="keyword">this</span>.age = age;
        <span class="keyword">var</span> _idNum = <span class="number">0</span>;     <span class="comment">//该属性无法被访问到</span>
}
Person.prototype = {
        run : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
                conosole.log(<span class="keyword">this</span>.name + <span class="string">"在跑步"</span>);  <span class="comment">//公共方法</span>
        }
}
<span class="keyword">var</span> per1 = <span class="keyword">new</span> Person(<span class="string">"tian"</span>, <span class="number">12</span>);
</code></pre>
<p>原形方法和特权方法都属于实例方法，还有一种类方法或者类属性，我们直接在函数上定义就可以：Person.method = function(){}。遵循对象设计原则，类的所有成员都应该封装在类的结构体内，因此优化该模式，产生动态原形模式。</p>
<h2 id="动态原形模式"><a href="#动态原形模式" class="headerlink" title="动态原形模式"></a>动态原形模式</h2><p>把所有信息放在构造函数中，并且动态的判断是否具有某方法并创建  </p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>{
        <span class="keyword">this</span>.name = name;
        <span class="keyword">this</span>.age = age;
        <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.run === <span class="string">'undefined'</span>) {
                Person.prototype.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
                        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">"在跑步"</span>);
                }
        }
}
</code></pre>
<h2 id="其他模式"><a href="#其他模式" class="headerlink" title="其他模式"></a>其他模式</h2><p>寄生构造函数：类似工厂模式，将工厂中的对象实例o，换成指定构造器生成，常用来扩展一些JS本身构造函数，又不希望直接修改构造函数时候使用。比如扩展Array构造函数。<br>稳妥构造函数模式：一般用于安全的环境中。最后这两种方法直接十分类似，也不太常用，具体代码就不贴了都和工厂模式长得很像，有兴趣的自行查找。  </p>
<h1 id="Prototype原形与new操作符"><a href="#Prototype原形与new操作符" class="headerlink" title="Prototype原形与new操作符"></a>Prototype原形与new操作符</h1><p>在讨论继承之前，我们先探索一下原形链和new操作符在创建对象的时候的步骤。<br>首先：我们知道在当我们访问对象的一个属性或方法的时候，那么他会先找特权成员，如果有同名的就返回，没有就查找原形，在没有查找父类原形。我们通过组合模式创建的对象都有父类：Object。这种原形链的查找方式我们看看在修改prototype的时候会发生什么：  </p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>{}
Person.prototype = {
        name : <span class="string">"tian"</span>
}
<span class="keyword">var</span> per1 = <span class="keyword">new</span> Person();
<span class="built_in">console</span>.log(per1.name) <span class="comment">//tian</span>
Person.prototype = {
        name : <span class="string">"hyang"</span>     <span class="comment">//原形链断开，重写</span>
}
<span class="built_in">console</span>.log(per1.name) <span class="comment">//tian 不受影响</span>
<span class="function"><span class="keyword">function</span> <span class="title">Teacher</span>(<span class="params"></span>)</span>{}
Teacher.prototype = {
       name : <span class="string">"qiqi"</span>
}
per1.constructor = Teacher;
<span class="built_in">console</span>.log(per1.name)  <span class="comment">//tian 依然不受影响</span>
</code></pre>
<p>通过上述代码我们发现，当重写类的原形链的时候，已经生成的实例并不受任何影响，修改construct属性（该属性表示对象的构造函数），也没有任何效果。那么究竟什么才是对象回溯的依据呢？其实每个对象都有一个 <code>__proto__</code>属性。该属性保存着对象指向的原形。  </p>
<pre><code class="javascript"><span class="built_in">console</span>.log(per1.__proto__)   <span class="comment">//Object {name: "tian"}</span>
per1.__proto__ = Person.prototype;   <span class="comment">//修改__proto__属性</span>
<span class="built_in">console</span>.log(per1.name)   <span class="comment">//hyang</span>
per1.__proto__ = Teacher.prototype 
<span class="built_in">console</span>.log(per1.name)   <span class="comment">//qiqi</span>
</code></pre>
<p>在IE11以后和标准浏览器中该属性可以修改访问，之前的该属性不暴露。于是我们得出new操作符在执行的时候过程（参考Person类）：</p>
<blockquote>
<p>1）创建一个空对象obj<br>2）obj.<strong>proto</strong> = Person.prototype (引用)<br>3）将构造器中this = obj<br>4）执行构造器里面的代码<br>5）判断有没有返回值，没有返回值默认undefined，有返回值且为复合类型则返回该类型，否则返回this如果通过new生成对象的时候，忘记加上new了，那么属性会保存在哪儿里呢？  </p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>{
        <span class="keyword">this</span>.name = name;
}
<span class="keyword">var</span> per = Person(<span class="string">"tian"</span>);
per   <span class="comment">//'undefined'</span>
<span class="built_in">console</span>.log(<span class="built_in">window</span>.name) <span class="comment">//'tian'</span>
</code></pre>
<p>可以看到没有加new操作符，Person中的this会被解释称window对象，全局变量就很容易受到污染，谨慎使用new操作符。  </p>
</blockquote>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>Javascript实现继承，通过上面我们知道只要prototype有什么，那么实例就有什么；如果我们将类prototype置换为另一类的prototype，那么该类就可以轻易得到类的原型成员。但是由于对象是引用类型，所以不能直接替换  </p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>{}  <span class="comment">//父类</span>
Person.prototype = {
        <span class="string">"name"</span> : <span class="string">"tian"</span>
}
<span class="function"><span class="keyword">function</span> <span class="title">Teacher</span>(<span class="params"></span>)</span>{}    <span class="comment">//子类</span>
Teacher.prototype = Person.prototype;
</code></pre>
<p>这样Teacher的原形保存的是对Person的引用，修改Teacher会同时修改Person。解决的方法有两个，一个是通过for in把父类原型逐一赋给子类的原形（拷贝继承）；第二种现将父类的原形赋给一个函数，然后将该函数的实例作为子类的原形。<br>方法1：  </p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">child, super</span>) </span>{
        <span class="keyword">for</span>(<span class="keyword">var</span> property <span class="keyword">in</span> <span class="keyword">super</span>) {
                child[property] = <span class="keyword">super</span>[property];
        }
        <span class="keyword">return</span> child;
}
</code></pre>
<p>该方法有一个缺陷，就是无法通过instanceof验证。<br>方法2 原型继承：  </p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>{
        <span class="keyword">this</span>.name = name;
}
Person.prototype = {
        <span class="string">"run"</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
                <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">"跑步"</span>)
        }
}

<span class="function"><span class="keyword">function</span> <span class="title">birdge</span>(<span class="params"></span>)</span>{}
birdge.prototype = Person.prototype;

<span class="function"><span class="keyword">function</span> <span class="title">Teacher</span>(<span class="params">name, wage</span>)</span>{
        <span class="keyword">this</span>.name = name;
        <span class="keyword">this</span>.wage = wage;
}
Teacher.prototype = <span class="keyword">new</span> birdge();
<span class="keyword">var</span> per = <span class="keyword">new</span> Person(<span class="string">"tian"</span>);
<span class="keyword">var</span> tea = <span class="keyword">new</span> Teacher(<span class="string">"hyang"</span>,<span class="number">10</span>);
Person.prototype === Teacher.prototype;  <span class="comment">// false 说明原型已经分离</span>
Person.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)
} <span class="comment">//为父类添加一个方法</span>
tea.say()    <span class="comment">//hyang  说明子类得到了父类新添加的方法</span>
Teacher.prototype.getWage = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
    <span class="built_in">console</span>.log(<span class="keyword">this</span>.wage);
}
per.getWage;  <span class="comment">//'undefined' 说明子类添加的方法并没有影响到父类</span>
</code></pre>
<p>这样我们就完成了类的原型继承，我们给子类原形添加的新方法，其实是保存在了生成的new bridge()那个对象中（Teacher的原型保存的是对new bridge这个对象的引用）  </p>
<pre><code class="javascript">per.__proto__                  <span class="comment">//Object {run: function, say: function}</span>
tea.__proto__                  <span class="comment">//birdge {getWage: function, run: function, say: function}</span>
tea.__proto__.__proto__  <span class="comment">//Object {run: function, say: function}</span>
</code></pre>
<p>这里我们可以清除的看到对象各自的原型是什么，中介函数bridge的使用在ES5中有更加简单的方法 Object.create(原型)这样就可以创建出一个具有指定原形的对象。对于不支持Object.create我们可以自己定义该函数   </p>
<pre><code class="javascript"><span class="keyword">if</span>(!<span class="built_in">Object</span>.create){
        <span class="built_in">Object</span>.create= (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
                <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>{}   <span class="comment">//创建中介函数（bridge）</span>
                <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>{
                        <span class="keyword">if</span>(<span class="built_in">arguments</span>.length !== <span class="number">1</span>) {
                                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"仅支持一个参数"</span>);
                        }
                        F.prototype = obj;   <span class="comment">//原形绑定</span>
                        <span class="keyword">return</span> <span class="keyword">new</span> F();      <span class="comment">//返回实例</span>
                }
        })()
}
</code></pre>
<p>这样上述继承就可以改写成，Teacher.prototype = Object.create(Person.prototype)。对于特权属性和函并没有在原型链中，我们可以采用借用构造函数来继承，于是上面Teacher子类修改为    </p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">Teacher</span>(<span class="params">name, wage</span>) </span>{
        Person.call(<span class="keyword">this</span>, name);   <span class="comment">//调用父类的构造方法，实现特权函数继承;</span>
        <span class="keyword">this</span>.wage = wage;
}
</code></pre>
<p>综上两种当时组合在一起，就是我们常用的类的类的继承方法（组合继承）。  还有其他的继承方式比如寄生式继承，寄生组合式继承，这些方法个人用的比较少，有兴趣的可以自己参考。  </p>
<h1 id="类工厂"><a href="#类工厂" class="headerlink" title="类工厂"></a>类工厂</h1><p>js作为一个基于对象的语言，本身并没有提供class这一概念，通过上一篇文章Javascript 类工厂Ⅰ - 类与继承我们明白了类的继承原理，为此我们可以实现一个属于的简单的OO原型继承。  </p>
<pre><code class="javascript"><span class="comment">/**</span>
<span class="comment"> * 提供简单的OO原型继承</span>
<span class="comment"> */</span>
(<span class="function"><span class="keyword">function</span>(<span class="params">global</span>) </span>{
<span class="meta">    "use strict"</span>
    global.Class = {
        <span class="comment">/**</span>
<span class="comment">         * @param superclass  父类</span>
<span class="comment">         * @param definition  类的属性设置</span>
<span class="comment">         * @returns {_Object}  返回生成好的类</span>
<span class="comment">         */</span>
        create : <span class="function"><span class="keyword">function</span>(<span class="params">superclass, definition</span>) </span>{
            <span class="keyword">if</span>(<span class="built_in">arguments</span>.length === <span class="number">1</span>) {
                definition = superclass;
                superclass = <span class="built_in">Object</span>;
            }
            <span class="keyword">if</span>(<span class="keyword">typeof</span> superclass !== <span class="string">"function"</span>) {
                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"superclass must be fun"</span>);
            }
            <span class="keyword">var</span> _super = superclass.prototype;

            <span class="comment">//删去静态方法（静态方法不能被继承）</span>
            <span class="keyword">var</span> statics = definition.statics;
            <span class="keyword">delete</span> definition.statics;

            <span class="comment">// 用于返回的中间类,调去deinition对象中的内容</span>
            <span class="function"><span class="keyword">function</span> <span class="title">_Object</span>(<span class="params"></span>) </span>{
                <span class="keyword">this</span>.init.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);
            }
            _Object.prototype = <span class="built_in">Object</span>.create(_super);

            <span class="comment">//_super 属性保存父类原型</span>
            _Object.prototype._super = _super;
            _Object.prototype.constructor = _Object;
           <span class="comment">//确保一定存在init方法</span>
            <span class="keyword">if</span>(<span class="keyword">typeof</span> _Object.prototype.init !== <span class="string">'function'</span>) {
                _Object.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
                    superclass.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);
                }
            }
            <span class="comment">//copy对象内容到原型中</span>
            <span class="keyword">for</span>(<span class="keyword">var</span> name <span class="keyword">in</span> definition) {
                _Object.prototype[name] = definition[name];
            }

           <span class="comment">//绑定静态内容</span>
            _Object.statics = {};
            <span class="keyword">for</span>(<span class="keyword">var</span> name <span class="keyword">in</span> statics) {
                _Object.statics[name] = statics[name];
            }

            <span class="keyword">return</span> _Object;
        }
    }

})(<span class="keyword">this</span>);
</code></pre>
<h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><p>通过Class.create([properties])创建类，properties为属性对象;<br>init 初始化方法，会在创建实例是被调用<br>statics 类的静态方法，ClassName.fn()   </p>
<pre><code class="javascript"><span class="keyword">var</span> Person = Class.create({
    init : <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>{
        <span class="keyword">this</span>.name = name;
        <span class="keyword">this</span>.age = age;
    },
    statics : {
       <span class="string">"name"</span> : <span class="string">"Person"</span>,
       <span class="string">"type"</span> : <span class="string">"Class"</span>
    }
})
<span class="keyword">var</span> per = <span class="keyword">new</span> Person(<span class="string">"phantom"</span>, <span class="number">1</span>);
</code></pre>
<p>使用Class.create(superClass, properties) 继承父类superClass</p>
<p>this._super 保存有父类属性，可以用于子类中调用父类方法。  </p>
<pre><code class="javascript"><span class="keyword">var</span> Teacher = Class.create(Person, {
    init : <span class="function"><span class="keyword">function</span>(<span class="params">name, age, school</span>) </span>{
        <span class="keyword">this</span>._super.init.call(<span class="keyword">this</span>, name, age);  <span class="comment">//调用父类init</span>
        <span class="keyword">this</span>.school = school;
    },
    teach : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">"上课呢"</span>);
    }
})
<span class="keyword">var</span> te = <span class="keyword">new</span> Teacher(<span class="string">"cjk"</span>, <span class="number">30</span>, <span class="string">'t_hot'</span>);
</code></pre>
<h1 id="ES6的类扩展"><a href="#ES6的类扩展" class="headerlink" title="ES6的类扩展"></a>ES6的类扩展</h1><p>ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。  </p>
<pre><code class="javascript"><span class="comment">//定义类</span>
<span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>{
  <span class="keyword">constructor</span>(x, y) {
    <span class="keyword">this</span>.x = x;
    <span class="keyword">this</span>.y = y;
  }
  toString() {
    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;
  }
}
</code></pre>
<p>上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。</p>
<p>继承类:<br>Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。<br><code>class ColorPoint extends Point {}</code><br>上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。下面，我们在ColorPoint内部加上代码。  </p>
<pre><code class="javascript"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>{
  <span class="keyword">constructor</span>(x, y, color) {
    <span class="keyword">super</span>(x, y); <span class="comment">// 调用父类的constructor(x, y)</span>
    <span class="keyword">this</span>.color = color;
  }
  toString() {
    <span class="keyword">return</span> <span class="keyword">this</span>.color + <span class="string">' '</span> + <span class="keyword">super</span>.toString(); <span class="comment">// 调用父类的toString()</span>
  }
}
</code></pre>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>参考资料如下：  </p>
<ul>
<li><a href="http://product.dangdang.com/1900470931.html" target="_blank" rel="external">javascript高级程序设计第三版</a></li>
<li>Prototype.js源码</li>
<li><a href="https://item.jd.com/11436424.html" target="_blank" rel="external">jQuery框架设计</a></li>
<li><a href="https://github.com/T-phantom" target="_blank" rel="external">PhantomUI组件库</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;类的创建&quot;&gt;&lt;a href=&quot;#类的创建&quot; class=&quot;headerlink&quot; title=&quot;类的创建&quot;&gt;&lt;/a&gt;类的创建&lt;/h1&gt;&lt;p&gt;在面向对象语言中，类是面向对象的基础，并且具有棉线的层次概念和继承关系。Javascript中并没有类的概念，Javascript是基于对象的弱类型语言，以对象为基础，以函数为模型，以原形为继承机制的一种模式。创建一个简单的对象，就是创建一个Object类的实例。虽然Object构造函数或对象字面量可以用来创建单个对象，但是这些对象都是基于Object这一个类。为此我们需要创建自己的类，Javascript中创建类的方式有很多种：工厂模式，构造函数模式，原形模式，动态原形模式，寄生构造模式，稳妥构造模式。&lt;br&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
</feed>
